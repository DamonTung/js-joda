{"version":3,"file":"js-joda.js","sources":["../src/errors.js","../src/assert.js","../src/MathUtil.js","../src/Enum.js","../src/temporal/TemporalAmount.js","../src/temporal/TemporalUnit.js","../src/Duration.js","../src/YearConstants.js","../src/temporal/ChronoUnit.js","../src/temporal/TemporalField.js","../src/temporal/ValueRange.js","../src/temporal/ChronoField.js","../src/temporal/TemporalQueries.js","../src/temporal/TemporalAccessor.js","../src/temporal/Temporal.js","../src/temporal/TemporalQuery.js","../src/DayOfWeek.js","../src/StringUtil.js","../src/ZoneId.js","../src/zone/ZoneRules.js","../src/ZoneOffset.js","../src/Period.js","../src/format/ParsePosition.js","../src/format/EnumMap.js","../src/format/ResolverStyle.js","../src/format/DateTimeBuilder.js","../src/format/DateTimeParseContext.js","../src/format/DateTimePrintContext.js","../src/format/SignStyle.js","../src/format/StringBuilder.js","../src/format/DateTimeFormatter.js","../src/chrono/ChronoLocalDate.js","../src/temporal/IsoFields.js","../src/format/DecimalStyle.js","../src/format/TextStyle.js","../src/format/parser/CharLiteralPrinterParser.js","../src/format/parser/CompositePrinterParser.js","../src/format/parser/FractionPrinterParser.js","../src/format/parser/NumberPrinterParser.js","../src/format/parser/OffsetIdPrinterParser.js","../src/format/parser/PadPrinterParserDecorator.js","../src/format/parser/SettingsParser.js","../src/format/parser/StringLiteralPrinterParser.js","../src/zone/ZoneRulesProvider.js","../src/ZoneRegion.js","../src/format/parser/ZoneIdPrinterParser.js","../src/format/DateTimeFormatterBuilder.js","../src/Month.js","../src/MonthDay.js","../src/YearMonth.js","../src/Year.js","../src/temporal/TemporalAdjuster.js","../src/temporal/TemporalAdjusters.js","../src/chrono/IsoChronology.js","../src/chrono/ChronoZonedDateTime.js","../src/ZonedDateTime.js","../src/LocalDate.js","../src/chrono/ChronoLocalDateTime.js","../src/LocalDateTime.js","../src/LocalTime.js","../src/Instant.js","../src/Clock.js","../src/zone/ZoneOffsetTransition.js","../src/temporal/TemporalQueriesFactory.js","../src/zone/SystemDefaultZoneRules.js","../src/zone/SystemDefaultZoneId.js","../src/ZoneIdFactory.js","../src/_init.js","../src/convert.js","../src/temporal/NativeJsTemporal.js","../src/use.js","../src/js-joda.js"],"sourcesContent":["/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init, superErrorClass = Error) {\n    function E(message) {\n        if (!Error.captureStackTrace){\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n        this.toString = function () {\n            return `${this.name}: ${this.message}`;\n        };\n    }\n    E.prototype = new superErrorClass();\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    return E;\n}\n\nexport const DateTimeException = createErrorType('DateTimeException', messageWithCause);\nexport const DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nexport const UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nexport const ArithmeticException = createErrorType('ArithmeticException');\nexport const IllegalArgumentException = createErrorType('IllegalArgumentException');\nexport const IllegalStateException = createErrorType('IllegalStateException');\nexport const NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause = null) {\n    let msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text = '', index = 0, cause = null) {\n    let msg = message || this.name;\n    msg += ': ' + text + ', at index: ' + index;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n    this.parsedString = () => {\n        return text;\n    };\n    this.errorIndex = () => {\n        return index;\n    };\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {NullPointerException, IllegalArgumentException} from './errors';\n\nexport function assert(assertion, msg, error) {\n    if(!assertion){\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(parameterName + ' must not be null');\n    }\n    return value;\n}\n\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));\n    }\n    return value;\n}\n\nexport function abstractMethodFail(methodName){\n    throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {ArithmeticException} from './errors';\n\nexport const MAX_SAFE_INTEGER = 9007199254740991;\nexport const MIN_SAFE_INTEGER = -9007199254740991;\n\n/**\n * Math helper with static function for integer operations\n */\nexport class MathUtil {\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intDiv(x, y) {\n        let r = x/y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intMod(x, y) {\n        let r = x - MathUtil.intDiv(x, y) * y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} r\n     * @returns {number}\n     */\n    static roundDown(r){\n        if (r < 0) {\n            return Math.ceil(r);\n        } else {\n            return Math.floor(r);\n        }\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorDiv(x, y){\n        const r = Math.floor(x / y);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorMod(x, y){\n        const r = x - MathUtil.floorDiv(x, y) * y;\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeAdd(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        const r = MathUtil.safeToInt(x + y);\n        if (r === x || r === y) {\n            throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n        }\n        return r;\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeSubtract(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0 && y === 0) {\n            return 0;\n        } else if (x === 0) {\n            return MathUtil.safeZero(-1 * y);\n        } else if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        return MathUtil.safeToInt(x - y);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeMultiply(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 1) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 1) {\n            return MathUtil.safeZero(x);\n        }\n        if (x === 0 || y === 0) {\n            return 0;\n        }\n        const r = MathUtil.safeToInt(x * y);\n        if (r / y !== x || (x === MIN_SAFE_INTEGER && y === -1) || (y === MIN_SAFE_INTEGER && x === -1)) {\n            throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);\n        }\n        return r;\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static parseInt(value) {\n        const r = parseInt(value);\n        return MathUtil.safeToInt(r);\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static safeToInt(value) {\n        MathUtil.verifyInt(value);\n        return MathUtil.safeZero(value);\n    }\n\n    /**\n     *\n     * @param {number} value\n     */\n    static verifyInt(value){\n        if (value == null) {\n            throw new ArithmeticException(`Invalid value: '${value}', using null or undefined as argument`);\n        }\n        if (isNaN(value)) {\n            throw new ArithmeticException('Invalid int value, using NaN as argument');\n        }\n        if ((value % 1) !== 0) {\n            throw new ArithmeticException(`Invalid value: '${value}' is a float`);\n        }\n        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n            throw new ArithmeticException('Calculation overflows an int: ' + value);\n        }\n    }\n\n    /**\n     * convert -0 to 0 and int as string to a number ( '1' -> 1 )\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static safeZero(value){\n        return value === 0 ? 0 : +value;\n    }\n\n    /**\n     * Compares two Numbers.\n     *\n     * @param {number} a  the first value\n     * @param {number} b  the second value\n     * @return {number} the result\n     */\n    static compareNumbers(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n\n    // convert to small integer for v8 optimisation\n    static smi(int) {\n        return ((int >>> 1) & 0x40000000) | (int & 0xBFFFFFFF);\n    }\n\n    // calculate 32 bit hash of a number and convert to SMI\n    static hash(number) {\n        if (number !== number || number === Infinity) {\n            return 0;\n        }\n        let result = number;\n        while (number > 0xFFFFFFFF) {\n            number /= 0xFFFFFFFF;\n            result ^= number;\n        }\n        return MathUtil.smi(result);\n    }\n\n    // default hashCode calculation for a number sequence as mentioned by Joshua Bloch\n    static hashCode(...numbers) {\n        let result = 17;\n        for (const n of numbers) {\n            result = (result << 5) - result + MathUtil.hash(n);\n        }\n        return MathUtil.hash(result);\n    }\n}\n\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n/***\n * Base class for a pseudo enum\n */\nexport class Enum {\n    constructor(name){\n        this._name = name;\n    }\n\n    equals(other){\n        return this === other;\n    }\n\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * Framework-level interface defining an amount of time, such as\n * \"6 hours\", \"8 days\" or \"2 years and 3 months\".\n *\n * This is the base interface type for amounts of time.\n * An amount is distinct from a date or time-of-day in that it is not tied\n * to any specific point on the time-line.\n *\n * The amount can be thought of as a {@link Map} of {@link TemporalUnit} to\n * `long`, exposed via {@link getUnits} and {@link get}.\n * A simple case might have a single unit-value pair, such as \"6 hours\".\n * A more complex case may have multiple unit-value pairs, such as\n * \"7 years, 3 months and 5 days\".\n *\n * There are two common implementations.\n * {@link Period} is a date-based implementation, storing years, months and days.\n * {@link Duration} is a time-based implementation, storing seconds and nanoseconds,\n * but providing some access using other duration based units such as minutes,\n * hours and fixed 24-hour days.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link Period} and {@link Duration}.\n *\n * @interface\n */\nexport class TemporalAmount {\n    /**\n     * Returns the value of the requested unit.\n     * The units returned from {@link getUnits} uniquely define the\n     * value of the {@link TemporalAmount}.  A value must be returned\n     * for each unit listed in {@link getUnits}.\n     *\n     * @implSpec\n     * Implementations may declare support for units not listed by {@link getUnits}.\n     * Typically, the implementation would define additional units\n     * as conversions for the convenience of developers.\n     *\n     * @param {TemporalUnit} unit - the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if a value for the unit cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the {@link unit} is not supported\n     */\n    // eslint-disable-next-line no-unused-vars\n    get(unit) {\n        abstractMethodFail('get');\n    }\n    \n    /**\n     * Returns the list of units uniquely defining the value of this TemporalAmount.\n     * The list of {@link TemporalUnits} is defined by the implementation class.\n     * The list is a snapshot of the units at the time {@link getUnits}\n     * is called and is not mutable.\n     * The units are ordered from longest duration to the shortest duration\n     * of the unit.\n     *\n     * @implSpec\n     * The list of units completely and uniquely represents the\n     * state of the object without omissions, overlaps or duplication.\n     * The units are in order from longest duration to shortest.\n     *\n     * @return {TemporalUnit[]} the List of {@link TemporalUnits}; not null\n     */\n    units() {\n        abstractMethodFail('units');\n    }\n    \n    /**\n     * Adds to the specified temporal object.\n     *\n     * Adds the amount to the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // These two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.addTo(dateTime);\n     *   dateTime = dateTime.plus(adder);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and add to it.\n     * The implementation defines the logic of the addition and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the addition.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to add the amount to, not null\n     * @return {Temporal} an object of the same observable type with the addition made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(temporal) {\n        abstractMethodFail('addTo');\n    }\n    \n    /**\n     * Subtracts this object from the specified temporal object.\n     *\n     * Subtracts the amount from the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#minus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(amount);\n     * </pre>\n     * It is recommended to use the second approach, {@link minus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and subtract from it.\n     * The implementation defines the logic of the subtraction and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the subtraction.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to subtract the amount from, not null\n     * @return {Temporal} an object of the same observable type with the subtraction made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    subtractFrom(temporal) {\n        abstractMethodFail('subtractFrom');\n    }\n    \n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * A unit of date-time, such as Days or Hours.\n *\n * Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.\n * Implementations of this interface represent those units.\n *\n * An instance of this interface represents the unit itself, rather than an amount of the unit.\n * See {@link Period} for a class that represents an amount in terms of the common units.\n *\n * The most commonly used units are defined in {@link ChronoUnit}.\n * Further units are supplied in {@link IsoFields}.\n * Units can also be written by application code by implementing this interface.\n *\n * The unit works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the unit is a {@link ChronoUnit}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalUnit {\n    /**\n     * Gets the duration of this unit, which may be an estimate.\n     *\n     * All units return a duration measured in standard nanoseconds from this method.\n     * The duration will be positive and non-zero.\n     * For example, an hour has a duration of `60 * 60 * 1,000,000,000ns`.\n     *\n     * Some units may return an accurate duration while others return an estimate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * To determine if the duration is an estimate, use {@link isDurationEstimated}.\n     *\n     * @return {Duration} the duration of this unit, which may be an estimate, not null\n     */\n    duration() {\n        abstractMethodFail('duration');\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     *\n     * All units have a duration, however the duration is not always accurate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * This method returns true if the duration is an estimate and false if it is\n     * accurate. Note that accurate/estimated ignores leap seconds.\n     *\n     * @return {boolean} true if the duration is estimated, false if accurate\n     */\n    isDurationEstimated() {\n        abstractMethodFail('isDurationEstimated');\n    }\n\n    /**\n     * Checks if this unit is date-based.\n     *\n     * @return {boolean} true if date-based\n     */\n    isDateBased() {\n        abstractMethodFail('isDateBased');\n    }\n\n    /**\n     * Checks if this unit is time-based.\n     *\n     * @return {boolean} true if time-based\n     */\n    isTimeBased() {\n        abstractMethodFail('isTimeBased');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     *\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     *\n     * @param {Temporal} temporal  the temporal object to check, not null\n     * @return {boolean} true if the unit is supported\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupportedBy(temporal) {\n        abstractMethodFail('isSupportedBy');\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     *\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.doPlus(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {Temporal} dateTime  the temporal object to adjust, not null\n     * @param {number} periodToAdd  the period of this unit to add, positive or negative\n     * @return {Temporal} the adjusted temporal object, not null\n     * @throws DateTimeException if the period cannot be added\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(dateTime, periodToAdd) {\n        abstractMethodFail('addTo');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the period in terms of this unit between two temporal objects of the same type.\n     *\n     * This calculates the period between two temporals in terms of this unit.\n     * The start and end points are supplied as temporal objects and must be of the same type.\n     * The result will be negative if the end is before the start.\n     * For example, the period in hours between two temporal objects can be calculated\n     * using {@link HOURS.between}.\n     *\n     * The calculation returns a whole number, representing the number of complete units between the two temporals.\n     * For example, the period in hours between the times 11:30 and 13:29 will only b\n     * one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * For example, this method allows the number of days between two dates to be calculated:\n     * <pre>\n     *   long daysBetween = DAYS.between(start, end);\n     *   // or alternatively\n     *   long daysBetween = start.until(end, DAYS);\n     * </pre>\n     * Implementations should perform any queries or calculations using the units available in\n     * {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported a DateTimeException must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @param {Temporal} temporal1  the base temporal object, not null\n     * @param {Temporal} temporal2  the other temporal object, not null\n     * @return {number} the period between temporal1 and temporal2 in terms of this unit;\n     *  positive if temporal2 is later than temporal1, negative if earlier\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    between(temporal1, temporal2) {\n        abstractMethodFail('between');\n    }\n\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {requireNonNull, requireInstance} from './assert';\nimport {ArithmeticException, DateTimeParseException, UnsupportedTemporalTypeException} from './errors';\nimport {MathUtil, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalAmount} from './temporal/TemporalAmount';\nimport {TemporalUnit} from './temporal/TemporalUnit';\n\nimport {LocalTime} from './LocalTime';\n\n/**\n * A time-based amount of time, such as '34.5 seconds'.\n *\n * This class models a quantity or amount of time in terms of seconds and nanoseconds.\n * It can be accessed using other duration-based units, such as minutes and hours.\n * In addition, the {@link ChronoUnit#DAYS} unit can be used and is treated as\n * exactly equal to 24 hours, thus ignoring daylight savings effects.\n * See {@link Period} for the date-based equivalent to this class.\n *\n * A physical duration could be of infinite length.\n * For practicality, the duration is stored with constraints similar to {@link Instant}.\n * The duration uses nanosecond resolution with a maximum value of the seconds that can\n * be held in a `long`. This is greater than the current estimated age of the universe.\n *\n * The range of a duration requires the storage of a number larger than a `long`.\n * To achieve this, the class stores a `long` representing seconds and an `int`\n * representing nanosecond-of-second, which will always be between 0 and 999,999,999.\n *\n * The duration is measured in \"seconds\", but these are not necessarily identical to\n * the scientific \"SI second\" definition based on atomic clocks.\n * This difference only impacts durations measured near a leap-second and should not affect\n * most applications.\n * See {@link Instant} for a discussion as to the meaning of the second and time-scales.\n *\n * ### Static properties of Class {@link Duration}\n *\n * Duration.ZERO\n *\n * Constant for a duration of zero.\n *\n */\nexport class Duration extends TemporalAmount /*implements TemporalAmount, Comparable<Duration>, Serializable */ {\n\n    /**\n     * Constructs an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanos - the nanoseconds within the second, from 0 to 999,999,999\n     * @private\n     */\n    constructor(seconds, nanos) {\n        super();\n        this._seconds = MathUtil.safeToInt(seconds);\n        this._nanos = MathUtil.safeToInt(nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard 24 hour days.\n     *\n     * The seconds are calculated based on the standard definition of a day,\n     * where each day is 86400 seconds which implies a 24 hour day.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} days - the number of days, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input days exceeds the capacity of {@link Duration}\n     */\n    static ofDays(days) {\n        return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard hours.\n     *\n     * The seconds are calculated based on the standard definition of an hour,\n     * where each hour is 3600 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} hours - the number of hours, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input hours exceeds the capacity of {@link Duration}\n     */\n    static ofHours(hours) {\n        return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard minutes.\n     *\n     * The seconds are calculated based on the standard definition of a minute,\n     * where each minute is 60 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} minutes - the number of minutes, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input minutes exceeds the capacity of {@link Duration}\n     */\n    static ofMinutes(minutes) {\n        return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of seconds\n     * and an adjustment in nanoseconds.\n     *\n     * This method allows an arbitrary number of nanoseconds to be passed in.\n     * The factory will alter the values of the second and nanosecond in order\n     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n     * For example, the following will result in the exactly the same duration:\n     * <pre>\n     *  Duration.ofSeconds(3, 1);\n     *  Duration.ofSeconds(4, -999_999_999);\n     *  Duration.ofSeconds(2, 1000_000_001);\n     * </pre>\n     *\n     * @param {Number} seconds - the number of seconds, positive or negative\n     * @param {Number} nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@link Duration}\n     */\n    static ofSeconds(seconds, nanoAdjustment = 0) {\n        const secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Duration._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of milliseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {Number} millis - the number of milliseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofMillis(millis) {\n        let secs = MathUtil.intDiv(millis, 1000);\n        let mos = MathUtil.intMod(millis, 1000);\n        if (mos < 0) {\n            mos += 1000;\n            secs--;\n        }\n        return Duration._create(secs, mos * 1000000);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of nanoseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified nanoseconds.\n     *\n     * @param {Number} nanos - the number of nanoseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofNanos(nanos) {\n        let secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n        if (nos < 0) {\n            nos += LocalTime.NANOS_PER_SECOND;\n            secs--;\n        }\n        return this._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a duration in the specified unit.\n     *\n     * The parameters represent the two parts of a phrase like '6 Hours'. For example:\n     * <pre>\n     *  Duration.of(3, SECONDS);\n     *  Duration.of(465, HOURS);\n     * </pre>\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * @param {Number} amount - the amount of the duration, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the duration is measured in, must have an exact duration, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the period unit has an estimated duration\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static of(amount, unit) {\n        return Duration.ZERO.plus(amount, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from an amount.\n     *\n     * This obtains a duration based on the specified amount.\n     * A TemporalAmount represents an amount of time, which may be date-based\n     * or time-based, which this factory extracts to a duration.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the duration of the unit to calculate the total Duration.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration or be ChronoUnit.DAYS which\n     * is treated as 24 hours. If any other units are found then an exception is thrown.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Duration} the resulting duration, not null\n     * @throws DateTimeException if the amount cannot be converted\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static from(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount);\n        let duration = Duration.ZERO;\n        amount.units().forEach((unit) => {\n            duration = duration.plus(amount.get(unit), unit);\n        });\n        return duration;\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} representing the duration between two instants.\n     *\n     * Obtains a {@link Duration} representing the duration between two instants.\n     * This calculates the duration between two temporal objects of the same type.\n     * The difference in seconds is calculated using {@link Temporal#until}.\n     * The difference in nanoseconds is calculated using by querying the\n     * {@link ChronoField#NANO_OF_SECOND} field.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * To guarantee to obtain a positive duration call abs() on the result.\n     *\n     * @param {Temporal} startInclusive - the start instant, inclusive, not null\n     * @param {Temporal} endExclusive - the end instant, exclusive, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the seconds between the temporals cannot be obtained\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@link Duration}\n     */\n    static between(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        let secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n        let nanos = 0;\n        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n            try {\n                const startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n                nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n                if (secs > 0 && nanos < 0) {\n                    nanos += LocalTime.NANOS_PER_SECOND;\n                } else if (secs < 0 && nanos > 0) {\n                    nanos -= LocalTime.NANOS_PER_SECOND;\n                } else if (secs === 0 && nanos !== 0) {\n                    // two possible meanings for result, so recalculate secs\n                    const adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n                    secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n                }\n            } catch (e) {\n                // ignore and only use seconds\n            }\n        }\n        return this.ofSeconds(secs, nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Duration} from a text string such as {@link PnDTnHnMn.nS}.\n     *\n     * This will parse a textual representation of a duration, including the\n     * string produced by {@link toString}. The formats accepted are based\n     * on the ISO-8601 duration format {@link PnDTnHnMn.nS} with days\n     * considered to be exactly 24 hours.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter \"P\" is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * The sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\n     * days, hours, minutes and seconds, accepted in upper or lower case.\n     * The suffixes must occur in order. The ASCII letter \"T\" must occur before\n     * the first occurrence, if any, of an hour, minute or second section.\n     * At least one of the four sections must be present, and if \"T\" is present\n     * there must be at least one section after the \"T\".\n     * The number part of each section must consist of one or more ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number of days, hours and minutes must parse to a `long`.\n     * The number of seconds must parse to a `long` with optional fraction.\n     * The decimal point may be either a dot or a comma.\n     * The fractional part may have from zero to 9 digits.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard.\n     *\n     * Examples:\n     * <pre>\n     *    \"PT20.345S\" -> parses as \"20.345 seconds\"\n     *    \"PT15M\"     -> parses as \"15 minutes\" (where a minute is 60 seconds)\n     *    \"PT10H\"     -> parses as \"10 hours\" (where an hour is 3600 seconds)\n     *    \"P2D\"       -> parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n     *    \"P2DT3H4M\"  -> parses as \"2 days, 3 hours and 4 minutes\"\n     *    \"P-6H3M\"    -> parses as \"-6 hours and +3 minutes\"\n     *    \"-P6H3M\"    -> parses as \"-6 hours and -3 minutes\"\n     *    \"-P-6H+3M\"  -> parses as \"+6 hours and -3 minutes\"\n     * </pre>\n     *\n     * @param {String} text - the text to parse, not null\n     * @return {Duration} the parsed duration, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a duration\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        /**\n         * The pattern for parsing.\n         */\n        const PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n        const matches = PATTERN.exec(text);\n        if (matches !== null) {\n            // check for letter T but no time sections\n            if ('T' === matches[3] === false) {\n                const negate = '-' === matches[1];\n                const dayMatch = matches[2];\n                const hourMatch = matches[4];\n                const minuteMatch = matches[5];\n                const secondMatch = matches[6];\n                const fractionMatch = matches[7];\n                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n                    const daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n                    const hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n                    const minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n                    const seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n                    const negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n                    const nanos = Duration._parseFraction(text,  fractionMatch, negativeSecs ? -1 : 1);\n                    try {\n                        return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n                    } catch (ex) {\n                        throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n                    }\n                }\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n    }\n\n    static _parseNumber(text, parsed, multiplier, errorText) {\n        // regex limits to [-+]?[0-9]+\n        if (parsed == null) {\n            return 0;\n        }\n        try {\n            if (parsed[0] === '+') {\n                parsed = parsed.substring(1);\n            }\n            return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n        } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);\n        }\n    }\n\n    static _parseFraction(text, parsed, negate) {\n        // regex limits to [0-9]{0,9}\n        if (parsed == null || parsed.length === 0) {\n            return 0;\n        }\n        parsed = (parsed + '000000000').substring(0, 9);\n        return parseFloat(parsed) * negate;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * to handle function overriding this function accepts any number of arguments, checks their type and delegates to the appropriate\n     * function\n     *\n     * @return {Duration}\n     */\n    static _create() {\n        if (arguments.length <= 2) {\n            return Duration._createSecondsNanos(arguments[0], arguments[1]);\n        } else {\n            return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n        }\n    }\n\n    static _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n        const seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n        if (negate) {\n            return Duration.ofSeconds(seconds, nanos).negated();\n        }\n        return Duration.ofSeconds(seconds, nanos);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanoAdjustment - the nanosecond adjustment within the second, from 0 to 999,999,999\n     */\n    static _createSecondsNanos(seconds = 0, nanoAdjustment = 0) {\n        if ((seconds | nanoAdjustment) === 0) {\n            return Duration.ZERO;\n        }\n        return new Duration(seconds, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the requested unit.\n     *\n     * This returns a value for each of the two supported units,\n     * {@link ChronoUnit#SECONDS} and {@link ChronoUnit#NANOS}.\n     * All other units throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the const value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.SECONDS) {\n            return this._seconds;\n        } else if (unit === ChronoUnit.NANOS) {\n            return this._nanos;\n        } else {\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n    }\n\n    units() {\n        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is zero length.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is zero.\n     *\n     * @return {boolean} true if this duration has a total length equal to zero\n     */\n    isZero() {\n        return (this._seconds | this._nanos) === 0;\n    }\n\n    /**\n     * Checks if this duration is negative, excluding zero.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is less than zero.\n     *\n     * @return {boolean} true if this duration has a total length less than zero\n     */\n    isNegative() {\n        return this._seconds < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of seconds in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getNano}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the whole seconds part of the length of the duration, positive or negative\n     */\n    seconds() {\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds within the second in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getSeconds}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified amount of seconds.\n     *\n     * This returns a duration with the specified seconds, retaining the\n     * nano-of-second part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} seconds - the seconds to represent, may be negative\n     * @return {Duration} based on this period with the requested seconds, not null\n     */\n    withSeconds(seconds) {\n        return Duration._create(seconds, this._nanos);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified nano-of-second.\n     *\n     * This returns a duration with the specified nano-of-second, retaining the\n     * seconds part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {Duration} based on this period with the requested nano-of-second, not null\n     * @throws DateTimeException if the nano-of-second is invalid\n     */\n    withNanos(nanoOfSecond) {\n        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n        return Duration._create(this._seconds, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to add, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        return this.plus(duration.seconds(), duration.nano());\n    }\n\n\n    /**\n     * function overloading for {@link Duration.plus}\n     *\n     * if called with 1 arguments, then {@link Duration.plusDuration} is executed.\n     *\n     * if called with 2 arguments and second argument is an instance of TemporalUnit, then {@link Duration.plusAmountUnit} is executed.\n     *\n     * Otherwise {@link Duration.plusSecondsNanos} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {!TemporaloUnit|number} unitOrNumber\n     * @returns {Duration}\n     */\n    plus(durationOrNumber, unitOrNumber) {\n        if (arguments.length === 1) {\n            return this.plusDuration(durationOrNumber);\n        }\n        else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n            return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n        } else {\n            return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToAdd - the amount to add, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.DAYS) {\n            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n        }\n        if (unit.isDurationEstimated()) {\n            throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n        }\n        if (amountToAdd === 0) {\n            return this;\n        }\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, (1000000 * 1000)) * 1000, MathUtil.intMod(amountToAdd, (1000000 * 1000)) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n            }\n            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n        }\n        const duration = unit.duration().multipliedBy(amountToAdd);\n        return this.plusSecondsNanos(duration.seconds(), duration.nano());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToAdd - the days to add, positive or negative\n     * @return {Duration} based on this duration with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToAdd - the hours to add, positive or negative\n     * @return {Duration} based on this duration with the specified hours added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusHours(hoursToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToAdd - the minutes to add, positive or negative\n     * @return {Duration} based on this duration with the specified minutes added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMinutes(minutesToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSeconds(secondsToAdd) {\n        return this.plusSecondsNanos(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusNanos(nanosToAdd) {\n        return this.plusSecondsNanos(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @param {Number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSecondsNanos(secondsToAdd, nanosToAdd) {\n        requireNonNull(secondsToAdd, 'secondsToAdd');\n        requireNonNull(nanosToAdd, 'nanosToAdd');\n        if ((secondsToAdd | nanosToAdd) === 0) {\n            return this;\n        }\n        let epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);  // safe int+LocalTime.NANOS_PER_SECOND\n        return Duration.ofSeconds(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Duration.minus}\n     *\n     * if called with 1 arguments and first argument is an instance of Duration, then {@link Duration.minusDuration} is executed.\n     *\n     * Otherwise {@link Duration.minusAmountUnit} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {?ChronoUnit} unit\n     * @return {Duration}\n     */\n    minus(durationOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusDuration(durationOrNumber);\n        } else {\n            return this.minusAmountUnit(durationOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to subtract, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        const secsToSubtract = duration.seconds();\n        const nanosToSubtract = duration.nano();\n        if (secsToSubtract === MIN_SAFE_INTEGER) {\n            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n        }\n        return this.plus(-secsToSubtract, -nanosToSubtract);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToSubtract - the amount to subtract, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return (amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToSubtract - the days to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return (daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToSubtract - the hours to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified hours subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusHours(hoursToSubtract) {\n        return (hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes subtracted.\n     *\n     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToSubtract - the minutes to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified minutes subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMinutes(minutesToSubtract) {\n        return (minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified seconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusSeconds(secondsToSubtract) {\n        return (secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return (millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToSubtract - the nanoseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return (nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration multiplied by the scalar.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} multiplicand - the value to multiply the duration by, positive or negative\n     * @return {Duration} based on this duration multiplied by the specified scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(multiplicand) {\n        if (multiplicand === 0) {\n            return Duration.ZERO;\n        }\n        if (multiplicand === 1) {\n            return this;\n        }\n        let secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n        let nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    /**\n     * Returns a copy of this duration divided by the specified value.\n     *\n     * In opposite to the threeten implementation the division is realized by floating point not by\n     * fixed point arithmetic. Expect floating point rounding errors for {@link Duration.dividedBy}.\n     *\n     * @param {Number} divisor - the value to divide the duration by, positive or negative, not zero\n     * @return {Duration} based on this duration divided by the specified divisor, not null\n     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs\n     */\n    dividedBy(divisor) {\n        if (divisor === 0) {\n            throw new ArithmeticException('Cannot divide by zero');\n        }\n        if (divisor === 1) {\n            return this;\n        }\n        const secs = MathUtil.intDiv(this._seconds, divisor);\n        const secsMod = MathUtil.roundDown(((this._seconds/ divisor) - secs) * LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intDiv(this._nanos, divisor);\n        nos = secsMod + nos;\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the length negated.\n     *\n     * This method swaps the sign of the total length of this duration.\n     * For example, {@link PT1.3S} will be returned as {@link PT-1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with the amount negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    /**\n     * Returns a copy of this duration with a positive length.\n     *\n     * This method returns a positive duration by effectively removing the sign from any negative total length.\n     * For example, {@link PT-1.3S} will be returned as {@link PT1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with an absolute length, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    abs() {\n        return this.isNegative() ? this.negated() : this;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this duration to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisDuration);\n     * </pre>\n     *\n     * The calculation will add the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this duration from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisDuration);\n     * </pre>\n     *\n     * The calculation will subtract the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of days in this duration.\n     *\n     * This returns the total number of days in the duration by dividing the\n     * number of seconds by 86400.\n     * This is based on the standard definition of a day as 24 hours.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of days in the duration, may be negative\n     */\n    toDays() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n    }\n\n    /**\n     * Gets the number of hours in this duration.\n     *\n     * This returns the total number of hours in the duration by dividing the\n     * number of seconds by 3600.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of hours in the duration, may be negative\n     */\n    toHours() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    }\n\n    /**\n     * Gets the number of minutes in this duration.\n     *\n     * This returns the total number of minutes in the duration by dividing the\n     * number of seconds by 60.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of minutes in the duration, may be negative\n     */\n    toMinutes() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    }\n\n    /**\n     * Converts this duration to the total length in milliseconds.\n     *\n     * If this duration is too large to fit in a `long` milliseconds, then an\n     * exception is thrown.\n     *\n     * If this duration has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the total length of the duration in milliseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toMillis() {\n        let millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n        return millis;\n    }\n\n    /**\n     * Converts this duration to the total length in nanoseconds expressed as a `long`.\n     *\n     * If this duration is too large to fit in a `long` nanoseconds, then an\n     * exception is thrown.\n     *\n     * @return {number} the total length of the duration in nanoseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toNanos() {\n        let totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n        return totalNanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this duration to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {Duration} otherDuration - the other duration to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(otherDuration) {\n        requireNonNull(otherDuration, 'otherDuration');\n        requireInstance(otherDuration, Duration, 'otherDuration');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherDuration.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is equal to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {*} otherDuration - the other duration, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherDuration) {\n        if (this === otherDuration) {\n            return true;\n        }\n        if (otherDuration instanceof Duration) {\n            return this.seconds() === otherDuration.seconds() &&\n                   this.nano() === otherDuration.nano();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A string representation of this duration using ISO-8601 seconds\n     * based representation, such as {@link PT8H6M12.345S}.\n     *\n     * The format of the returned string will be {@link PTnHnMnS}, where n is\n     * the relevant hours, minutes or seconds part of the duration.\n     * Any fractional seconds are placed after a decimal povar i the seconds section.\n     * If a section has a zero value, it is omitted.\n     * The hours, minutes and seconds will all have the same sign.\n     *\n     * Examples:\n     * <pre>\n     *    \"20.345 seconds\"                 -> \"PT20.345S\n     *    \"15 minutes\" (15 * 60 seconds)   -> \"PT15M\"\n     *    \"10 hours\" (10 * 3600 seconds)   -> \"PT10H\"\n     *    \"2 days\" (2 * 86400 seconds)     -> \"PT48H\"\n     * </pre>\n     * Note that multiples of 24 hours are not output as days to avoid confusion\n     * with {@link Period}.\n     *\n     * @return {string} an ISO-8601 representation of this duration, not null\n     */\n    toString() {\n        if (this === Duration.ZERO) {\n            return 'PT0S';\n        }\n        const hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n        const minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n        const secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n        let rval = 'PT';\n        if (hours !== 0) {\n            rval += hours + 'H';\n        }\n        if (minutes !== 0) {\n            rval += minutes + 'M';\n        }\n        if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n            return rval;\n        }\n        if (secs < 0 && this._nanos > 0) {\n            if (secs === -1) {\n                rval += '-0';\n            } else {\n                rval += secs + 1;\n            }\n        } else {\n            rval += secs;\n        }\n        if (this._nanos > 0) {\n            rval += '.';\n            let nanoString;\n            if (secs < 0) {\n                nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n            } else {\n                nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);\n            }\n            // remove the leading '1'\n            nanoString = nanoString.slice(1, nanoString.length);\n            rval += nanoString;\n            while (rval.charAt(rval.length - 1) === '0') {\n                rval = rval.slice(0, rval.length - 1);\n            }\n        }\n        rval += 'S';\n        return rval;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Duration.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Constant for a duration of zero.\n     */\n    Duration.ZERO = new Duration(0, 0);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n/**\n * attempt to avoid dependency cycles... define all constants here and they could be used\n * so instead of using e.g. Year.MAX_VALUE we could use YearConstants.MAX_VALUE to avoid the cycle\n */\nexport class YearConstants {}\n\nexport function _init() {\n    /**\n     * The minimum supported year\n     */\n    YearConstants.MIN_VALUE = -999999;\n    /**\n     * The maximum supported year\n     */\n    YearConstants.MAX_VALUE = 999999;\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from '../MathUtil';\n\nimport {Duration} from '../Duration';\nimport {YearConstants} from '../YearConstants';\nimport {TemporalUnit} from './TemporalUnit';\n\n/**\n * A standard set of date periods units.\n *\n * This set of units provide unit-based access to manipulate a date, time or date-time.\n * The standard set of units can be extended by implementing {@link TemporalUnit}.\n *\n * These units are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define units of years, months and days,\n * just with slightly different rules.\n * The documentation of each unit explains how it operates.\n *\n * ### Static properties of Class {@link ChronoUnit}\n *\n * ChronoUnit.NANOS\n *\n * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n *\n * ChronoUnit.MICROS\n *\n * Unit that represents the concept of a microsecond.\n * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n *\n * ChronoUnit.MILLIS\n *\n * Unit that represents the concept of a millisecond.\n * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n *\n * ChronoUnit.SECONDS\n *\n * Unit that represents the concept of a second.\n * For the ISO calendar system, it is equal to the second in the SI system\n * of units, except around a leap-second.\n *\n * ChronoUnit.MINUTES\n *\n * Unit that represents the concept of a minute.\n * For the ISO calendar system, it is equal to 60 seconds.\n *\n * ChronoUnit.HOURS\n *\n * Unit that represents the concept of an hour.\n * For the ISO calendar system, it is equal to 60 minutes.\n *\n * ChronoUnit.HALF_DAYS\n *\n * Unit that represents the concept of half a day, as used in AM/PM.\n * For the ISO calendar system, it is equal to 12 hours.\n *\n * ChronoUnit.DAYS\n *\n * Unit that represents the concept of a day.\n * For the ISO calendar system, it is the standard day from midnight to midnight.\n * The estimated duration of a day is 24 hours.\n *\n * When used with other calendar systems it must correspond to the day defined by\n * the rising and setting of the Sun on Earth. It is not required that days begin\n * at midnight - when converting between calendar systems, the date should be\n * equivalent at midday.\n *\n * ChronoUnit.WEEKS\n *\n * Unit that represents the concept of a week.\n * For the ISO calendar system, it is equal to 7 days.\n *\n * When used with other calendar systems it must correspond to an integral number of days.\n *\n * ChronoUnit.MONTHS\n *\n * Unit that represents the concept of a month.\n * For the ISO calendar system, the length of the month varies by month-of-year.\n * The estimated duration of a month is one twelfth of 365.2425 days.\n *\n * When used with other calendar systems it must correspond to an integral number of days.\n *\n * ChronoUnit.YEARS\n *\n * Unit that represents the concept of a year.\n * For the ISO calendar system, it is equal to 12 months.\n * The estimated duration of a year is 365.2425 days.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n *\n * ChronoUnit.DECADES\n *\n * Unit that represents the concept of a decade.\n * For the ISO calendar system, it is equal to 10 years.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.CENTURIES\n *\n * Unit that represents the concept of a century.\n * For the ISO calendar system, it is equal to 100 years.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.MILLENNIA\n *\n * Unit that represents the concept of a millennium.\n * For the ISO calendar system, it is equal to 1000 years.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.ERAS\n *\n * Unit that represents the concept of an era.\n * The ISO calendar system doesn't have eras thus it is impossible to add\n * an era to a date or date-time.\n * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n *\n * When used with other calendar systems there are no restrictions on the unit.\n *\n * ChronoUnit.FOREVER\n *\n * Artificial unit that represents the concept of forever.\n * This is primarily used with {@link TemporalField} to represent unbounded fields\n * such as the year or era.\n * The estimated duration of the era is artificially defined as the largest duration\n * supported by {@link Duration}.\n *\n */\nexport class ChronoUnit extends TemporalUnit {\n\n    /**\n     *\n     * @param {String} name\n     * @param {Duration} estimatedDuration\n     * @private\n     */\n    constructor (name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the estimated duration of this unit in the ISO calendar system.\n     *\n     * All of the units in this class have an estimated duration.\n     * Days vary due to daylight saving time, while months have different lengths.\n     *\n     * @return {Duration} the estimated duration of this unit, not null\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     *\n     * All time units in this class are considered to be accurate, while all date\n     * units in this class are considered to be estimated.\n     *\n     * This definition ignores leap seconds, but considers that Days vary due to\n     * daylight saving time and months have different lengths.\n     *\n     * @return {boolean} true if the duration is estimated, false if accurate\n     */\n    isDurationEstimated() {\n        return this.isDateBased() || this === ChronoUnit.FOREVER;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is a date unit.\n     *\n     * @return true if a date unit, false if a time unit\n     */\n    isDateBased() {\n        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n    }\n\n    /**\n     * Checks if this unit is a time unit.\n     *\n     * @return true if a time unit, false if a date unit\n     */\n    isTimeBased() {\n        return this.compareTo(ChronoUnit.DAYS) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     *\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     *\n     * This default implementation derives the value using\n     * {@link Temporal#plus}.\n     *\n     * @param {Temporal} temporal  the temporal object to check, not null\n     * @return {boolean} true if the unit is supported\n     */\n    isSupportedBy(temporal) {\n        if (this === ChronoUnit.FOREVER) {\n            return false;\n        }\n        /* TODO: classes not implemented yet */\n        /*\n        if (temporal instanceof ChronoLocalDate) {\n            return isDateBased();\n        }\n        if (temporal instanceof ChronoLocalDateTime || temporal instanceof ChronoZonedDateTime) {\n            return true;\n        }\n*/\n        try {\n            temporal.plus(1, this);\n            return true;\n        } catch (e) {\n            try {\n                temporal.plus(-1, this);\n                return true;\n            } catch (e2) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     *\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.addTo(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported an {@link UnsupportedTemporalTypeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @param {Number} amount  the amount of this unit to add, positive or negative\n     * @return {Temporal} the adjusted temporal object, not null\n     * @throws DateTimeException if the amount cannot be added\n     * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal\n     */\n    addTo(temporal, amount) {\n        return temporal.plus(amount, this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the amount of time between two temporal objects.\n     *\n     * This calculates the amount in terms of this unit. The start and end\n     * points are supplied as temporal objects and must be of compatible types.\n     * The implementation will convert the second type to be an instance of the\n     * first type before the calculating the amount.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in hours between two temporal objects can be\n     * calculated using {@link HOURS.between}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two temporals.\n     * For example, the amount in hours between the times 11:30 and 13:29\n     * will only be one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * For example, this method allows the number of days between two dates to\n     * be calculated:\n     * <pre>\n     *  daysBetween = DAYS.between(start, end);\n     *  // or alternatively\n     *  daysBetween = start.until(end, DAYS);\n     * </pre>\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported an {@link UnsupportedTemporalTypeException} must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @implSpec\n     * Implementations must begin by checking to if the two temporals have the\n     * same type using `.constructor.name`. If they do not, then the result must be\n     * obtained by calling `temporal1.until`.\n     *\n     * @param {Temporal} temporal1  the base temporal object, not null\n     * @param {Temporal} temporal2  the other temporal object, exclusive, not null\n     * @return {Number} the amount of time between temporal1 and temporal2\n     *  in terms of this unit; positive if temporal2 is later than\n     *  temporal1, negative if earlier\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to the same type as the start temporal\n     * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    between(temporal1, temporal2) {\n        return temporal1.until(temporal2, this);\n    }\n\n    //-----------------------------------------------------------------------\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * Compares this ChronoUnit to the specified {TemporalUnit}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {TemporalUnit} other  the other unit to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        return this.duration().compareTo(other.duration());\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n     * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n     */\n    ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n    /**\n     * Unit that represents the concept of a microsecond.\n     * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n     */\n    ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n    /**\n     * Unit that represents the concept of a millisecond.\n     * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n     */\n    ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n    /**\n     * Unit that represents the concept of a second.\n     * For the ISO calendar system, it is equal to the second in the SI system\n     * of units, except around a leap-second.\n     */\n    ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n    /**\n     * Unit that represents the concept of a minute.\n     * For the ISO calendar system, it is equal to 60 seconds.\n     */\n    ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n    /**\n     * Unit that represents the concept of an hour.\n     * For the ISO calendar system, it is equal to 60 minutes.\n     */\n    ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n    /**\n     * Unit that represents the concept of half a day, as used in AM/PM.\n     * For the ISO calendar system, it is equal to 12 hours.\n     */\n    ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n    /**\n     * Unit that represents the concept of a day.\n     * For the ISO calendar system, it is the standard day from midnight to midnight.\n     * The estimated duration of a day is 24 hours.\n     *\n     * When used with other calendar systems it must correspond to the day defined by\n     * the rising and setting of the Sun on Earth. It is not required that days begin\n     * at midnight - when converting between calendar systems, the date should be\n     * equivalent at midday.\n     */\n    ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n    /**\n     * Unit that represents the concept of a week.\n     * For the ISO calendar system, it is equal to 7 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n    /**\n     * Unit that represents the concept of a month.\n     * For the ISO calendar system, the length of the month varies by month-of-year.\n     * The estimated duration of a month is one twelfth of 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n    /**\n     * Unit that represents the concept of a year.\n     * For the ISO calendar system, it is equal to 12 months.\n     * The estimated duration of a year is 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n     */\n    ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n    /**\n     * Unit that represents the concept of a decade.\n     * For the ISO calendar system, it is equal to 10 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n    /**\n     * Unit that represents the concept of a century.\n     * For the ISO calendar system, it is equal to 100 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n    /**\n     * Unit that represents the concept of a millennium.\n     * For the ISO calendar system, it is equal to 1000 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n    /**\n     * Unit that represents the concept of an era.\n     * The ISO calendar system doesn't have eras thus it is impossible to add\n     * an era to a date or date-time.\n     * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n     *\n     * When used with other calendar systems there are no restrictions on the unit.\n     */\n    ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n    /**\n     * Artificial unit that represents the concept of forever.\n     * This is primarily used with {@link TemporalField} to represent unbounded fields\n     * such as the year or era.\n     * The estimated duration of the era is artificially defined as the largest duration\n     * supported by {@link Duration}.\n     */\n    ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * A field of date-time, such as month-of-year or hour-of-minute.\n *\n * Date and time is expressed using fields which partition the time-line into something\n * meaningful for humans. Implementations of this interface represent those fields.\n *\n * The most commonly used units are defined in {@link ChronoField}.\n * Further fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.\n * Fields can also be written by application code by implementing this interface.\n *\n * The field works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the field is a {@link ChronoField}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalField {}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from '../assert';\nimport {DateTimeException, IllegalArgumentException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\n/**\n * The range of valid values for a date-time field.\n *\n * All TemporalField instances have a valid range of values.\n * For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.\n * This class captures that valid range.\n *\n * It is important to be aware of the limitations of this class.\n * Only the minimum and maximum values are provided.\n * It is possible for there to be invalid values within the outer range.\n * For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus\n * have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.\n *\n * Instances of this class are not tied to a specific field.\n */\nexport class ValueRange {\n\n    /**\n     *\n     * @param {!number} minSmallest\n     * @param {!number} minLargest\n     * @param {!number} maxSmallest\n     * @param {!number} maxLargest\n     * @private\n     */\n    constructor(minSmallest, minLargest, maxSmallest, maxLargest) {\n        assert(!(minSmallest > minLargest), 'Smallest minimum value \\'' + minSmallest +\n            '\\' must be less than largest minimum value \\'' + minLargest + '\\'', IllegalArgumentException);\n        assert(!(maxSmallest > maxLargest), 'Smallest maximum value \\'' + maxSmallest +\n            '\\' must be less than largest maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n        assert(!(minLargest > maxLargest), 'Minimum value \\'' + minLargest +\n            '\\' must be less than maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n\n        this._minSmallest = minSmallest;\n        this._minLargest = minLargest;\n        this._maxLargest = maxLargest;\n        this._maxSmallest = maxSmallest;\n    }\n\n    /**\n     * Is the value range fixed and fully known.\n     *\n     * For example, the ISO day-of-month runs from 1 to between 28 and 31.\n     * Since there is uncertainty about the maximum value, the range is not fixed.\n     * However, for the month of January, the range is always 1 to 31, thus it is fixed.\n     *\n     * @return {boolean} true if the set of values is fixed\n     */\n    isFixed() {\n        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    minimum(){\n        return this._minSmallest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    largestMinimum(){\n        return this._minLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    maximum(){\n        return this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    smallestMaximum(){\n        return this._maxSmallest;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isValidValue(value) {\n        return (this.minimum() <= value && value <= this.maximum());\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @param {TemporalField} field\n     */\n    checkValidValue(value, field) {\n        let msg;\n        if (!this.isValidValue(value)) {\n            if (field != null) {\n                msg = ('Invalid value for ' + field + ' (valid values ' + (this.toString()) + '): ') + value;\n            } else {\n                msg = ('Invalid value (valid values ' + (this.toString()) + '): ') + value;\n            }\n            return assert(false, msg, DateTimeException);\n        }\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an `int`.\n     *\n     * This validates that the value is within the valid range of values and that\n     * all valid values are within the bounds of an `int`.\n     * The field is only used to improve the error message.\n     *\n     * @param {number} value - the value to check\n     * @param {TemporalField} field - the field being checked, may be null\n     * @return {number} the value that was passed in\n     * @see #isValidIntValue(long)\n     */\n    checkValidIntValue(value, field) {\n        if (this.isValidIntValue(value) === false) {\n            throw new DateTimeException('Invalid int value for ' + field + ': ' + value);\n        }\n        return value;\n    }\n\n    /**\n     * Checks if the value is within the valid range and that all values\n     * in the range fit in an `int`.\n     *\n     * This method combines {@link isIntValue} and {@link isValidValue}.\n     *\n     * @param {number} value - the value to check\n     * @return true if the value is valid and fits in an `int`\n     */\n    isValidIntValue(value) {\n        return this.isIntValue() && this.isValidValue(value);\n    }\n\n    /**\n     * Checks if all values in the range fit in an `int`.\n     *\n     * This checks that all valid values are within the bounds of an `int`.\n     *\n     * For example, the ISO month-of-year has values from 1 to 12, which fits in an `int`.\n     * By comparison, ISO nano-of-day runs from 1 to 86,400,000,000,000 which does not fit in an `int`.\n     *\n     * This implementation uses {@link getMinimum} and {@link getMaximum}.\n     *\n     * @return boolean if a valid value always fits in an `int`\n     */\n    isIntValue() { // should be isSafeIntegerValue\n        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if this range is equal to another range.\n     *\n     * The comparison is based on the four values, minimum, largest minimum,\n     * smallest maximum and maximum.\n     * Only objects of type {@link ValueRange} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other range\n     */\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ValueRange) {\n            return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest &&\n                this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this range.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);\n    }\n\n    /*\n     * Outputs this range as a String.\n     *\n     * The format will be '{min}/{largestMin} - {smallestMax}/{max}',\n     * where the largestMin or smallestMax sections may be omitted, together\n     * with associated slash, if they are the same as the min or max.\n     *\n     * @return {string} a string representation of this range, not null\n     */\n    toString() {\n        let str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + (this.largestMinimum()) : '');\n        str += ' - ';\n        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + (this.maximum()) : '');\n        return str;\n    }\n\n    /*\n     * called with 2 params: Obtains a fixed value range.\n     *\n     * This factory obtains a range where the minimum and maximum values are fixed.\n     * For example, the ISO month-of-year always runs from 1 to 12.\n     *\n     * @param min  the minimum value\n     * @param max  the maximum value\n     * @return the ValueRange for min, max, not null\n\n     * called with 3 params: Obtains a variable value range.\n     *\n     * This factory obtains a range where the minimum value is fixed and the maximum value may vary.\n     * For example, the ISO day-of-month always starts at 1, but ends between 28 and 31.\n     *\n     * @param min  the minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     * @return the ValueRange for min, smallest max, largest max, not null\n\n     * called with 4 params: Obtains a fully variable value range.\n     *\n     * This factory obtains a range where both the minimum and maximum value may vary.\n     *\n     * @param minSmallest  the smallest minimum value\n     * @param minLargest  the largest minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     *\n     * @return {ValueRange} the ValueRange for smallest min, largest min, smallest max, largest max, not null\n     */\n    static of() {\n        if (arguments.length === 2) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n        } else if (arguments.length === 3) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n        } else if (arguments.length === 4) {\n            return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n        } else {\n            return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);\n        }\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MAX_SAFE_INTEGER, MIN_SAFE_INTEGER} from '../MathUtil';\n\nimport {ChronoUnit} from './ChronoUnit';\nimport {TemporalField} from './TemporalField';\nimport {ValueRange} from './ValueRange';\nimport {YearConstants} from '../YearConstants';\n\n/**\n * A standard set of fields.\n *\n * This set of fields provide field-based access to manipulate a date, time or date-time.\n * The standard set of fields can be extended by implementing {@link TemporalField}.\n *\n * These fields are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define dates as a year, month and day,\n * just with slightly different rules.\n * The documentation of each field explains how it operates.\n *\n * ### Static properties of Class {@link ChronoField}\n *\n * ChronoField.NANO_OF_SECOND\n *\n * ChronoField.NANO_OF_DAY\n *\n * ChronoField.MICRO_OF_SECOND\n *\n * ChronoField.MICRO_OF_DAY\n *\n * ChronoField.MILLI_OF_SECOND\n *\n * ChronoField.MILLI_OF_DAY\n *\n * ChronoField.SECOND_OF_MINUTE\n *\n * ChronoField.SECOND_OF_DAY\n *\n * ChronoField.MINUTE_OF_HOUR\n *\n * ChronoField.MINUTE_OF_DAY\n *\n * ChronoField.HOUR_OF_AMPM\n *\n * ChronoField.CLOCK_HOUR_OF_AMPM\n *\n * ChronoField.HOUR_OF_DAY\n *\n * ChronoField.CLOCK_HOUR_OF_DAY\n *\n * ChronoField.AMPM_OF_DAY\n *\n * ChronoField.DAY_OF_WEEK\n *\n * ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH\n *\n * ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR\n *\n * ChronoField.DAY_OF_MONTH\n *\n * ChronoField.DAY_OF_YEAR\n *\n * ChronoField.EPOCH_DAY\n *\n * ChronoField.ALIGNED_WEEK_OF_MONTH\n *\n * ChronoField.ALIGNED_WEEK_OF_YEAR\n *\n * ChronoField.MONTH_OF_YEAR\n *\n * ChronoField.PROLEPTIC_MONTH\n *\n * ChronoField.YEAR_OF_ERA\n *\n * ChronoField.YEAR\n *\n * ChronoField.ERA\n *\n * ChronoField.INSTANT_SECONDS\n *\n * ChronoField.OFFSET_SECONDS\n *\n */\nexport class ChronoField extends TemporalField {\n\n    /**\n     * helper function to get one of the static ChronoField defines by name, needed to resolve ChronoField from EnumMap\n     *\n     * @param {String} fieldName\n     * @return {ChronoField | null}\n     */\n    static byName(fieldName) {\n        for (const prop in ChronoField) {\n            if (ChronoField.hasOwnProperty(prop)) {\n                if ((ChronoField[prop] instanceof ChronoField) && ChronoField[prop].name() === fieldName) {\n                    return ChronoField[prop];\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {!string} name\n     * @param {!number} baseUnit\n     * @param {!number} rangeUnit\n     * @param {!ValueRange} range\n     * @private\n     */\n    constructor(name, baseUnit, rangeUnit, range) {\n        super();\n        this._name = name;\n        this._baseUnit = baseUnit;\n        this._rangeUnit = rangeUnit;\n        this._range = range;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;\n    }\n\n    /**\n     *\n     * @returns {!number}\n     */\n    baseUnit(){\n        return this._baseUnit;\n    }\n\n    /**\n     *\n     * @returns {!number}\n     */\n    rangeUnit(){\n        return this._rangeUnit;\n    }\n\n    /**\n     *\n     * @returns {!ValueRange}\n     */\n    range(){\n        return this._range;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    displayName(){\n        return this.toString();\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {*}\n     */\n    checkValidValue(value) {\n        return this.range().checkValidValue(value, this.name());\n    }\n\n    /**\n     * Checks if this field represents a component of a date.\n     *\n     * @return {boolean} true if it is a component of a date\n     */\n    isDateBased() {\n        const dateBased =\n            this === ChronoField.DAY_OF_WEEK ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR ||\n            this === ChronoField.DAY_OF_MONTH ||\n            this === ChronoField.DAY_OF_YEAR ||\n            this === ChronoField.EPOCH_DAY ||\n            this === ChronoField.ALIGNED_WEEK_OF_MONTH ||\n            this === ChronoField.ALIGNED_WEEK_OF_YEAR ||\n            this === ChronoField.MONTH_OF_YEAR ||\n            //this === ChronoField.EPOCH_MONTH ||\n            this === ChronoField.YEAR_OF_ERA ||\n            this === ChronoField.YEAR ||\n            this === ChronoField.ERA;\n        return dateBased;\n    }\n\n    /**\n     * Checks if this field represents a component of a time.\n     *\n     * @return {boolean} true if it is a component of a time\n     */\n    isTimeBased() {\n        const timeBased =\n            this === ChronoField.NANO_OF_SECOND     ||\n            this === ChronoField.NANO_OF_DAY        ||\n            this === ChronoField.MICRO_OF_SECOND    ||\n            this === ChronoField.MICRO_OF_DAY       ||\n            this === ChronoField.MILLI_OF_SECOND    ||\n            this === ChronoField.MILLI_OF_DAY       ||\n            this === ChronoField.SECOND_OF_MINUTE   ||\n            this === ChronoField.SECOND_OF_DAY      ||\n            this === ChronoField.MINUTE_OF_HOUR     ||\n            this === ChronoField.MINUTE_OF_DAY      ||\n            this === ChronoField.HOUR_OF_AMPM       ||\n            this === ChronoField.CLOCK_HOUR_OF_AMPM ||\n            this === ChronoField.HOUR_OF_DAY        ||\n            this === ChronoField.CLOCK_HOUR_OF_DAY  ||\n            this === ChronoField.AMPM_OF_DAY;\n        return timeBased;\n    }\n\n    /**\n     * Get the range of valid values for this field using the temporal object to\n     * refine the result.\n     *\n     * This uses the temporal object to find the range of valid values for the field.\n     * This is similar to {@link range}, however this method refines the result\n     * using the temporal. For example, if the field is {@link DAY_OF_MONTH} the\n     * {@link range} method is not accurate as there are four possible month lengths,\n     * 28, 29, 30 and 31 days. Using this method with a date allows the range to be\n     * accurate, returning just one of those four options.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#range}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.rangeRefinedBy(temporal);\n     *   temporal = temporal.range(thisField);\n     * </pre>\n     * It is recommended to use the second approach, {@link range},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object used to refine the result, not null\n     * @return {ValueRange} the range of valid values for this field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    rangeRefinedBy(temporal) {\n        return temporal.range(this);\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an `int`.\n     *\n     * This validates that the value is within the outer range of valid values\n     * returned by {@link range}.\n     * It also checks that all valid values are within the bounds of an `int`.\n     *\n     * This method checks against the range of the field in the ISO-8601 calendar system.\n     * This range may be incorrect for other calendar systems.\n     * Use {@link Chronology#range} to access the correct range\n     * for a different calendar system.\n     *\n     * @param {number} value - the value to check\n     * @return {number} the value that was passed in\n     */\n    checkValidIntValue(value) {\n        return this.range().checkValidIntValue(value, this);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        return temporal.getLong(this);\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this.name();\n    }\n\n    /**\n     *\n     * @param {*} other\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n}\n\nexport function _init() {\n\n    ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n\n    ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n\n    ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n\n    ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n\n    ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n\n    ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n\n    ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n\n    ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n\n    ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n\n    ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, (24 * 60) - 1));\n\n    ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n\n    ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n\n    ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n\n    ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n\n    ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n\n    ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n\n    ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n\n    ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));\n\n    ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n\n    ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n\n    ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n\n    ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n\n    ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n\n    ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');\n\n    ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n\n    ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n\n    ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n\n}\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * Common implementations of {@link TemporalQuery}.\n *\n * This class provides common implementations of {@link TemporalQuery}.\n * These queries are primarily used as optimizations, allowing the internals\n * of other objects to be extracted effectively. Note that application code\n * can also use the {@link from} method on most temporal\n * objects as a method reference matching the query interface, such as\n * {@link LocalDate::from} and {@link ZoneId::from}.\n *\n * There are two equivalent ways of using a {@link TemporalQuery}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link TemporalAccessor#query}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = query.queryFrom(dateTime);\n *   dateTime = dateTime.query(query);\n * </pre>\n * It is recommended to use the second approach, {@link query},\n * as it is a lot clearer to read in code.\n *\n */\nexport class TemporalQueries {\n\n    /**\n     * A strict query for the {@link ZoneId}.\n     *\n     * This queries a {@link TemporalAccessor} for the zone.\n     * The zone is only returned if the date-time conceptually contains a {@link ZoneId}.\n     * It will not be returned if the date-time only conceptually has an {@link ZoneOffset}.\n     * Thus a {@link ZonedDateTime} will return the result of\n     * {@link getZone}, but an {@link OffsetDateTime} will\n     * return null.\n     *\n     * In most cases, applications should use {@link ZONE} as this query is too strict.\n     *\n     * The result from JDK classes implementing {@link TemporalAccessor} is as follows:\n     * * * {@link LocalDate} returns null\n     * * {@link LocalTime} returns null\n     * * {@link LocalDateTime} returns null\n     * * {@link ZonedDateTime} returns the associated zone\n     * * {@link OffsetTime} returns null\n     * * {@link OffsetDateTime} returns null\n     * * {@link ChronoLocalDate} returns null\n     * * {@link ChronoLocalDateTime} returns null\n     * * {@link ChronoZonedDateTime} returns the associated zone\n     * * {@link Era} returns null\n     * * {@link DayOfWeek} returns null\n     * * {@link Month} returns null\n     * * {@link Year} returns null\n     * * {@link YearMonth} returns null\n     * * {@link MonthDay} returns null\n     * * {@link ZoneOffset} returns null\n     * * {@link Instant} returns null\n     *\n     * @return a query that can obtain the zone ID of a temporal, not null\n     */\n    static zoneId() {\n        return TemporalQueries.ZONE_ID;\n    }\n\n    /**\n     * A query for the {@link Chronology}.\n     *\n     * This queries a {@link TemporalAccessor} for the chronology.\n     * If the target {@link TemporalAccessor} represents a date, or part of a date,\n     * then it should return the chronology that the date is expressed in.\n     * As a result of this definition, objects only representing time, such as\n     * {@link LocalTime}, will return null.\n     *\n     * The result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n     *\n     * * {@link LocalDate} returns * {@link IsoChronology.INSTANCE}\n     * * {@link LocalTime} returns null (does not represent a date)\n     * * {@link LocalDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link ZonedDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link OffsetTime} returns null (does not represent a date)\n     * * {@link OffsetDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link ChronoLocalDate} returns the associated chronology\n     * * {@link ChronoLocalDateTime} returns the associated chronology\n     * * {@link ChronoZonedDateTime} returns the associated chronology\n     * * {@link Era} returns the associated chronology\n     * * {@link DayOfWeek} returns null (shared across chronologies)\n     * * {@link Month} returns * {@link IsoChronology.INSTANCE}\n     * * {@link Year} returns * {@link IsoChronology.INSTANCE}\n     * * {@link YearMonth} returns * {@link IsoChronology.INSTANCE}\n     * * {@link MonthDay} returns null * {@link IsoChronology.INSTANCE}\n     * * {@link ZoneOffset} returns null (does not represent a date)\n     * * {@link Instant} returns null (does not represent a date)\n     *\n     * The method {@link Chronology#from} can be used as a\n     * {@link TemporalQuery}\n     * That method is equivalent to this query, except that it throws an\n     * exception if a chronology cannot be obtained.\n     *\n     * @return {TemporalQuery} a query that can obtain the chronology of a temporal, not null\n     */\n    static chronology() {\n        return TemporalQueries.CHRONO;\n    }\n\n    /**\n     * A query for the smallest supported unit.\n     *\n     * This queries a {@link TemporalAccessor} for the time precision.\n     * If the target {@link TemporalAccessor} represents a consistent or complete date-time,\n     * date or time then this must return the smallest precision actually supported.\n     * Note that fields such as {@link NANO_OF_DAY} and {@link NANO_OF_SECOND}\n     * are defined to always return ignoring the precision, thus this is the only\n     * way to find the actual smallest supported unit.\n     * For example, were {@link GregorianCalendar} to implement {@link TemporalAccessor}\n     * it would return a precision of {@link MILLIS}.\n     *\n     * The result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n     *\n     * {@link LocalDate} returns {@link DAYS}\n     * {@link LocalTime} returns {@link NANOS}\n     * {@link LocalDateTime} returns {@link NANOS}\n     * {@link ZonedDateTime} returns {@link NANOS}\n     * {@link OffsetTime} returns {@link NANOS}\n     * {@link OffsetDateTime} returns {@link NANOS}\n     * {@link ChronoLocalDate} returns {@link DAYS}\n     * {@link ChronoLocalDateTime} returns {@link NANOS}\n     * {@link ChronoZonedDateTime} returns {@link NANOS}\n     * {@link Era} returns {@link ERAS}\n     * {@link DayOfWeek} returns {@link DAYS}\n     * {@link Month} returns {@link MONTHS}\n     * {@link Year} returns {@link YEARS}\n     * {@link YearMonth} returns {@link MONTHS}\n     * {@link MonthDay} returns null (does not represent a complete date or time)\n     * {@link ZoneOffset} returns null (does not represent a date or time)\n     * {@link Instant} returns {@link NANOS}\n     *\n     * @return a query that can obtain the precision of a temporal, not null\n     */\n    static precision() {\n        return TemporalQueries.PRECISION;\n    }\n\n    /**\n     * A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n     *\n     * This queries a {@link TemporalAccessor} for the zone.\n     * It first tries to obtain the zone, using {@link zoneId}.\n     * If that is not found it tries to obtain the {@link offset}.\n     *\n     * In most cases, applications should use this query rather than {@link zoneId}.\n     *\n     * This query examines the {@link ChronoField#OFFSET_SECONDS}\n     * field and uses it to create a {@link ZoneOffset}.\n     *\n     * The method {@link ZoneId#from} can be used as a\n     * {@link TemporalQuery} via a method reference, {@link ZoneId::from}.\n     * That method is equivalent to this query, except that it throws an\n     * exception if a zone cannot be obtained.\n     *\n     * @return a query that can obtain the zone ID or offset of a temporal, not null\n     */\n    static zone() {\n        return TemporalQueries.ZONE;\n    }\n\n    /**\n     * A query for {@link ZoneOffset} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the offset. The query will return null if the temporal\n     * object cannot supply an offset.\n     *\n     * The query implementation examines the {@link ChronoField#OFFSET_SECONDS}\n     * field and uses it to create a {@link ZoneOffset}.\n     *\n     * The method {@link java.time.ZoneOffset#from} can be used as a\n     * {@link TemporalQuery} via a method reference, {@link ZoneOffset::from}.\n     * This query and {@link ZoneOffset::from} will return the same result if the\n     * temporal object contains an offset. If the temporal object does not contain\n     * an offset, then the method reference will throw an exception, whereas this\n     * query will return null.\n     *\n     * @return a query that can obtain the offset of a temporal, not null\n     */\n    static offset() {\n        return TemporalQueries.OFFSET;\n    }\n\n    /**\n     * A query for {@link LocalDate} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the local date. The query will return null if the temporal\n     * object cannot supply a local date.\n     *\n     * The query implementation examines the {@link ChronoField#EPOCH_DAY}\n     * field and uses it to create a {@link LocalDate}.\n     *\n     * @return a query that can obtain the date of a temporal, not null\n     */\n    static localDate() {\n        return TemporalQueries.LOCAL_DATE;\n    }\n\n    /**\n     * A query for {@link LocalTime} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the local time. The query will return null if the temporal\n     * object cannot supply a local time.\n     *\n     * The query implementation examines the {@link ChronoField#NANO_OF_DAY}\n     * field and uses it to create a {@link LocalTime}.\n     *\n     * @return a query that can obtain the time of a temporal, not null\n     */\n    static localTime() {\n        return TemporalQueries.LOCAL_TIME;\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {UnsupportedTemporalTypeException} from '../errors';\n\nimport {ChronoField} from './ChronoField';\nimport {TemporalQueries} from './TemporalQueries';\n\nexport class TemporalAccessor {\n    /**\n     * Queries this date-time.\n     *\n     * This queries this date-time using the specified query strategy object.\n     *\n     * Queries are a key tool for extracting information from date-times.\n     * They exists to externalize the process of querying, permitting different\n     * approaches, as per the strategy design pattern.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     *\n     * The most common query implementations are method references, such as\n     * {@link LocalDate::from} and {@link ZoneId::from}.\n     * Further implementations are on {@link TemporalQueries}.\n     * Queries may also be defined by applications.\n     *\n     * @implSpec\n     * Implementations of this method must behave as follows:\n     * <pre>\n        if (query == TemporalQueries.zoneId()\n            || query == TemporalQueries.chronology()\n            || query == TemporalQueries.precision()) {\n                return null;\n        }\n        return query.queryFrom(this);\n     * </pre>\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()\n                || query === TemporalQueries.chronology()\n                || query === TemporalQueries.precision()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Gets the value of the specified field as an `int`.\n     *\n     * This queries the date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If the date-time cannot return the value, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * ### Specification for implementors\n     *\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported and has an `int` range, then the value of\n     * the field must be returned.\n     * If unsupported, then a {@link DateTimeException} must be thrown.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument.\n     *\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an `int`\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * All fields can be expressed as a `long` integer.\n     * This method returns an object that describes the valid range for that value.\n     * The value of this temporal object is used to enhance the accuracy of the returned range.\n     * If the date-time cannot return the range, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * Note that the result only describes the minimum and maximum valid values\n     * and it is important not to read too much into them. For example, there\n     * could be values within the range that are invalid for the field.\n     *\n     * ### Specification for implementors\n     *\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported, then the range of the field must be returned.\n     * If unsupported, then a {@link DateTimeException} must be thrown.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     *\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (this.isSupported(field)) {\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {TemporalAccessor} from './TemporalAccessor';\n\n/**\n * Framework-level interface defining read-write access to a temporal object,\n * such as a date, time, offset or some combination of these.\n *\n * This is the base interface type for date, time and offset objects that\n * are complete enough to be manipulated using plus and minus.\n * It is implemented by those classes that can provide and manipulate information\n * as fields (see {@link TemporalField}) or queries (see {@link TemporalQuery}).\n * See {@link TemporalAccessor} for the read-only version of this interface.\n *\n * Most date and time information can be represented as a number.\n * These are modeled using {@link TemporalField} with the number held using\n * a `long` to handle large values. Year, month and day-of-month are\n * simple examples of fields, but they also include instant and offsets.\n * See {@link ChronoField} for the standard set of fields.\n *\n * Two pieces of date/time information cannot be represented by numbers,\n * the {@link Chronology} and the {@link ZoneId}.\n * These can be accessed using the static methods defined on {@link TemporalQueries}.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link LocalDate}.\n * There are many reasons for this, part of which is that implementations\n * of this interface may be in calendar systems other than ISO.\n * See {@link ChronoLocalDate} for a fuller discussion of the issues.\n *\n * ### When to implement\n *\n * A class should implement this interface if it meets three criteria:\n *\n * * it provides access to date/time/offset information, as per {@link TemporalAccessor}\n * * the set of fields are contiguous from the largest to the smallest\n * * the set of fields are complete, such that no other field is needed to define the\n *   valid range of values for the fields that are represented\n *\n * Four examples make this clear:\n *\n * * {@link LocalDate} implements this interface as it represents a set of fields\n *   that are contiguous from days to forever and require no external information to determine\n *   the validity of each date. It is therefore able to implement plus/minus correctly.\n * * {@link LocalTime} implements this interface as it represents a set of fields\n *   that are contiguous from nanos to within days and require no external information to determine\n *   validity. It is able to implement plus/minus correctly, by wrapping around the day.\n * * {@link MonthDay}, the combination of month-of-year and day-of-month, does not implement\n *   this interface.  While the combination is contiguous, from days to months within years,\n *   the combination does not have sufficient information to define the valid range of values\n *   for day-of-month.  As such, it is unable to implement plus/minus correctly.\n * * The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement\n *   this interface. It does not represent a contiguous set of fields, as days to weeks overlaps\n *   days to months.\n *\n * @interface\n */\nexport class Temporal extends TemporalAccessor {}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\nimport {Enum} from '../Enum';\n\n\n/**\n * Strategy for querying a temporal object.\n *\n * Queries are a key tool for extracting information from temporal objects.\n * They exist to externalize the process of querying, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be a query that checks if the date is the day before February 29th\n * in a leap year, or calculates the number of days to your next birthday.\n *\n * The {@link TemporalField} interface provides another mechanism for querying\n * temporal objects. That interface is limited to returning a `long`.\n * By contrast, queries can return any type.\n *\n * There are two equivalent ways of using a {@link TemporalQuery}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link TemporalAccessor#query}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisQuery.queryFrom(temporal);\n *   temporal = temporal.query(thisQuery);\n * </pre>\n * It is recommended to use the second approach, {@link query},\n * as it is a lot clearer to read in code.\n *\n * The most common implementations are method references, such as\n * {@link LocalDate::from} and {@link ZoneId::from}.\n * Further implementations are on {@link TemporalQueries}.\n * Queries may also be defined by applications.\n *\n * ### Specification for implementors\n *\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalQuery  extends Enum {\n    /**\n     * Queries the specified temporal object.\n     *\n     * This queries the specified temporal object to return an object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#query}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisQuery.queryFrom(temporal);\n     *   temporal = temporal.query(thisQuery);\n     * </pre>\n     * It is recommended to use the second approach, {@link query},\n     * as it is a lot clearer to read in code.\n     *\n     * ### Specification for implementors\n     *\n     * The implementation must take the input object and query it.\n     * The implementation defines the logic of the query and is responsible for\n     * documenting that logic.\n     * It may use any method on {@link TemporalAccessor} to determine the result.\n     * The input object must not be altered.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to query, not null\n     * @return the queried value, may return null to indicate not found\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    queryFrom(temporal){\n        abstractMethodFail('queryFrom');\n    }\n\n}\n\n/**\n * Factory to create something similar to the JSR-310 {TemporalQuery} interface, takes a function and returns a new TemporalQuery object that presents that function\n * as the queryFrom() function.\n * @param name for the underlying Enum\n * @param queryFromFunction\n */\nexport function createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException, UnsupportedTemporalTypeException, NullPointerException} from './errors';\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull} from './assert';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {IllegalArgumentException} from './errors';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\n/**\n * ### Static properties of Class {@link DayOfWeek}\n *\n * DayOfWeek.MONDAY,\n * DayOfWeek.TUESDAY,\n * DayOfWeek.WEDNESDAY,\n * DayOfWeek.THURSDAY,\n * DayOfWeek.FRIDAY,\n * DayOfWeek.SATURDAY,\n * DayOfWeek.SUNDAY\n *\n */\nexport class DayOfWeek extends Temporal {\n\n    /**\n     *\n     * @param {number} ordinal\n     * @param {string} name\n     * @private\n     */\n    constructor(ordinal, name){\n        super();\n        this._ordinal = ordinal;\n        this._name = name;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    ordinal(){\n        return this._ordinal;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;\n    }\n\n    /**\n     *\n     * @returns {DayOfWeek[]}\n     */\n    static values() {\n        return ENUMS.slice();\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @returns {DayOfWeek}\n     */\n    static valueOf(name) {\n        let ordinal = 0;\n        for(ordinal; ordinal < ENUMS.length; ordinal++){\n            if(ENUMS[ordinal].name() === name){\n                break;\n            }\n        }\n        return DayOfWeek.of(ordinal+1);\n    }\n\n    /**\n     * Obtains an instance of {@link DayOfWeek} from an `int` value.\n     *\n     * {@link DayOfWeek} is an enum representing the 7 days of the week.\n     * This factory allows the enum to be obtained from the `int` value.\n     * The `int` value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     *\n     * @param {!number} dayOfWeek  the day-of-week to represent, from 1 (Monday) to 7 (Sunday)\n     * @return {DayOfWeek} the day-of-week singleton, not null\n     * @throws DateTimeException if the day-of-week is invalid\n     */\n    static of(dayOfWeek) {\n        if (dayOfWeek < 1 || dayOfWeek > 7) {\n            throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);\n        }\n        return ENUMS[dayOfWeek - 1];\n    }\n\n    /**\n     * Obtains an instance of {@link DayOfWeek} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link DayOfWeek}.\n     *\n     * The conversion extracts the {@link ChronoField#DAY_OF_WEEK} field.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link DayOfWeek::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {DayOfWeek} the day-of-week, not null\n     * @throws DateTimeException if unable to convert to a {@link DayOfWeek}\n     */\n    static from(temporal) {\n        assert(temporal != null, 'temporal', NullPointerException);\n        if (temporal instanceof DayOfWeek) {\n            return temporal;\n        }\n        try {\n            return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n        } catch (ex) {\n            if(ex instanceof DateTimeException) {\n                throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * Gets the day-of-week `int` value.\n     *\n     * The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     * See {@link WeekFields#dayOfWeek} for localized week-numbering.\n     *\n     * @return {number} the day-of-week, from 1 (Monday) to 7 (Sunday)\n     */\n    value() {\n        return this._ordinal + 1;\n    }\n\n    /**\n     * Gets the textual representation, such as 'Mon' or 'Friday'.\n     *\n     * This returns the textual name used to identify the day-of-week.\n     * The parameters control the length of the returned text and the locale.\n     *\n     * If no textual mapping is found then the numeric value (see {@link getValue}) is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    getDisplayName(style, locale) {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n        // return new DateTimeFormatterBuilder().appendText(ChronoField.DAY_OF_WEEK, style).toFormatter(locale).format(this);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this day-of-week can be queried for the specified field.\n     * If false, then calling the {@link range} and\n     * {@link get} methods will throw an exception.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then\n     * this method returns true.\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this day-of-week, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_WEEK;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This day-of-week is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * range of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as an `int`.\n     *\n     * This queries this day-of-week for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an `int`\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as a `long`.\n     *\n     * This queries this day-of-week for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the day-of-week that is the specified number of days after this one.\n     *\n     * The calculation rolls around the end of the week from Sunday to Monday.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    plus(days) {\n        const amount = MathUtil.floorMod(days, 7);\n        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n    }\n\n    /**\n     * Returns the day-of-week that is the specified number of days before this one.\n     *\n     * The calculation rolls around the start of the year from Monday to Sunday.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    minus(days) {\n        return this.plus(-1 * MathUtil.floorMod(days, 7));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this day-of-week using the specified query.\n     *\n     * This queries this day-of-week using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() || query === TemporalQueries.chronology() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        assert(query != null, 'query', NullPointerException);\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this day-of-week.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the day-of-week changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#DAY_OF_WEEK} as the field.\n     * Note that this adjusts forwards or backwards within a Monday to Sunday week.\n     * See {@link WeekFields#dayOfWeek} for localized week start days.\n     * See {@link TemporalAdjusters} for other adjusters\n     * with more control, such as `next(MONDAY)`.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisDayOfWeek.adjustInto(temporal);\n     *   temporal = temporal.with(thisDayOfWeek);\n     * </pre>\n     *\n     * For example, given a date that is a Wednesday, the following are output:\n     * <pre>\n     *   dateOnWed.with(MONDAY);     // two days earlier\n     *   dateOnWed.with(TUESDAY);    // one day earlier\n     *   dateOnWed.with(WEDNESDAY);  // same date\n     *   dateOnWed.with(THURSDAY);   // one day later\n     *   dateOnWed.with(FRIDAY);     // two days later\n     *   dateOnWed.with(SATURDAY);   // three days later\n     *   dateOnWed.with(SUNDAY);     // four days later\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjusters} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._name;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nlet ENUMS;\n\nexport function _init() {\n    DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n    DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n    DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n    DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n    DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n    DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n    DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n\n    DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', (temporal) => {\n        return DayOfWeek.from(temporal);\n    });\n\n    ENUMS = [\n        DayOfWeek.MONDAY,\n        DayOfWeek.TUESDAY,\n        DayOfWeek.WEDNESDAY,\n        DayOfWeek.THURSDAY,\n        DayOfWeek.FRIDAY,\n        DayOfWeek.SATURDAY,\n        DayOfWeek.SUNDAY\n    ];\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\n\n/**\n * @private\n */\nexport class StringUtil {\n\n    /**\n     *\n     * @param {string} text\n     * @param {string} pattern\n     * @return {boolean}\n     */\n    static startsWith(text, pattern){\n        return text.indexOf(pattern) === 0;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    static hashCode(text) {\n        const len = text.length;\n        if (len === 0) {\n            return 0;\n        }\n\n        let hash = 0;\n        for (let i = 0; i < len; i++) {\n            const chr = text.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return MathUtil.smi(hash);\n    }\n}\n\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from './assert';\nimport {DateTimeException} from './errors';\n\nimport {StringUtil} from './StringUtil';\n\nimport {Instant} from './Instant';\n\nexport class ZoneId {\n    /**\n     * Gets the system default time-zone.\n     *\n     * @return {ZoneId} the zone ID, not null\n     */\n    static systemDefault() {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation');\n    }\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * This set includes the string form of all available region-based IDs.\n     * Offset-based zone IDs are not included in the returned set.\n     * The ID can be passed to {@link of} to create a {@link ZoneId}.\n     *\n     * The set of zone IDs can increase over time, although in a typical application\n     * the set of IDs is fixed. Each call to this method is thread-safe.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds() {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation');\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} from an ID ensuring that the\n     * ID is valid and available for use.\n     *\n     * This method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\n     * A {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\n     * The result will always be a valid ID for which {@link ZoneRules} can be obtained.\n     *\n     * Parsing matches the zone ID step by step as follows.\n     *\n     * * If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n     * * If the zone ID consists of a single letter, the zone ID is invalid\n     *   and {@link DateTimeException} is thrown.\n     * * If the zone ID starts with '+' or '-', the ID is parsed as a\n     *   {@link ZoneOffset} using {@link ZoneOffset#of}.\n     * * If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n     *   with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n     * * If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n     *   then the ID is a prefixed offset-based ID. The ID is split in two, with\n     *   a two or three letter prefix and a suffix starting with the sign.\n     *   The suffix is parsed as a {@link ZoneOffset}.\n     *   The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n     *   and the normalized offset ID as per {@link ZoneOffset#getId}.\n     *   The rules of the returned {@link ZoneId} will be equivalent to the\n     *   parsed {@link ZoneOffset}.\n     * * All other IDs are parsed as region-based zone IDs. Region IDs must\n     *   match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n     *   otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n     *   in the configured set of IDs, {@link ZoneRulesException} is thrown.\n     *   The detailed format of the region ID depends on the group supplying the data.\n     *   The default set of data is supplied by the IANA Time Zone Database (TZDB).\n     *   This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n     *   This is compatible with most IDs from {@link java.util.TimeZone}.\n     *\n     * @param {string} zoneId  the time-zone ID, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if the zone ID has an invalid format\n     * @throws ZoneRulesException if the zone ID is a region ID that cannot be found\n     */\n    static of(zoneId) {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation' + zoneId);\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} wrapping an offset.\n     *\n     * If the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\n     * with the prefix and the non-zero offset is returned.\n     * If the prefix is empty `''` the {@link ZoneOffset} is returned.\n     *\n     * @param {string} prefix  the time-zone ID, not null\n     * @param {ZoneOffset} offset  the offset, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws IllegalArgumentException if the prefix is not one of\n     *     'GMT', 'UTC', or 'UT', or ''\n     */\n    static ofOffset(prefix, offset) {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation' + prefix + offset);\n    }\n\n\n    /**\n     * Obtains an instance of {@link ZoneId} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n     *\n     * The conversion will try to obtain the zone in a way that favours region-based\n     * zones over offset-based zones using {@link TemporalQueries#zone}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZoneId::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if unable to convert to a {@link ZoneId}\n     */\n    static from(temporal) {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation' + temporal);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the unique time-zone ID.\n     *\n     * This ID uniquely defines this object.\n     * The format of an offset based ID is defined by {@link ZoneOffset#getId}.\n     *\n     * @return {String} the time-zone unique ID, not null\n     */\n    id(){\n        abstractMethodFail('ZoneId.id');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone rules for this ID allowing calculations to be performed.\n     *\n     * The rules provide the functionality associated with a time-zone,\n     * such as finding the offset for a given instant or local date-time.\n     *\n     * A time-zone can be invalid if it is deserialized in a Java Runtime which\n     * does not have the same rules loaded as the Java Runtime that stored it.\n     * In this case, calling this method will throw a {@link ZoneRulesException}.\n     *\n     * The rules are supplied by {@link ZoneRulesProvider}. An advanced provider may\n     * support dynamic updates to the rules without restarting the Java Runtime.\n     * If so, then the result of this method may change over time.\n     * Each individual call will be still remain thread-safe.\n     *\n     * {@link ZoneOffset} will always return a set of rules where the offset never changes.\n     *\n     * @return {!ZoneRules} the rules, not null\n     * @throws ZoneRulesException if no rules are available for this ID\n     */\n    rules(){\n        abstractMethodFail('ZoneId.rules');\n    }\n\n    /**\n      * Normalizes the time-zone ID, returning a {@link ZoneOffset} where possible.\n      *\n      * The returns a normalized {@link ZoneId} that can be used in place of this ID.\n      * The result will have {@link ZoneRules} equivalent to those returned by this object,\n      * however the ID returned by {@link getId} may be different.\n      *\n      * The normalization checks if the rules of this {@link ZoneId} have a fixed offset.\n      * If they do, then the {@link ZoneOffset} equal to that offset is returned.\n      * Otherwise `this` is returned.\n      *\n      * @return {ZoneId} the time-zone unique ID, not null\n      */\n    normalized() {\n        const rules = this.rules();\n        if (rules.isFixedOffset()) {\n            return rules.offset(Instant.EPOCH);\n        }\n        //try {\n        //} catch (ZoneRulesException ex) {\n        //    // ignore invalid objects\n        //}\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n      * Checks if this time-zone ID is equal to another time-zone ID.\n      *\n      * The comparison is based on the ID.\n      *\n      * @param {*} other  the object to check, null returns false\n      * @return {boolean} true if this is equal to the other time-zone ID\n      */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZoneId) {\n            return this.id() === other.id();\n        }\n        return false;\n    }\n\n    /**\n      * A hash code for this time-zone ID.\n      *\n      * @return {number} a suitable hash code\n      */\n    hashCode() {\n        return StringUtil.hashCode(this.id());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n      * Outputs this zone as a string, using the ID.\n      *\n      * @return {string} a string representation of this time-zone ID, not null\n      */\n    toString() {\n        return this.id();\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, abstractMethodFail} from '../assert';\n\nimport {Duration} from '../Duration';\nimport {Instant} from '../Instant';\n\nexport class ZoneRules {\n\n    /**\n     * Obtains an instance of {@link ZoneRules} that always uses the same offset.\n     *\n     * The returned rules always have the same offset.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZoneRules} the zone rules, not null\n     */\n    static of(offset) {\n        requireNonNull(offset, 'offset');\n        return new Fixed(offset);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        abstractMethodFail('ZoneRules.isFixedOffset');\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     *\n     * @param instantOrLocalDateTime\n     * @returns {ZoneOffset}\n     */\n    offset(instantOrLocalDateTime){\n        if(instantOrLocalDateTime instanceof Instant){\n            return this.offsetOfInstant(instantOrLocalDateTime);\n        } else {\n            return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n        }\n    }\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     *\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfInstant(instant){\n        abstractMethodFail('ZoneRules.offsetInstant');\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfEpochMilli(epochMilli){\n        abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     *\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link getValidOffsets} and {@link getTransition}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfLocalDateTime(localDateTime){\n        abstractMethodFail('ZoneRules.offsetLocalDateTime');\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     *\n     * There are various ways to handle the conversion from a {@link LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     *\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    validOffsets(localDateTime){\n        abstractMethodFail('ZoneRules.validOffsets');\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     *\n     * There are various ways to handle the conversion from a {@link LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    transition(localDateTime){\n        abstractMethodFail('ZoneRules.transition');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     *\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    standardOffset(instant){\n        abstractMethodFail('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     *\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    daylightSavings(instant){\n        abstractMethodFail('ZoneRules.daylightSavings');\n        //    default {\n        //        ZoneOffset standardOffset = getStandardOffset(instant);\n        //        ZoneOffset actualOffset = getOffset(instant);\n        //        return actualOffset.toDuration().minus(standardOffset.toDuration()).normalized();\n        //    }\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     *\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    isDaylightSavings(instant) {\n        abstractMethodFail('ZoneRules.isDaylightSavings');\n        //    default {\n        //        return (getStandardOffset(instant).equals(getOffset(instant)) == false);\n        //    }\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     *\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    // eslint-disable-next-line no-unused-vars\n    isValidOffset(localDateTime, offset){\n        abstractMethodFail('ZoneRules.isValidOffset');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     *\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    nextTransition(instant){\n        abstractMethodFail('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     *\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    previousTransition(instant){\n        abstractMethodFail('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     *\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link getTransitionRules}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     *\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        abstractMethodFail('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     *\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link getTransitions}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     *\n     * For any given {@link ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     *\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     *\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        abstractMethodFail('ZoneRules.transitionRules');\n    }\n\n    toString(){\n        abstractMethodFail('ZoneRules.toString');\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\n\nclass Fixed extends ZoneRules{\n    /**\n     *\n     * @param {ZoneOffset} offset\n     * @private\n     */\n    constructor(offset){\n        super();\n        this._offset = offset;\n    }\n\n    isFixedOffset(){\n        return true;\n    }\n\n    offsetOfInstant(){\n        return this._offset;\n    }\n\n    offsetOfEpochMilli(){\n        return this._offset;\n    }\n\n    offsetOfLocalDateTime(){\n        return this._offset;\n    }\n\n    validOffsets(){\n        return [this._offset];\n    }\n\n    transition(){\n        return null;\n    }\n\n    standardOffset(){\n        return this._offset;\n    }\n\n    daylightSavings(){\n        return Duration.ZERO;\n    }\n\n    isDaylightSavings(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} localDateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(localDateTime, offset) {\n        return this._offset.equals(offset);\n    }\n\n    nextTransition(){\n        return null;\n    }\n\n    previousTransition(){\n        return null;\n    }\n\n    transitions(){\n        return [];\n    }\n\n    transitionRules(){\n        return [];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Fixed) {\n            return this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'FixedRules:' + this._offset.toString();\n    }\n\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {LocalTime} from './LocalTime';\nimport {ZoneId} from './ZoneId';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\nimport {ZoneRules} from './zone/ZoneRules';\n\nconst SECONDS_CACHE = {};\nconst ID_CACHE = {};\n\n/**\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n *\n * ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n *\n * ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n *\n * ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n *\n */\nexport class ZoneOffset extends ZoneId {\n    /**\n     *\n     * @param {number} totalSeconds\n     * @private\n     */\n    constructor(totalSeconds){\n        super();\n        ZoneOffset._validateTotalSeconds(totalSeconds);\n        this._totalSeconds = MathUtil.safeToInt(totalSeconds);\n        this._rules = ZoneRules.of(this);\n        this._id = ZoneOffset._buildId(totalSeconds);\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    totalSeconds() {\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {string}\n     */\n    static _buildId(totalSeconds) {\n        if (totalSeconds === 0) {\n            return 'Z';\n        } else {\n            const absTotalSeconds = Math.abs(totalSeconds);\n            const absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n            const absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n            let buf = '' + (totalSeconds < 0 ? '-' : '+')\n                + (absHours < 10 ? '0' : '') + (absHours)\n                + (absMinutes < 10 ? ':0' : ':') + (absMinutes);\n            const absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n            if (absSeconds !== 0) {\n                buf += (absSeconds < 10 ? ':0' : ':') + (absSeconds);\n            }\n            return buf;\n        }\n    }\n\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @private\n     */\n    static _validateTotalSeconds(totalSeconds){\n        if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @private\n     */\n    static _validate(hours, minutes, seconds) {\n        if (hours < -18 || hours > 18) {\n            throw new DateTimeException('Zone offset hours not in valid range: value ' + hours +\n                    ' is not in the range -18 to 18');\n        }\n        if (hours > 0) {\n            if (minutes < 0 || seconds < 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n            }\n        } else if (hours < 0) {\n            if (minutes > 0 || seconds > 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n            }\n        } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n            throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n        }\n        if (Math.abs(minutes) > 59) {\n            throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' +\n                    Math.abs(minutes) + ' is not in the range 0 to 59');\n        }\n        if (Math.abs(seconds) > 59) {\n            throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' +\n                    Math.abs(seconds) + ' is not in the range 0 to 59');\n        }\n        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZoneOffset} using the ID.\n     *\n     * This method parses the string ID of a {@link ZoneOffset} to\n     * return an instance. The parsing accepts all the formats generated by\n     * {@link getId}, plus some additional formats:\n     *\n     * * {@link Z} - for UTC\n     * * `+h`\n     * * `+hh`\n     * * `+hh:mm`\n     * * `-hh:mm`\n     * * `+hhmm`\n     * * `-hhmm`\n     * * `+hh:mm:ss`\n     * * `-hh:mm:ss`\n     * * `+hhmmss`\n     * * `-hhmmss`\n     *\n     * Note that &plusmn; means either the plus or minus symbol.\n     *\n     * The ID of the returned offset will be normalized to one of the formats\n     * described by {@link getId}.\n     *\n     * The maximum supported range is from +18:00 to -18:00 inclusive.\n     *\n     * @param {string} offsetId  the offset ID, not null\n     * @return {ZoneOffset} the zone-offset, not null\n     * @throws DateTimeException if the offset ID is invalid\n     */\n    static of(offsetId) {\n        requireNonNull(offsetId, 'offsetId');\n        // \"Z\" is always in the cache\n        const offset = ID_CACHE[offsetId];\n        if (offset != null) {\n            return offset;\n        }\n\n        // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n        let hours, minutes, seconds;\n        switch (offsetId.length) {\n            case 2:\n                offsetId = offsetId[0] + '0' + offsetId[1];  // fallthru\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = 0;\n                seconds = 0;\n                break;\n            case 5:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = 0;\n                break;\n            case 6:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = 0;\n                break;\n            case 7:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n                break;\n            case 9:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n                break;\n            default:\n                throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);\n        }\n        const first = offsetId[0];\n        if (first !== '+' && first !== '-') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);\n        }\n        if (first === '-') {\n            return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n        } else {\n            return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n        }\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {string} offsetId - the offset ID, not null\n     * @param {number} pos - the position to parse, valid\n     * @param {boolean} precededByColon - should this number be prefixed by a precededByColon\n     * @return {number} the parsed number, from 0 to 99\n     */\n    static _parseNumber(offsetId, pos, precededByColon) {\n        if (precededByColon && offsetId[pos - 1] !== ':') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);\n        }\n        const ch1 = offsetId[pos];\n        const ch2 = offsetId[pos + 1];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);\n        }\n        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @returns {ZoneOffset}\n     */\n    static ofHours(hours) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutes(hours, minutes) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutesSeconds(hours, minutes, seconds) {\n        ZoneOffset._validate(hours, minutes, seconds);\n        const totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     *\n     * @param {number} totalMinutes\n     * @returns {ZoneOffset}\n     */\n    static ofTotalMinutes(totalMinutes) {\n        const totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {ZoneOffset}\n     */\n    static ofTotalSeconds(totalSeconds) {\n        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n            const totalSecs = totalSeconds;\n            let result = SECONDS_CACHE[totalSecs];\n            if (result == null) {\n                result = new ZoneOffset(totalSeconds);\n                SECONDS_CACHE[totalSecs] = result;\n                ID_CACHE[result.id()] = result;\n            }\n            return result;\n        } else {\n            return new ZoneOffset(totalSeconds);\n        }\n    }\n\n    /**\n     * Gets the associated time-zone rules.\n     *\n     * The rules will always return this offset when queried.\n     * The implementation class is immutable, thread-safe and serializable.\n     *\n     * @return {ZoneRules} the rules, not null\n     */\n    rules() {\n        return this._rules;\n    }\n\n    /**\n      * Gets the value of the specified field from this offset as an `int`.\n      *\n      * This queries this offset for the value for the specified field.\n      * The returned value will always be within the valid range of values for the field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      *\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@link OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n      *\n      * If the field is not a {@link ChronoField}, then the result of this method\n      * is obtained by invoking {@link TemporalField.getFrom}\n      * passing `this` as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n      * Gets the value of the specified field from this offset as a `long`.\n      *\n      * This queries this offset for the value for the specified field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      *\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@link OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n      *\n      * If the field is not a {@link ChronoField}, then the result of this method\n      * is obtained by invoking {@link TemporalField.getFrom}\n      * passing `this` as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    getLong(field) {\n        if (field === ChronoField.OFFSET_SECONDS) {\n            return this._totalSeconds;\n        } else if (field instanceof ChronoField) {\n            throw new DateTimeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n      * Queries this offset using the specified query.\n      *\n      * This queries this offset using the specified query strategy object.\n      * The {@link TemporalQuery} object defines the logic to be used to\n      * obtain the result. Read the documentation of the query to understand\n      * what the result of this method will be.\n      *\n      * The result of this method is obtained by invoking the\n      * {@link TemporalQuery#queryFrom} method on the\n      * specified query passing `this` as the argument.\n      *\n      * @param {TemporalQuery} query - the query to invoke, not null\n      * @return {*} the query result, null may be returned (defined by the query)\n      * @throws DateTimeException if unable to query (defined by the query)\n      * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n      */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n            return this;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                 query === TemporalQueries.precision() || query === TemporalQueries.chronology() || query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n      * Adjusts the specified temporal object to have the same offset as this object.\n      *\n      * This returns a temporal object of the same observable type as the input\n      * with the offset changed to be the same as this.\n      *\n      * The adjustment is equivalent to using {@link Temporal#with}\n      * passing {@link ChronoField#OFFSET_SECONDS} as the field.\n      *\n      * In most cases, it is clearer to reverse the calling pattern by using\n      * {@link Temporal#with}:\n      * <pre>\n      *   // these two lines are equivalent, but the second approach is recommended\n      *   temporal = thisOffset.adjustInto(temporal);\n      *   temporal = temporal.with(thisOffset);\n      * </pre>\n      *\n      * This instance is immutable and unaffected by this method call.\n      *\n      * @param {Temporal} temporal - the target object to be adjusted, not null\n      * @return {Temporal} the adjusted object, not null\n      * @throws DateTimeException if unable to make the adjustment\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n    }\n\n    /**\n     * Compares this offset to another offset in descending order.\n     *\n     * The offsets are compared in the order that they occur for the same time\n     * of day around the world. Thus, an offset of `+10:00` comes before an\n     * offset of `+09:00` and so on down to `-18:00`.\n     *\n     * The comparison is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {!ZoneOffset} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, postive if greater\n     * @throws NullPointerException if {@link other} is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        return other._totalSeconds - this._totalSeconds;\n    }\n\n\n    /**\n     * Checks if this offset is equal to another offset.\n     *\n     * The comparison is based on the amount of the offset in seconds.\n     * This is equivalent to a comparison by ID.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other offset\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof ZoneOffset) {\n            return this._totalSeconds === obj._totalSeconds;\n        }\n        return false;\n    }\n\n    /**\n     * @return {number}\n     */\n    hashCode(){\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._id;\n    }\n}\n\nexport function _init() {\n    ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n    ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n    ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n    ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, ArithmeticException, DateTimeParseException} from './errors';\n\nimport {IsoChronology} from './chrono/IsoChronology';\n\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalAmount} from './temporal/TemporalAmount';\n\nimport {LocalDate} from './LocalDate';\n\n/**\n * The pattern for parsing.\n */\nconst PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\n\n/**\n * A date-based amount of time, such as '2 years, 3 months and 4 days'.\n *\n * This class models a quantity or amount of time in terms of years, months and days.\n * See {@link Duration} for the time-based equivalent to this class.\n *\n * Durations and period differ in their treatment of daylight savings time\n * when added to {@link ZonedDateTime}. A {@link Duration} will add an exact\n * number of seconds, thus a duration of one day is always exactly 24 hours.\n * By contrast, a {@link Period} will add a conceptual day, trying to maintain\n * the local time.\n *\n * For example, consider adding a period of one day and a duration of one day to\n * 18:00 on the evening before a daylight savings gap. The {@link Period} will add\n * the conceptual day and result in a {@link ZonedDateTime} at 18:00 the following day.\n * By contrast, the {@link Duration} will add exactly 24 hours, resulting in a\n * {@link ZonedDateTime} at 19:00 the following day (assuming a one hour DST gap).\n *\n * The supported units of a period are {@link ChronoUnit#YEARS},\n * {@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\n * All three fields are always present, but may be set to zero.\n *\n * The period may be used with any calendar system.\n * The meaning of a 'year' or 'month' is only applied when the object is added to a date.\n *\n * The period is modeled as a directed amount of time, meaning that individual parts of the\n * period may be negative.\n *\n * The months and years fields may be normalized (see {@link normalized}).\n * The normalization assumes a 12 month year, so is not appropriate for all calendar systems.\n *\n * ### Static properties of Class {@link Period}\n *\n * Period.ZERO\n *\n * A constant for a period of zero.\n *\n */\nexport class Period extends TemporalAmount /* extends ChronoPeriod */ {\n\n    /**\n     * do not call the constructor directly\n     * use a factory method instead\n     *\n     * @param {number} years\n     * @param {number} months\n     * @param {number} days\n     * @private\n     */\n    constructor(years, months, days){\n        super();\n        \n        const _years = MathUtil.safeToInt(years);\n        const _months =  MathUtil.safeToInt(months);\n        const _days = MathUtil.safeToInt(days);\n\n        if((_years | _months | _days) === 0){\n            if (!Period.ZERO) {\n                this._years = _years;\n                this._months =  _months;\n                this._days = _days;\n                Period.ZERO = this;\n            }\n            return Period.ZERO;\n        }\n        \n        /**\n         * The number of years.\n         */\n        this._years = _years;\n        /**\n         * The number of months.\n         */\n        this._months =  _months;\n        /**\n         * The number of days.\n         */\n        this._days = _days;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years.\n     *\n     * The resulting period will have the specified years.\n     * The months and days units will be zero.\n     *\n     * @param {number} years - the number of years, positive or negative\n     * @return {Period} the period of years, not null\n     */\n    static ofYears(years) {\n        return Period.create(years, 0, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of months.\n     *\n     * The resulting period will have the specified months.\n     * The years and days units will be zero.\n     *\n     * @param {number} months - the number of months, positive or negative\n     * @return {Period} the period of months, not null\n     */\n    static ofMonths(months) {\n        return Period.create(0, months, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of weeks.\n     *\n     * The resulting period will have days equal to the weeks multiplied by seven.\n     * The years and months units will be zero.\n     *\n     * @param {number} weeks - the number of weeks, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofWeeks(weeks) {\n        return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of days.\n     *\n     * The resulting period will have the specified days.\n     * The years and months units will be zero.\n     *\n     * @param {number} days - the number of days, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofDays(days) {\n        return Period.create(0, 0, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years, months and days.\n     *\n     * This creates an instance based on years, months and days.\n     *\n     * @param {!number} years - the amount of years, may be negative\n     * @param {!number} months - the amount of months, may be negative\n     * @param {!number} days - the amount of days, may be negative\n     * @return {Period} the period of years, months and days, not null\n     */\n    static of(years, months, days) {\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Period} from a temporal amount.\n     *\n     * This obtains a period based on the specified amount.\n     * A {@link TemporalAmount} represents an - amount of time, which may be\n     * date-based or time-based, which this factory extracts to a {@link Period}.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the {@link ChronoUnit#YEARS}, {@link ChronoUnit#MONTHS}\n     * and {@link ChronoUnit#DAYS} units to create a period.\n     * If any other units are found then an exception is thrown.\n     *\n     * If the amount is a {@link ChronoPeriod} then it must use the ISO chronology.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Period} the equivalent period, not null\n     * @throws DateTimeException if unable to convert to a {@link Period}\n     * @throws ArithmeticException if the amount of years, months or days exceeds an int\n     */\n    static from(amount) {\n        if (amount instanceof Period) {\n            return amount;\n        }\n        /*\n        if (amount instanceof ChronoPeriod) {\n            if (IsoChronology.INSTANCE !== amount.chronology()) {\n                throw new DateTimeException('Period requires ISO chronology: ' + amount);\n            }\n        }\n*/\n        requireNonNull(amount, 'amount');\n        let years = 0;\n        let months = 0;\n        let days = 0;\n        const units = amount.units();\n        for (let i=0; i<units.length; i++) {\n            const unit = units[i];\n            const unitAmount = amount.get(unit);\n            if (unit === ChronoUnit.YEARS) {\n                years = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.MONTHS) {\n                months = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.DAYS) {\n                days = MathUtil.safeToInt(unitAmount);\n            } else {\n                throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);\n            }\n        }\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} consisting of the number of years, months,\n     * and days between two dates.\n     *\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then split into years and months based on a 12 month year.\n     * A month is considered if the end day-of-month is greater than or equal to the start day-of-month.\n     * For example, from `2010-01-15` to `2011-03-18` is one year, two months and three days.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n\n     * see {@link ChronoLocalDate.until}\n     *\n     * @param {LocalDate} startDate - the start date, inclusive, not null\n     * @param {LocalDate} endDate - the end date, exclusive, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    static between(startDate, endDate) {\n        requireNonNull(startDate, 'startDate');\n        requireNonNull(endDate, 'endDate');\n        requireInstance(startDate, LocalDate, 'startDate');\n        requireInstance(endDate, LocalDate, 'endDate');\n        return startDate.until(endDate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} from a text string such as {@link PnYnMnD}.\n     *\n     * This will parse the string produced by {@link toString} which is\n     * based on the ISO-8601 period formats {@link PnYnMnD} and {@link PnW}.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter 'P' is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * At least one of the four sections must be present.\n     * The sections have suffixes in ASCII of 'Y', 'M', 'W' and 'D' for\n     * years, months, weeks and days, accepted in upper or lower case.\n     * The suffixes must occur in order.\n     * The number part of each section must consist of ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number must parse to an `int`.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard. In addition, ISO-8601 does not\n     * permit mixing between the {@link PnYnMnD} and {@link PnW} formats.\n     * Any week-based input is multiplied by 7 and treated as a number of days.\n     *\n     * For example, the following are valid inputs:\n     * <pre>\n     *   'P2Y'             -- Period.ofYears(2)\n     *   'P3M'             -- Period.ofMonths(3)\n     *   'P4W'             -- Period.ofWeeks(4)\n     *   'P5D'             -- Period.ofDays(5)\n     *   'P1Y2M3D'         -- Period.of(1, 2, 3)\n     *   'P1Y2M3W4D'       -- Period.of(1, 2, 25)\n     *   'P-1Y2M'          -- Period.of(-1, 2, 0)\n     *   '-P1Y2M'          -- Period.of(-1, -2, 0)\n     * </pre>\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Period} the parsed period, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a period\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        try {\n            return Period._parse(text);\n        } catch (ex){\n            if(ex instanceof ArithmeticException){\n                throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * because functions that containing a try/ catch block cant be optimized,\n     * we put the code in a sub function.\n     */\n    static _parse(text){\n        const matches = PATTERN.exec(text);\n        if (matches != null) {\n            const negate = '-' === matches[1] ? -1 : 1;\n            const yearMatch = matches[2];\n            const monthMatch = matches[3];\n            const weekMatch = matches[4];\n            const dayMatch = matches[5];\n            if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n                const years = Period._parseNumber(text, yearMatch, negate);\n                const months = Period._parseNumber(text, monthMatch, negate);\n                const weeks = Period._parseNumber(text, weekMatch, negate);\n                let days = Period._parseNumber(text, dayMatch, negate);\n                days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n                return Period.create(years, months, days);\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n    }\n\n    static _parseNumber(text, str, negate) {\n        if (str == null) {\n            return 0;\n        }\n        const val = MathUtil.parseInt(str);\n        return MathUtil.safeMultiply(val, negate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates an instance.\n     *\n     * @param {number} years - the amount\n     * @param {number} months - the amount\n     * @param {number} days - the amount\n     * @return {Duration}\n     */\n    static create(years, months, days) {\n        return new Period(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the list of units, from largest to smallest, that fully define this amount.\n     *\n     * @returns {ChronoUnit[]} list of units\n     */\n    units() {\n        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n    }\n\n    /**\n     * Gets the chronology that defines the meaning of the supported units.\n     *\n     * The period is defined by the chronology.\n     * It controls the supported units and restricts addition/subtraction\n     * to {@link ChronoLocalDate} instances of the same chronology.\n     *\n     * @return {IsoChronology} the chronology defining the period, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the value of the requested unit.\n     *\n     * The supported units are chronology specific.\n     * They will typically be {@link ChronoUnit#YEARS},\n     * {@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\n     * Requesting an unsupported unit will throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.YEARS) {\n            return this._years;\n        }\n        if (unit === ChronoUnit.MONTHS) {\n            return this._months;\n        }\n        if (unit === ChronoUnit.DAYS) {\n            return this._days;\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if all three units of this period are zero.\n     *\n     * A zero period has the value zero for the years, months and days units.\n     *\n     * @return {boolean} true if this period is zero-length\n     */\n    isZero() {\n        return (this === Period.ZERO);\n    }\n\n    /**\n     * Checks if any of the three units of this period are negative.\n     *\n     * This checks whether the years, months or days units are less than zero.\n     *\n     * @return {boolean} true if any unit of this period is negative\n     */\n    isNegative() {\n        return this._years < 0 || this._months < 0 || this._days < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the amount of years of this period.\n     *\n     * This returns the years unit.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of years of this period, may be negative\n     */\n    years() {\n        return this._years;\n    }\n\n    /**\n     * Gets the amount of months of this period.\n     *\n     * This returns the months unit.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of months of this period, may be negative\n     */\n    months() {\n        return this._months;\n    }\n\n    /**\n     * Gets the amount of days of this period.\n     *\n     * This returns the days unit.\n     *\n     * @return {number} the amount of days of this period, may be negative\n     */\n    days() {\n        return this._days;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount of years.\n     *\n     * This sets the amount of the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested years, not null\n     */\n    withYears(years) {\n        if (years === this._years) {\n            return this;\n        }\n        return Period.create(years, this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of months.\n     *\n     * This sets the amount of the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested months, not null\n     */\n    withMonths(months) {\n        if (months === this._months) {\n            return this;\n        }\n        return Period.create(this._years, months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of days.\n     *\n     * This sets the amount of the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested days, not null\n     */\n    withDays(days) {\n        if (days === this._days) {\n            return this;\n        }\n        return Period.create(this._years, this._months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount added.\n     *\n     * This input amount is converted to a {@link Period} using {@link from}.\n     * This operates separately on the years, months and days.\n     *\n     * For example, '1 year, 6 months and 3 days' plus '2 years, 2 months and 2 days'\n     * returns '3 years, 8 months and 5 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToAdd - the period to add, not null\n     * @return {Period} a {@link Period} based on this period with the requested period added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plus(amountToAdd) {\n        const amount = Period.from(amountToAdd);\n        return Period.create(\n            MathUtil.safeAdd(this._years, amount._years),\n            MathUtil.safeAdd(this._months, amount._months),\n            MathUtil.safeAdd(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years added.\n     *\n     * This adds the amount to the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 years returns '3 years, 6 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd - the years to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months added.\n     *\n     * This adds the amount to the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 months returns '1 year, 8 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd - the months to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days added.\n     *\n     * This adds the amount to the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 days returns '1 year, 6 months and 5 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToAdd - the days to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount subtracted.\n     *\n     * This input amount is converted to a {@link Period} using {@link from}.\n     * This operates separately on the years, months and days.\n     *\n     * For example, '1 year, 6 months and 3 days' minus '2 years, 2 months and 2 days'\n     * returns '-1 years, 4 months and 1 day'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToSubtract - the period to subtract, not null\n     * @return {Period} a {@link Period} based on this period with the requested period subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minus(amountToSubtract) {\n        const amount = Period.from(amountToSubtract);\n        return Period.create(\n            MathUtil.safeSubtract(this._years, amount._years),\n            MathUtil.safeSubtract(this._months, amount._months),\n            MathUtil.safeSubtract(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years subtracted.\n     *\n     * This subtracts the amount from the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 years returns '-1 years, 6 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(-1 * yearsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months subtracted.\n     *\n     * This subtracts the amount from the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 months returns '1 year, 4 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(-1 * monthsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days subtracted.\n     *\n     * This subtracts the amount from the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 days returns '1 year, 6 months and 1 day'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToSubtract - the months to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(-1 * daysToSubtract);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * This simply multiplies each field, years, months, days and normalized time,\n     * by the scalar. No normalization is performed.\n     *\n     * @param {number} scalar - the scalar to multiply by, not null\n     * @return {Period} a {@link Period} based on this period with the amounts multiplied by the scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(scalar) {\n        if (this === Period.ZERO || scalar === 1) {\n            return this;\n        }\n        return Period.create(\n            MathUtil.safeMultiply(this._years, scalar),\n            MathUtil.safeMultiply(this._months, scalar),\n            MathUtil.safeMultiply(this._days, scalar));\n    }\n\n    /**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return {Period} a {@link Period} based on this period with the amounts negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the years and months normalized\n     * using a 12 month year.\n     *\n     * This normalizes the years and months units, leaving the days unit unchanged.\n     * The months unit is adjusted to have an absolute value less than 11,\n     * with the years unit being adjusted to compensate. For example, a period of\n     * '1 Year and 15 months' will be normalized to '2 years and 3 months'.\n     *\n     * The sign of the years and months units will be the same after normalization.\n     * For example, a period of '1 year and -25 months' will be normalized to\n     * '-1 year and -1 month'.\n     *\n     * This normalization uses a 12 month year which is not valid for all calendar systems.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Period} a {@link Period} based on this period with excess months normalized to years, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    normalized() {\n        const totalMonths = this.toTotalMonths();\n        const splitYears = MathUtil.intDiv(totalMonths, 12);\n        const splitMonths = MathUtil.intMod(totalMonths, 12);  // no overflow\n        if (splitYears === this._years && splitMonths === this._months) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n    }\n\n    /**\n     * Gets the total number of months in this period using a 12 month year.\n     *\n     * This returns the total number of months in the period by multiplying the\n     * number of years by 12 and adding the number of months.\n     *\n     * This uses a 12 month year which is not valid for all calendar systems.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the total number of months in the period, may be negative\n     */\n    toTotalMonths() {\n        return this._years * 12 + this._months;  // no overflow\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this period to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this period added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisPeriod);\n     * </pre>\n     *\n     * The calculation will add the years, then months, then days.\n     * Only non-zero amounts will be added.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this period from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this period subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisPeriod);\n     * </pre>\n     *\n     * The calculation operates as follows.\n     * First, the chronology of the temporal is checked to ensure it is ISO chronology or null.\n     * Second, if the months are zero, the years are added if non-zero, otherwise\n     * the combination of years and months is added if non-zero.\n     * Finally, any days are added.\n     *\n     * The calculation will subtract the years, then months, then days.\n     * Only non-zero amounts will be subtracted.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this period is equal to another period.\n     *\n     * The comparison is based on the amounts held in the period.\n     * To be equal, the years, months and days units must be individually equal.\n     * Note that this means that a period of '15 Months' is not equal to a period\n     * of '1 Year and 3 Months'.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other period\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Period) {\n            const other = obj;\n            return this._years === other._years &&\n                this._months === other._months &&\n                this._days === other._days;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this period.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._years, this._months, this._days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this period as a string, such as {@link P6Y3M1D}.\n     *\n     * The output will be in the ISO-8601 period format.\n     * A zero period will be represented as zero days, 'P0D'.\n     *\n     * @return {string} a string representation of this period, not null\n     */\n    toString() {\n        if (this === Period.ZERO) {\n            return 'P0D';\n        } else {\n            let buf = 'P';\n            if (this._years !== 0) {\n                buf += '' + this._years + 'Y';\n            }\n            if (this._months !== 0) {\n                buf += '' + this._months + 'M';\n            }\n            if (this._days !== 0) {\n                buf += '' + this._days + 'D';\n            }\n            return buf;\n        }\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Period.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nexport function _init() {\n    /**\n     * A constant for a period of zero.\n     */\n    Period.ofDays(0);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class ParsePosition {\n    constructor(index) {\n        this._index = index;\n        this._errorIndex = -1;\n    }\n\n    getIndex(){\n        return this._index;\n    }\n\n    setIndex(index){\n        this._index = index;\n    }\n\n    getErrorIndex(){\n        return this._errorIndex;\n    }\n\n    setErrorIndex(errorIndex){\n        this._errorIndex = errorIndex;\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class EnumMap {\n    constructor(){\n        this._map = {};\n    }\n\n    putAll(otherMap){\n        for(const key in otherMap._map){\n            this._map[key] = otherMap._map[key];\n        }\n        return this;\n    }\n\n    containsKey(key){\n        return (this._map.hasOwnProperty(key.name())) && (this.get(key) !== undefined);\n    }\n\n    get(key) {\n        return this._map[key.name()];\n    }\n\n    put(key, val) {\n        return this.set(key, val);\n    }\n\n    set(key, val) {\n        this._map[key.name()] = val;\n        return this;\n    }\n\n    retainAll(keyList){\n        const map = {};\n        for(let i=0; i<keyList.length; i++){\n            const key = keyList[i].name();\n            map[key] = this._map[key];\n        }\n        this._map = map;\n        return this;\n    }\n\n    /**\n     * due to the bad performance of delete we just set the key entry to undefined.\n     *\n     * this might lead to issues with \"null\" entries. Calling clear in the end might solve the issue\n     * @param key\n     * @returns {*}\n     */\n    remove(key){\n        const keyName = key.name();\n        const val = this._map[keyName];\n        this._map[keyName] = undefined;\n        return val;\n    }\n\n    keySet(){\n        return this._map;\n    }\n\n    clear(){\n        this._map = {};\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\n/**\n * Enumeration of different ways to resolve dates and times.\n * \n * Parsing a text string occurs in two phases.\n * Phase 1 is a basic text parse according to the fields added to the builder.\n * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n * This style is used to control how phase 2, resolving, happens.\n *\n * ### Static properties of Class {@link DateTimeFormatter}\n *\n * ResolverStyle.STRICT = new ResolverStyle('STRICT');\n *\n * Style to resolve dates and times strictly.\n *\n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n *\n * ResolverStyle.SMART = new ResolverStyle('SMART');\n *\n * Style to resolve dates and times in a smart, or intelligent, manner.\n *\n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n *\n * ResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n *\n * Style to resolve dates and times leniently.\n *\n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n *\n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n *\n */\nexport class ResolverStyle extends Enum {}\n\n/**\n * Style to resolve dates and times strictly.\n * \n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n */\nResolverStyle.STRICT = new ResolverStyle('STRICT');\n/**\n * Style to resolve dates and times in a smart, or intelligent, manner.\n * \n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n */\nResolverStyle.SMART = new ResolverStyle('SMART');\n/**\n * Style to resolve dates and times leniently.\n * \n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n * \n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n */\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {DateTimeException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {EnumMap} from './EnumMap';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoLocalDate} from '../chrono/ChronoLocalDate';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nimport {LocalTime} from '../LocalTime';\nimport {LocalDate} from '../LocalDate';\nimport {Period} from '../Period';\n\nimport {ZoneOffset} from '../ZoneOffset';\n\n/**\n * Builder that can holds date and time fields and related date and time objects.\n *\n * The builder is used to hold onto different elements of date and time.\n * It is designed as two separate maps:\n *\n * * from {@link TemporalField} to `long` value, where the value may be\n *   outside the valid range for the field\n * * from {@link Class} to {@link TemporalAccessor}, holding larger scale objects\n *   like {@link LocalDateTime}.\n *\n *   @private\n */\nexport class DateTimeBuilder extends Temporal {\n\n    /**\n     * Creates a new instance of the builder with a single field-value.\n     *\n     * This is equivalent to using {@link addFieldValue} on an empty builder.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {number} value - the value to add, not null\n     * @return {DateTimeBuilder}\n     */\n    static create(field, value) {\n        const dtb = new DateTimeBuilder();\n        dtb._addFieldValue(field, value);\n        return dtb;\n    }\n\n\n    constructor(){\n        super();\n\n        /**\n         * The map of other fields.\n         */\n        this.fieldValues = new EnumMap();\n        /**\n         * The chronology.\n         */\n        this.chrono = null;\n        /**\n         * The zone.\n         */\n        this.zone = null;\n        /**\n         * The date.\n         */\n        this.date = null;\n        /**\n         * The time.\n         */\n        this.time = null;\n        /**\n         * The leap second flag.\n         */\n        this.leapSecond = false;\n        /**\n         * The excess days.\n         */\n        this.excessDays = null;\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @return {Number} field value\n     */\n    getFieldValue0(field) {\n        return this.fieldValues.get(field);\n    }\n\n    /**\n     * Adds a field-value pair to the builder.\n     *\n     * This adds a field to the builder.\n     * If the field is not already present, then the field-value pair is added to the map.\n     * If the field is already present and it has the same value as that specified, no action occurs.\n     * If the field is already present and it has a different value to that specified, then\n     * an exception is thrown.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {Number} value - the value to add, not null\n     * @return {DateTimeBuilder}, this for method chaining\n     * @throws DateTimeException if the field is already present with a different value\n     */\n    _addFieldValue(field, value) {\n        requireNonNull(field, 'field');\n        const old = this.getFieldValue0(field);  // check first for better error message\n        if (old != null && old !== value) {\n            throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);\n        }\n        return this._putFieldValue0(field, value);\n    }\n\n    /**\n     * @param {TemporalField} field\n     * @param {Number} value\n     * @return {DateTimeBuilder}, this for method chaining\n     */\n    _putFieldValue0(field, value) {\n        this.fieldValues.put(field, value);\n        return this;\n    }\n\n    /**\n     * Resolves the builder, evaluating the date and time.\n     *\n     * This examines the contents of the build.er and resolves it to produce the best\n     * available date and time, throwing an exception if a problem occurs.\n     * Calling this method changes the state of the builder.\n     *\n     * @param {ResolverStyle} resolverStyle - how to resolve\n     * @param {TemporalField[]} resolverFields\n     * @return {DateTimeBuilder} this, for method chaining\n     */\n    resolve(resolverStyle, resolverFields) {\n        if (resolverFields != null) {\n            this.fieldValues.retainAll(resolverFields);\n        }\n        // handle standard fields\n        // this._mergeInstantFields();\n        this._mergeDate(resolverStyle);\n        this._mergeTime(resolverStyle);\n        //if (resolveFields(resolverStyle)) {\n        //    mergeInstantFields();\n        //    mergeDate(resolverStyle);\n        //    mergeTime(resolverStyle);\n        //}\n        this._resolveTimeInferZeroes(resolverStyle);\n        //this._crossCheck();\n        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n            this.date = this.date.plus(this.excessDays);\n            this.excessDays = Period.ZERO;\n        }\n        //resolveFractional();\n        this._resolveInstant();\n        return this;\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeDate(resolverStyle) {\n        //if (this.chrono instanceof IsoChronology) {\n        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n        //} else {\n        //    if (this.fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n        //        this._checkDate(LocalDate.ofEpochDay(this.fieldValues.remove(ChronoField.EPOCH_DAY)));\n        //        return;\n        //    }\n        //}\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @private\n     */\n    _checkDate(date) {\n        if (date != null) {\n            this._addObject(date);\n            for (const fieldName in this.fieldValues.keySet()) {\n                const field = ChronoField.byName(fieldName);\n                if (field) {\n                    if (this.fieldValues.get(field) !== undefined) { // undefined if \"removed\" in EnumMap\n                        if (field.isDateBased()) {\n                            let val1;\n                            try {\n                                val1 = date.getLong(field);\n                            } catch (ex) {\n                                if (ex instanceof DateTimeException) {\n                                    continue;\n                                } else {\n                                    throw ex;\n                                }\n                            }\n                            const val2 = this.fieldValues.get(field);\n                            if (val1 !== val2) {\n                                throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeTime(resolverStyle) {\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n            const ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n        }\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n            const ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_AMPM, ch === 12 ? 0 : ch);\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n                ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n            }\n            if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n                ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n            const ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n            const hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n        }\n        //        if (timeFields.containsKey(HOUR_OF_DAY) && timeFields.containsKey(MINUTE_OF_HOUR)) {\n        //            const hod = timeFields.remove(HOUR_OF_DAY);\n        //            const moh = timeFields.remove(MINUTE_OF_HOUR);\n        //            this._addFieldValue(MINUTE_OF_DAY, hod * 60 + moh);\n        //        }\n        //        if (timeFields.containsKey(MINUTE_OF_DAY) && timeFields.containsKey(SECOND_OF_MINUTE)) {\n        //            const mod = timeFields.remove(MINUTE_OF_DAY);\n        //            const som = timeFields.remove(SECOND_OF_MINUTE);\n        //            this._addFieldValue(SECOND_OF_DAY, mod * 60 + som);\n        //        }\n        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n            const nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.NANO_OF_DAY.checkValidValue(nod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n            const cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n            const lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n            const sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n            this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n            const mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n        }\n\n        //            const sod = MathUtil.intDiv(nod, 1000000000L);\n        //            this._addFieldValue(HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n        //            this._addFieldValue(MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n        //            this._addFieldValue(SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        //            this._addFieldValue(NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000L));\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n                ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n            }\n            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n                ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            const los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            const cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + (MathUtil.intMod(cos, 1000)));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            const nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n            this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            const nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(nos, 1000000));\n            this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            const cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, cos * 1000);\n        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n            const los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, los * 1000000);\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _resolveTimeInferZeroes(resolverStyle) {\n        let hod =  this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n        const moh =  this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n        const som =  this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n        let nos =  this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n        if (hod == null) {\n            return;\n        }\n        if (moh == null && (som != null || nos != null)) {\n            return;\n        }\n        if (moh != null && som == null && nos != null) {\n            return;\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (hod != null) {\n                if (resolverStyle === ResolverStyle.SMART &&\n                                hod === 24 &&\n                                (moh == null || moh === 0) &&\n                                (som == null || som === 0) &&\n                                (nos == null || nos === 0)) {\n                    hod = 0;\n                    this.excessDays = Period.ofDays(1);\n                }\n                const hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n                if (moh != null) {\n                    const mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n                    if (som != null) {\n                        const somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n                        if (nos != null) {\n                            const nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n                        } else {\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n                        }\n                    } else {\n                        if (nos == null) {\n                            this._addObject(LocalTime.of(hodVal, mohVal));\n                        }\n                    }\n                } else {\n                    if (som == null && nos == null) {\n                        this._addObject(LocalTime.of(hodVal, 0));\n                    }\n                }\n            }\n        } else {\n            if (hod != null) {\n                let hodVal = hod;\n                if (moh != null) {\n                    if (som != null) {\n                        if (nos == null) {\n                            nos = 0;\n                        }\n                        let totalNanos = MathUtil.safeMultiply(hodVal, 3600000000000);\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, nos);\n                        const excessDays =  MathUtil.floorDiv(totalNanos, 86400000000000);  // safe int cast\n                        const nod = MathUtil.floorMod(totalNanos, 86400000000000);\n                        this._addObject(LocalTime.ofNanoOfDay(nod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    } else {\n                        let totalSecs = MathUtil.safeMultiply(hodVal, 3600);\n                        totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n                        const excessDays =  MathUtil.floorDiv(totalSecs, 86400);  // safe int cast\n                        const sod = MathUtil.floorMod(totalSecs, 86400);\n                        this._addObject(LocalTime.ofSecondOfDay(sod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    }\n                } else {\n                    const excessDays = MathUtil.safeToInt(MathUtil.floorDiv(hodVal, 24));\n                    hodVal = MathUtil.floorMod(hodVal, 24);\n                    this._addObject(LocalTime.of(hodVal, 0));\n                    this.excessDays = Period.ofDays(excessDays);\n                }\n            }\n        }\n        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n    }\n\n    /**\n     *\n     * @param {ChronoLocalDate|LocalTime} dateOrTime\n     * @private\n     */\n    _addObject(dateOrTime) {\n        if (dateOrTime instanceof ChronoLocalDate){\n            this.date = dateOrTime;\n        } else if (dateOrTime instanceof LocalTime){\n            this.time = dateOrTime;\n        }\n    }\n\n    _resolveInstant() {\n        if (this.date != null && this.time != null) {\n            const offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);\n            if (offsetSecs != null) {\n                const offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n                const instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);\n                this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n            } else if (this.zone != null) {\n                const instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);\n                this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n            }\n        }\n    }\n\n    /**\n     * Builds the specified type from the values in this builder.\n     *\n     * This attempts to build the specified type from this builder.\n     * If the builder cannot return the type, an exception is thrown.\n     *\n     * @param {!TemporalQuery} type - the type to invoke `from` on, not null\n     * @return {*} the extracted value, not null\n     * @throws DateTimeException if an error occurs\n     */\n    build(type) {\n        return type.queryFrom(this);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    isSupported(field) {\n        if (field == null) {\n            return false;\n        }\n        return (this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined) ||\n                (this.date != null && this.date.isSupported(field)) ||\n                (this.time != null && this.time.isSupported(field));\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        const value = this.getFieldValue0(field);\n        if (value == null) {\n            if (this.date != null && this.date.isSupported(field)) {\n                return this.date.getLong(field);\n            }\n            if (this.time != null && this.time.isSupported(field)) {\n                return this.time.getLong(field);\n            }\n            throw new DateTimeException('Field not found: ' + field);\n        }\n        return value;\n    }\n\n    /**\n     *\n     * @param {!TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()) {\n            return this.zone;\n        } else if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        } else if (query === TemporalQueries.localDate()) {\n            return this.date != null ? LocalDate.from(this.date) : null;\n        } else if (query === TemporalQueries.localTime()) {\n            return this.time;\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return query.queryFrom(this);\n        } else if (query === TemporalQueries.precision()) {\n            return null;  // not a complete date/time\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\n\nimport {DateTimeBuilder} from './DateTimeBuilder';\nimport {EnumMap} from './EnumMap';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\n/**\n * @private\n */\nexport class DateTimeParseContext{\n\n    constructor(){\n        if(arguments.length === 1){\n            if(arguments[0] instanceof DateTimeParseContext){\n                this._constructorSelf.apply(this, arguments);\n                return;\n            } else {\n                this._constructorFormatter.apply(this, arguments);\n            }\n        } else {\n            this._constructorParam.apply(this, arguments);\n        }\n\n        this._caseSensitive = true;\n        this._strict = true;\n        this._parsed = [new Parsed(this)];\n    }\n\n    _constructorParam(locale, symbols, chronology){\n        this._locale = locale;\n        this._symbols = symbols;\n        this._overrideChronology = chronology;\n    }\n\n    _constructorFormatter(formatter){\n        this._locale = formatter.locale();\n        this._symbols = formatter.decimalStyle();\n        this._overrideChronology = formatter.chronology();\n    }\n\n\n    _constructorSelf(other) {\n        this._locale = other._locale;\n        this._symbols = other._symbols;\n        this._overrideChronology = other._overrideChronology;\n        this._overrideZone = other._overrideZone;\n        this._caseSensitive = other._caseSensitive;\n        this._strict = other._strict;\n        this._parsed = [new Parsed(this)];\n    }\n\n    /**\n     * Creates a copy of this context.\n     */\n    copy() {\n        return new DateTimeParseContext(this);\n    }\n\n    symbols(){\n        return this._symbols;\n    }\n\n    isStrict(){\n        return this._strict;\n    }\n\n    setStrict(strict){\n        this._strict = strict;\n    }\n\n    locale() {\n        return this._locale;\n    }\n\n    setLocale(locale) {\n        this._locale = locale;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Starts the parsing of an optional segment of the input.\n     */\n    startOptional() {\n        this._parsed.push(this.currentParsed().copy());\n    }\n\n    /**\n     * Ends the parsing of an optional segment of the input.\n     *\n     * @param {boolean} successful  whether the optional segment was successfully parsed\n     */\n    endOptional(successful) {\n        if (successful) {\n            this._parsed.splice(this._parsed.length - 2, 1);\n        } else {\n            this._parsed.splice(this._parsed.length - 1, 1);\n        }\n    }\n\n    /**\n     * Checks if parsing is case sensitive.\n     *\n     * @return true if parsing is case sensitive, false if case insensitive\n     */\n    isCaseSensitive() {\n        return this._caseSensitive;\n    }\n\n    /**\n     * Sets whether the parsing is case sensitive or not.\n     *\n     * @param caseSensitive  changes the parsing to be case sensitive or not from now on\n     */\n    setCaseSensitive(caseSensitive) {\n        this._caseSensitive = caseSensitive;\n    }\n\n    /**\n     * Helper to compare two {@link CharSequence} instances.\n     * This uses {@link isCaseSensitive}.\n     *\n     * @param cs1  the first character sequence, not null\n     * @param offset1  the offset into the first sequence, valid\n     * @param cs2  the second character sequence, not null\n     * @param offset2  the offset into the second sequence, valid\n     * @param length  the length to check, valid\n     * @return true if equal\n     */\n    subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n            return false;\n        }\n        if (! this.isCaseSensitive()) {\n            cs1 = cs1.toLowerCase();\n            cs2 = cs2.toLowerCase();\n        }\n        for (let i = 0; i < length; i++) {\n            const ch1 = cs1[offset1 + i];\n            const ch2 = cs2[offset2 + i];\n            if (ch1 !== ch2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Helper to compare two `char`.\n     * This uses {@link isCaseSensitive}.\n     *\n     * @param ch1  the first character\n     * @param ch2  the second character\n     * @return true if equal\n     */\n    charEquals(ch1, ch2) {\n        if (this.isCaseSensitive()) {\n            return ch1 === ch2;\n        }\n        return this.charEqualsIgnoreCase(ch1, ch2);\n    }\n\n    /**\n     * Compares two characters ignoring case.\n     *\n     * @param c1  the first\n     * @param c2  the second\n     * @return true if equal\n     */\n    charEqualsIgnoreCase(c1, c2) {\n        return c1 === c2 ||\n                c1.toLowerCase() === c2.toLowerCase();\n    }\n\n    setParsedField(field, value, errorPos, successPos){\n        const currentParsedFieldValues = this.currentParsed().fieldValues;\n        const old = currentParsedFieldValues.get(field);\n        currentParsedFieldValues.set(field, value);\n        return (old != null && old !== value) ? ~errorPos : successPos;\n    }\n\n    /**\n     * Stores the parsed zone.\n     *\n     * This stores the zone that has been parsed.\n     * No validation is performed other than ensuring it is not null.\n     *\n     * @param {ZoneId} zone  the parsed zone, not null\n     */\n    setParsedZone(zone) {\n        requireNonNull(zone, 'zone');\n        this.currentParsed().zone = zone;\n    }\n\n    getParsed(field) {\n        return this.currentParsed().fieldValues.get(field);\n    }\n\n    toParsed() {\n        return this.currentParsed();\n    }\n\n    currentParsed() {\n        return this._parsed[this._parsed.length - 1];\n    }\n\n    /**\n     * Stores the leap second.\n     */\n    setParsedLeapSecond() {\n        this.currentParsed().leapSecond = true;\n    }\n\n    /**\n     * Gets the effective chronology during parsing.\n     *\n     * @return the effective parsing chronology, not null\n     */\n    getEffectiveChronology() {\n        let chrono = this.currentParsed().chrono;\n        if (chrono == null) {\n            chrono = this._overrideChronology;\n            if (chrono == null) {\n                chrono = IsoChronology.INSTANCE;\n            }\n        }\n        return chrono;\n    }\n\n\n}\n\nclass Parsed extends Temporal {\n    constructor(dateTimeParseContext){\n        super();\n        this.chrono = null;\n        this.zone = null;\n        this.fieldValues = new EnumMap();\n        this.leapSecond = false;\n        this.dateTimeParseContext = dateTimeParseContext;\n    }\n\n    copy() {\n        const cloned = new Parsed();\n        cloned.chrono = this.chrono;\n        cloned.zone = this.zone;\n        cloned.fieldValues.putAll(this.fieldValues);\n        cloned.leapSecond = this.leapSecond;\n        cloned.dateTimeParseContext = this.dateTimeParseContext;\n        return cloned;\n    }\n\n    toString() {\n        return `${this.fieldValues}, ${this.chrono}, ${this.zone}`;\n    }\n\n    isSupported(field) {\n        return this.fieldValues.containsKey(field);\n    }\n\n    get(field) {\n        const val = this.fieldValues.get(field);\n        assert(val != null);\n        return val;\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        }\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone;\n        }\n        return super.query(query);\n    }\n\n    toBuilder() {\n        const builder = new DateTimeBuilder();\n        builder.fieldValues.putAll(this.fieldValues);\n        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n        if (this.zone != null) {\n            builder.zone = this.zone;\n        } else {\n            builder.zone = this.overrideZone;\n        }\n        builder.leapSecond = this.leapSecond;\n        builder.excessDays = this.excessDays;\n        return builder;\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException} from '../errors';\n\nimport {DateTimeFormatter} from './DateTimeFormatter';\n\n/**\n * @private\n */\nexport class DateTimePrintContext{\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter|Locale} localeOrFormatter\n     * @param {DecimalStyle} symbols\n     */\n    constructor(temporal, localeOrFormatter, symbols) {\n        if(arguments.length === 2 && arguments[1] instanceof DateTimeFormatter){\n            this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n            this._locale = localeOrFormatter.locale();\n            this._symbols = localeOrFormatter.decimalStyle();\n        } else {\n            this._temporal = temporal;\n            this._locale = localeOrFormatter;\n            this._symbols = symbols;\n        }\n        this._optional = 0;\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter} formatter\n     * @returns {TemporalAccessor}\n     */\n    // eslint-disable-next-line no-unused-vars\n    static adjust(temporal, formatter) {\n        // TODO implement\n        return temporal;\n    }\n\n\n    symbols(){\n        return this._symbols;\n    }\n\n    /**\n     * Starts the printing of an optional segment of the input.\n     */\n    startOptional() {\n        this._optional++;\n    }\n\n    /**\n     * Ends the printing of an optional segment of the input.\n     */\n    endOptional() {\n        this._optional--;\n    }\n\n    /**\n     * Gets a value using a query.\n     *\n     * @param {TemporalQuery} query  the query to use, not null\n     * @return {*} the result, null if not found and optional is true\n     * @throws DateTimeException if the type is not available and the section is not optional\n     */\n    getValueQuery(query) {\n        const result = this._temporal.query(query);\n        if (result == null && this._optional === 0) {\n            throw new DateTimeException('Unable to extract value: ' + this._temporal);\n        }\n        return result;\n    }\n\n    /**\n     * Gets the value of the specified field.\n     *\n     * This will return the value for the specified field.\n     *\n     * @param field  the field to find, not null\n     * @return the value, null if not found and optional is true\n     * @throws DateTimeException if the field is not available and the section is not optional\n     */\n    getValue(field) {\n        try {\n            return this._temporal.getLong(field);\n        } catch (ex) {\n            if ((ex instanceof DateTimeException) && this._optional > 0) {\n                return null;\n            }\n            throw ex;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the temporal object being output.\n     *\n     * @return {TemporalAccessor} the temporal object, not null\n     */\n    temporal() {\n        return this._temporal;\n    }\n\n    /**\n     * Gets the locale.\n     * <p>\n     * This locale is used to control localization in the print output except\n     * where localization is controlled by the symbols.\n     *\n     * @return the locale, not null\n     */\n    locale() {\n        return this._locale;\n    }\n\n    //-------------------------------------------------------------------------\n    // for testing\n    /**\n     * Sets the date-time being output.\n     *\n     * @param temporal  the date-time object, not null\n     */\n    setDateTime(temporal) {\n        this._temporal = temporal;\n    }\n\n    setLocale(locale) {\n        this._locale = locale;\n    }\n\n\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\nexport class SignStyle extends Enum{\n    /**\n     * Parse helper.\n     *\n     * @param positive  true if positive sign parsed, false for negative sign\n     * @param strict  true if strict, false if lenient\n     * @param fixedWidth  true if fixed width, false if not\n     * @return true if valid\n     */\n    parse(positive, strict, fixedWidth){\n        switch (this) {\n            case SignStyle.NORMAL: // NORMAL\n                // valid if negative or (positive and lenient)\n                return !positive || !strict;\n            case SignStyle.ALWAYS: // ALWAYS\n            case SignStyle.EXCEEDS_PAD: // EXCEEDS_PAD\n                return true;\n            default:\n                // valid if lenient and not fixed width\n                return !strict && !fixedWidth;\n        }\n\n    }\n}\n\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class StringBuilder {\n    constructor(){\n        this._str = '';\n    }\n\n    append(str){\n        this._str += str;\n        return this;\n    }\n\n    appendChar(str){\n        this._str += str[0];\n        return this;\n    }\n\n    insert(offset, str){\n        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n        return this;\n    }\n\n    replace(start, end, str){\n        this._str = this._str.slice(0, start) + str + this._str.slice(end);\n        return this;\n    }\n\n    length(){\n        return this._str.length;\n    }\n\n    setLength(length){\n        this._str = this._str.slice(0, length);\n        return this;\n    }\n\n\n    toString() {\n        return this._str;\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\n\nimport {DateTimeParseException, NullPointerException} from '../errors';\n\nimport {Period} from '../Period';\n\nimport {ParsePosition} from './ParsePosition';\nimport {DateTimeBuilder} from './DateTimeBuilder';\nimport {DateTimeParseContext} from './DateTimeParseContext';\nimport {DateTimePrintContext} from './DateTimePrintContext';\nimport {DateTimeFormatterBuilder} from './DateTimeFormatterBuilder';\nimport {SignStyle} from './SignStyle';\nimport {StringBuilder} from './StringBuilder';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {createTemporalQuery} from '../temporal/TemporalQuery';\n\n/**\n *\n * ### Static properties of Class {@link DateTimeFormatter}\n *\n * DateTimeFormatter.ISO_LOCAL_DATE\n *\n * DateTimeFormatter.ISO_LOCAL_TIME\n *\n * DateTimeFormatter.ISO_LOCAL_DATE_TIME\n *\n */\nexport class DateTimeFormatter {\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     *\n     * This returns a singleton {@link TemporalQuery} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     *\n     * There are two situations where this query may return a non-zero period.\n     *\n     * * If the {@link ResolverStyle} is {@link LENIENT} and a time is parsed\n     *   without a date, then the complete result of the parse consists of a\n     *   {@link LocalTime} and an excess {@link Period} in days.\n     * * If the {@link ResolverStyle} is {@link SMART} and a time is parsed\n     *   without a date where the time is 24:00:00, then the complete result of\n     *   the parse consists of a {@link LocalTime} of 00:00:00 and an excess\n     *   {@link Period} of one day.\n     *\n     * In both cases, if a complete {@link ChronoLocalDateTime} or {@link Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     *\n     * The {@link SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@link LENIENT} mode also produces the same result:\n     * <pre>\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * </pre>\n     * The query can be used as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  LocalTime time = parsed.query(LocalTime.FROM);\n     *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());\n     * </pre>\n     * @return {TemporalQuery} a query that provides access to the excess days that were parsed\n     */\n    static parsedExcessDays() {\n        return DateTimeFormatter.PARSED_EXCESS_DAYS;\n    }\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     *\n     * This returns a singleton {@link TemporalQuery} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     *\n     * Instant parsing handles the special \"leap second\" time of '23:59:60'.\n     * Leap seconds occur at '23:59:60' in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant}, as that method\n     * always parses the instant with the UTC zone offset.\n     *\n     * If the time '23:59:60' is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return one second of excess if it did adjust to remove\n     * the leap-second, and zero if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  Instant instant = parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * </pre>\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    static parsedLeapSecond() {\n        return DateTimeFormatter.PARSED_LEAP_SECOND;\n    }\n\n    /**\n     * Creates a formatter using the specified pattern.\n     *\n     * This method will create a formatter based on a simple pattern of letters and symbols.\n     *\n     * The returned formatter will use the default locale, but this can be changed\n     * using {@link DateTimeFormatter.withLocale}.\n     *\n     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n     * The following pattern letters are defined:\n     * <pre>\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | u      | year                       | year             | 2004; 04\n     *  | y      | year-of-era                | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     * </pre>\n     *\n     * The count of pattern letters determine the format.\n     *\n     * **Text**: The text style is determined based on the number of pattern letters used.\n     * Less than 4 pattern letters will use the short form `TextStyle.SHORT`.\n     * Exactly 4 pattern letters will use the full form `TextStyle.FULL`.\n     * Exactly 5 pattern letters will use the narrow form `TextStyle.NARROW`.\n     *\n     * **NOTE**: since text styles require locale support, they are currently not supported in js-joda!\n     *\n     * **Number**: If the count of letters is one, then the value is printed using the minimum number\n     * of digits and without padding as per {@link DateTimeFormatterBuilder.appendValue}.\n     * Otherwise, the count of digits is used as the width of the output field as per\n     * {@link DateTimeFormatterBuilder.appendValue}.\n     *\n     * **Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\n     * Otherwise use the Number rules above.\n     *\n     * **Fraction**: Outputs the nano-of-second field as a fraction-of-second.\n     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\n     * If it is less than 9, then the nano-of-second value is truncated, with only the most\n     * significant digits being output.\n     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.\n     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern\n     * letters, up to 9 digits.\n     *\n     * **Year**: The count of letters determines the minimum field width below which padding is used.\n     * If the count of letters is two, then a {@link DateTimeFormatterBuilder.appendValueReduced}\n     * two digit form is used.\n     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the\n     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\n     * If the count of letters is less than four (but not two), then the sign is only output for negative\n     * years as per `SignStyle.NORMAL`.\n     * Otherwise, the sign is output if the pad width is exceeded, as per `SignStyle.EXCEEDS_PAD`\n     *\n     * **ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\n     * If the count of letters is two, then the time-zone ID is output.\n     * Any other count of letters throws `IllegalArgumentException`.\n     *\n     * **Zone names**: This outputs the display name of the time-zone ID.\n     * If the count of letters is one, two or three, then the short name is output.\n     * If the count of letters is four, then the full name is output.\n     * Five or more letters throws `IllegalArgumentException`.\n     *\n     * **NOTE**: since zone ids and name require the iana tzdb, they are currently not supported in js-joda!\n     *\n     * **Offset X and x**: This formats the offset based on the number of pattern letters.\n     * One letter outputs just the hour', such as '+01', unless the minute is non-zero\n     * in which case the minute is also output, such as '+0130'.\n     * Two letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Three letters outputs the hour and minute, with a colon, such as '+01:30'.\n     * Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\n     * Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\n     * Six or more letters throws `IllegalArgumentException`.\n     * Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\n     * whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n     *\n     * **Offset Z**: This formats the offset based on the number of pattern letters.\n     * One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Four or more letters throws `IllegalArgumentException`.\n     * The output will be '+0000' when the offset is zero.\n     *\n     * **Optional section**: The optional section markers work exactly like calling\n     * {@link DateTimeFormatterBuilder.optionalStart} and {@link DateTimeFormatterBuilder.optionalEnd}.\n     *\n     * **Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\n     * The pad width is determined by the number of pattern letters.\n     * This is the same as calling {@link DateTimeFormatterBuilder.padNext}.\n     *\n     * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n     *\n     * Any unrecognized letter is an error.\n     * Any non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\n     * Despite this, it is recommended to use single quotes around all characters that you want to\n     * output directly to ensure that future changes do not break your application.\n     *\n     * @param {String} pattern  the pattern to use, not null\n     * @return {DateTimeFormatter} the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     * @example\n     * var s = LocalDate.parse('2016-04-01').format(DateTimeFormatter.ofPattern('d MM yyyy'));\n     * console.log(s); // '1 04 2016'\n     *\n     */\n    static ofPattern(pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the decimal style to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     * @private\n     */\n    constructor(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono=IsoChronology.INSTANCE, zone) {\n        assert(printerParser != null);\n        assert(decimalStyle != null);\n        assert(resolverStyle != null);\n        /**\n         * The printer and/or parser to use, not null.\n         */\n        this._printerParser = printerParser;\n        /**\n         * The locale to use for formatting. // nyi\n         */\n        this._locale = locale;\n        /**\n         * The symbols to use for formatting, not null.\n         */\n        this._decimalStyle = decimalStyle;\n        /**\n         * The resolver style to use, not null.\n         */\n        this._resolverStyle = resolverStyle;\n        /**\n         * The fields to use in resolving, null for all fields.\n         */\n        this._resolverFields = resolverFields;\n        /**\n         * The chronology to use for formatting, null for no override.\n         */\n        this._chrono = chrono;\n        /**\n         * The zone to use for formatting, null for no override. // nyi\n         */\n        this._zone = zone;\n    }\n\n    locale() {\n        return this._locale;\n    }\n\n    decimalStyle() {\n        return this._decimalStyle;\n    }\n\n    chronology() {\n        return this._chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     *\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     *\n     * If an override is added, then any date that is printed or parsed will be affected.\n     *\n     * When printing, if the {@link Temporal} object contains a date then it will\n     * be converted to a date in the override chronology.\n     * Any time or zone will be retained unless overridden.\n     * The converted result will behave in a manner equivalent to an implementation\n     * of {@link ChronoLocalDate},{@link ChronoLocalDateTime} or {@link ChronoZonedDateTime}.\n     *\n     * When parsing, the override chronology will be used to interpret the\n     * {@link ChronoField} into a date unless the\n     * formatter directly parses a valid chronology.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, not null\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    withChronology(chrono) {\n        if (this._chrono != null && this._chrono.equals(chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle,\n            this._resolverStyle, this._resolverFields, chrono, this._zone);\n    }\n\n    /**\n     * not yet supported\n     * @returns {DateTimeFormatter}\n     */\n    withLocale(){\n        return this;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * <p>\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * <p>\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@link ResolverStyle} for more information on the options available.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ResolverStyle} resolverStyle  the new resolver style, not null\n     * @return {DateTimeFormatter} a formatter based on this formatter with the requested resolver style, not null\n     */\n    withResolverStyle(resolverStyle) {\n        requireNonNull(resolverStyle, 'resolverStyle');\n        if (resolverStyle.equals(this._resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     *\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to print, not null\n     * @return {String} the printed string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    format(temporal) {\n        const buf = new StringBuilder(32);\n        this._formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@link Appendable} using this formatter.\n     *\n     * This formats the date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@link StringBuffer}, {@link StringBuilder},\n     * {@link PrintStream} and {@link Writer}.\n     *\n     * Although {@link Appendable} methods throw an {@link IOException}, this method does not.\n     * Instead, any {@link IOException} is wrapped in a runtime exception.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to print, not null\n     * @param {StringBuilder} appendable - the appendable to print to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    _formatTo(temporal, appendable) {\n        requireNonNull(temporal, 'temporal');\n        requireNonNull(appendable, 'appendable');\n        const context = new DateTimePrintContext(temporal, this);\n        this._printerParser.print(context, appendable);\n    }\n\n    /**\n     * function overloading for {@link DateTimeFormatter.parse}\n     *\n     * if called with one arg {@link DateTimeFormatter.parse1} is called\n     * otherwise {@link DateTimeFormatter.parse2}\n     *\n     * @param {string} text\n     * @param {TemporalQuery} type\n     * @return {TemporalAccessor}\n     */\n    parse(text, type){\n        if(arguments.length === 1){\n            return this.parse1(text);\n        } else {\n            return this.parse2(text, type);\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link parse}.\n     * The result of this method is {@link TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param {String} text  the text to parse, not null\n     * @return {TemporalAccessor} the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse1(text) {\n        requireNonNull(text, 'text');\n        try {\n            return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link parse}.\n     * The result of this method is {@link TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param type the type to extract, not null\n * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse2(text, type) {\n        requireNonNull(text, 'text');\n        requireNonNull(type, 'type');\n        try {\n            const builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n            return builder.build(type);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    _createError(text, ex) {\n        let abbr = '';\n        if (text.length > 64) {\n            abbr = text.substring(0, 64) + '...';\n        } else {\n            abbr = text;\n        }\n        return new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed: ' + ex.message, text, 0, ex);\n    }\n\n\n    /**\n     * Parses the text to a builder.\n     *\n     * This parses to a {@link DateTimeBuilder} ensuring that the text is fully parsed.\n     * This method throws {@link DateTimeParseException} if unable to parse, or\n     * some other {@link DateTimeException} if another date/time problem occurs.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the engine representing the result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     */\n    _parseToBuilder(text, position) {\n        const pos = (position != null ? position : new ParsePosition(0));\n        const result = this._parseUnresolved0(text, pos);\n        if (result == null || pos.getErrorIndex() >= 0 || (position == null && pos.getIndex() < text.length)) {\n            let abbr = '';\n            if (text.length > 64) {\n                abbr = text.substr(0, 64).toString() + '...';\n            } else {\n                abbr = text;\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed at index ' +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed, unparsed text found at index ' +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return result.toBuilder();\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     *\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@link Map} of field to value, a {@link ZoneId} and a {@link Chronology}.\n     * Second, the parsed data is *resolved*, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     *\n     * The result of this method is {@link TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of '2012-00-65' would result in a temporal with three fields - year of '2012',\n     * month of '0' and day-of-month of '65'.\n     *\n     * The text will be parsed from the specified start {@link ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@link ParsePosition}\n     * will be updated with the index at the end of parsing.\n     *\n     * Errors are returned using the error index field of the {@link ParsePosition}\n     * instead of {@link DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the context.\n     *\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link parse} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    parseUnresolved(text, position) {\n        return this._parseUnresolved0(text, position);\n    }\n\n    _parseUnresolved0(text, position) {\n        assert(text != null, 'text', NullPointerException);\n        assert(position != null, 'position', NullPointerException);\n        const context = new DateTimeParseContext(this);\n        let pos = position.getIndex();\n        pos = this._printerParser.parse(context, text, pos);\n        if (pos < 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context.toParsed();\n    }\n\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param {boolean} optional  whether the printer/parser should be optional\n     * @return {CompositePrinterParser} the printer/parser, not null\n     */\n    _toPrinterParser(optional) {\n        return this._printerParser.withOptional(optional);\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        const pattern = this._printerParser.toString();\n        return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n    }\n\n}\n\nexport function _init() {\n\n    DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.HOUR_OF_DAY, 2)\n        .appendLiteral(':')\n        .appendValue(ChronoField.MINUTE_OF_HOUR, 2)\n        .optionalStart()\n        .appendLiteral(':')\n        .appendValue(ChronoField.SECOND_OF_MINUTE, 2)\n        .optionalStart()\n        .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE)\n        .appendLiteral('T')\n        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .appendInstant()\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n        .appendOffsetId()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder()\n        .append(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n        .optionalStart()\n        .appendLiteral('[')\n        .parseCaseSensitive()\n        .appendZoneId()\n        // .appendZoneRegionId()\n        .appendLiteral(']')\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    });\n\n    DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.leapSecond;\n        } else {\n            return false;\n        }\n    });\n\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from '../assert';\n\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {DateTimeFormatter} from '../format/DateTimeFormatter';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\nimport {Temporal} from '../temporal/Temporal';\n\nimport {LocalDate} from '../LocalDate';\n\n/**\n * A date without time-of-day or time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n *\n * **Most applications should declare method signatures, fields and variables\n * as {@link LocalDate}, not this interface.**\n *\n * A {@link ChronoLocalDate} is the abstract representation of a date where the\n * {@link Chronology}, or calendar system, is pluggable.\n * The date is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * #### When to use this interface\n *\n * The design of the API encourages the use of {@link LocalDate} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in the following documentation.\n *\n * The primary use case where this interface should be used is where the generic\n * type parameter `C` is fully defined as a specific chronology.\n * In that case, the assumptions of that chronology are known at development\n * time and specified in the code.\n *\n * When the chronology is defined in the generic type parameter as ? or otherwise\n * unknown at development time, the rest of the discussion below applies.\n *\n * To emphasize the point, declaring a method signature, field or variable as this\n * interface type can initially seem like the sensible way to globalize an application,\n * however it is usually the wrong approach.\n * As such, it should be considered an application-wide architectural decision to choose\n * to use this interface as opposed to {@link LocalDate}.\n *\n * #### Architectural issues to consider\n *\n * These are some of the points that must be considered before using this interface\n * throughout an application.\n *\n * 1) Applications using this interface, as opposed to using just {@link LocalDate},\n * face a significantly higher probability of bugs. This is because the calendar system\n * in use is not known at development time. A key cause of bugs is where the developer\n * applies assumptions from their day-to-day knowledge of the ISO calendar system\n * to code that is intended to deal with any arbitrary calendar system.\n * The section below outlines how those assumptions can cause problems\n * The primary mechanism for reducing this increased risk of bugs is a strong code review process.\n * This should also be considered a extra cost in maintenance for the lifetime of the code.\n *\n * 2) This interface does not enforce immutability of implementations.\n * While the implementation notes indicate that all implementations must be immutable\n * there is nothing in the code or type system to enforce this. Any method declared\n * to accept a {@link ChronoLocalDate} could therefore be passed a poorly or\n * maliciously written mutable implementation.\n *\n * 3) Applications using this interface  must consider the impact of eras.\n * {@link LocalDate} shields users from the concept of eras, by ensuring that `getYear()`\n * returns the proleptic year. That decision ensures that developers can think of\n * {@link LocalDate} instances as consisting of three fields - year, month-of-year and day-of-month.\n * By contrast, users of this interface must think of dates as consisting of four fields -\n * era, year-of-era, month-of-year and day-of-month. The extra era field is frequently\n * forgotten, yet it is of vital importance to dates in an arbitrary calendar system.\n * For example, in the Japanese calendar system, the era represents the reign of an Emperor.\n * Whenever one reign ends and another starts, the year-of-era is reset to one.\n *\n * 4) The only agreed international standard for passing a date between two systems\n * is the ISO-8601 standard which requires the ISO calendar system. Using this interface\n * throughout the application will inevitably lead to the requirement to pass the date\n * across a network or component boundary, requiring an application specific protocol or format.\n *\n * 5) Long term persistence, such as a database, will almost always only accept dates in the\n * ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\n * calendar systems increases the complications of interacting with persistence.\n *\n * 6) Most of the time, passing a {@link ChronoLocalDate} throughout an application\n * is unnecessary, as discussed in the last section below.\n *\n * #### False assumptions causing bugs in multi-calendar system code\n *\n * As indicated above, there are many issues to consider when try to use and manipulate a\n * date in an arbitrary calendar system. These are some of the key issues.\n *\n * Code that queries the day-of-month and assumes that the value will never be more than\n * 31 is invalid. Some calendar systems have more than 31 days in some months.\n *\n * Code that adds 12 months to a date and assumes that a year has been added is invalid.\n * Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.\n *\n * Code that adds one month to a date and assumes that the month-of-year value will increase\n * by one or wrap to the next year is invalid. Some calendar systems have a variable number\n * of months in a year, such as the Hebrew.\n *\n * Code that adds one month, then adds a second one month and assumes that the day-of-month\n * will remain close to its original value is invalid. Some calendar systems have a large difference\n * between the length of the longest month and the length of the shortest month.\n * For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.\n *\n * Code that adds seven days and assumes that a week has been added is invalid.\n * Some calendar systems have weeks of other than seven days, such as the French Revolutionary.\n *\n * Code that assumes that because the year of `date1` is greater than the year of `date2`\n * then `date1` is after `date2` is invalid. This is invalid for all calendar systems\n * when referring to the year-of-era, and especially untrue of the Japanese calendar system\n * where the year-of-era restarts with the reign of every new Emperor.\n *\n * Code that treats month-of-year one and day-of-month one as the start of the year is invalid.\n * Not all calendar systems start the year when the month value is one.\n *\n * In general, manipulating a date, and even querying a date, is wide open to bugs when the\n * calendar system is unknown at development time. This is why it is essential that code using\n * this interface is subjected to additional code reviews. It is also why an architectural\n * decision to avoid this interface type is usually the correct one.\n *\n * #### Using LocalDate instead\n *\n * The primary alternative to using this interface throughout your application is as follows.\n *\n * * Declare all method signatures referring to dates in terms of {@link LocalDate}.\n * * Either store the chronology (calendar system) in the user profile or lookup the chronology\n *   from the user locale.\n * * Convert the ISO {@link LocalDate} to and from the user's preferred calendar system during\n *   printing and parsing.\n *\n * This approach treats the problem of globalized calendar systems as a localization issue\n * and confines it to the UI layer. This approach is in keeping with other localization\n * issues in the java platform.\n *\n * As discussed above, performing calculations on a date where the rules of the calendar system\n * are pluggable requires skill and is not recommended.\n * Fortunately, the need to perform calculations on a date in an arbitrary calendar system\n * is extremely rare. For example, it is highly unlikely that the business rules of a library\n * book rental scheme will allow rentals to be for one month, where meaning of the month\n * is dependent on the user's preferred calendar system.\n *\n * A key use case for calculations on a date in an arbitrary calendar system is producing\n * a month-by-month calendar for display and user interaction. Again, this is a UI issue,\n * and use of this interface solely within a few methods of the UI layer may be justified.\n *\n * In any other part of the system, where a date must be manipulated in a calendar system\n * other than ISO, the use case will generally specify the calendar system to use.\n * For example, an application may need to calculate the next Islamic or Hebrew holiday\n * which may require manipulating the date.\n * This kind of use case can be handled as follows:\n *\n * * start from the ISO {@link LocalDate} being passed to the method\n * * convert the date to the alternate calendar system, which for this use case is known\n *   rather than arbitrary\n * * perform the calculation\n * * convert back to {@link LocalDate}\n *\n * Developers writing low-level frameworks or libraries should also avoid this interface.\n * Instead, one of the two general purpose access interfaces should be used.\n * Use {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}\n * if read-write access is required.\n *\n * ### Specification for implementors\n *\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n *\n * Additional calendar systems may be added to the system.\n * See {@link Chronology} for more details.\n *\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n */\nexport class ChronoLocalDate extends Temporal {\n\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toEpochDay());\n        } else if (query === TemporalQueries.localTime() || query === TemporalQueries.zone() ||\n                query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n    }\n    /**\n     * Formats this date using the specified formatter.\n     *\n     * This date will be passed to the formatter to produce a string.\n     *\n     * The default implementation must behave as follows:\n     * <pre>\n     *  return formatter.format(this);\n     * </pre>\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {UnsupportedTemporalTypeException, IllegalStateException} from '../errors';\n\nimport {DayOfWeek} from '../DayOfWeek';\nimport {Duration} from '../Duration';\nimport {MathUtil} from '../MathUtil';\nimport {LocalDate} from '../LocalDate';\n\nimport {ChronoField} from './ChronoField';\nimport {ChronoUnit} from './ChronoUnit';\nimport {TemporalField} from './TemporalField';\nimport {TemporalUnit} from './TemporalUnit';\nimport {ValueRange} from './ValueRange';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\n\nimport {ResolverStyle} from '../format/ResolverStyle';\n\n/**\n * Fields and units specific to the ISO-8601 calendar system,\n * including quarter-of-year and week-based-year.\n *\n * This class defines fields and units that are specific to the ISO calendar system.\n *\n * ### Quarter of year\n *\n * The ISO-8601 standard is based on the standard civic 12 month year.\n * This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.\n *\n * January, February and March are in Q1.\n * April, May and June are in Q2.\n * July, August and September are in Q3.\n * October, November and December are in Q4.\n *\n * The complete date is expressed using three fields:\n *\n * * {@link DAY_OF_QUARTER} - the day within the quarter, from 1 to 90, 91 or 92\n * * {@link QUARTER_OF_YEAR} - the week within the week-based-year\n * * {@link ChronoField#YEAR} - the standard ISO year\n *\n * ### Week based years\n *\n * The ISO-8601 standard was originally intended as a data interchange format,\n * defining a string format for dates and times. However, it also defines an\n * alternate way of expressing the date, based on the concept of week-based-year.\n *\n * The date is expressed using three fields:\n *\n * * {@link ChronoField#DAY_OF_WEEK} - the standard field defining the\n *   day-of-week from Monday (1) to Sunday (7)\n * * {@link WEEK_OF_WEEK_BASED_YEAR} - the week within the week-based-year\n * * {@link WEEK_BASED_YEAR} - the week-based-year\n *\n * The week-based-year itself is defined relative to the standard ISO proleptic year.\n * It differs from the standard year in that it always starts on a Monday.\n *\n * The first week of a week-based-year is the first Monday-based week of the standard\n * ISO year that has at least 4 days in the new year.\n *\n * * If January 1st is Monday then week 1 starts on January 1st\n * * If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year\n * * If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year\n * * If January 1st is Thursday then week 1 starts on December 29th of the previous standard year\n * * If January 1st is Friday then week 1 starts on January 4th\n * * If January 1st is Saturday then week 1 starts on January 3rd\n * * If January 1st is Sunday then week 1 starts on January 2nd\n *\n * There are 52 weeks in most week-based years, however on occasion there are 53 weeks.\n *\n * For example:\n *\n * * Sunday, 2008-12-28: Week 52 of week-based-year 2008\n * * Monday, 2008-12-29: Week 1 of week-based-year 2009\n * * Wednesday, 2008-12-31: Week 1 of week-based-year 2009\n * * Thursday, 2009-01-01: Week 1 of week-based-year 2009\n * * Sunday, 2009-01-04: Week 1 of week-based-year 2009\n * * Monday, 2009-01-05: Week 2 of week-based-year 2009\n *\n * ### Static properties of Class {@link IsoFields}\n *\n * IsoFields.DAY_OF_QUARTER\n *\n * The field that represents the day-of-quarter.\n *\n * This field allows the day-of-quarter value to be queried and set.\n * The day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91\n * in Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.\n *\n * The day-of-quarter can only be calculated if the day-of-year, month-of-year and year\n * are available.\n *\n * When setting this field, the value is allowed to be partially lenient, taking any\n * value from 1 to 92. If the quarter has less than 92 days, then day 92, and\n * potentially day 91, is in the following quarter.\n *\n * IsoFields.QUARTER_OF_YEAR\n *\n * The field that represents the quarter-of-year.\n *\n * This field allows the quarter-of-year value to be queried and set.\n * The quarter-of-year has values from 1 to 4.\n *\n * The day-of-quarter can only be calculated if the month-of-year is available.\n *\n * IsoFields.WEEK_OF_WEEK_BASED_YEAR\n *\n * The field that represents the week-of-week-based-year.\n *\n * This field allows the week of the week-based-year value to be queried and set.\n *\n * IsoFields.WEEK_BASED_YEAR\n *\n * The field that represents the week-based-year.\n *\n * This field allows the week-based-year value to be queried and set.\n *\n * IsoFields.WEEK_BASED_YEARS\n *\n * The unit that represents week-based-years for the purpose of addition and subtraction.\n *\n * This allows a number of week-based-years to be added to, or subtracted from, a date.\n * The unit is equal to either 52 or 53 weeks.\n * The estimated duration of a week-based-year is the same as that of a standard ISO\n * year at 365.2425 days.\n *\n * The rules for addition add the number of week-based-years to the existing value\n * for the week-based-year field. If the resulting week-based-year only has 52 weeks,\n * then the date will be in week 1 of the following week-based-year.\n *\n * IsoFields.QUARTER_YEARS\n *\n * Unit that represents the concept of a quarter-year.\n * For the ISO calendar system, it is equal to 3 months.\n * The estimated duration of a quarter-year is one quarter of 365.2425 days.\n */\nexport class IsoFields {\n}\n\n//-----------------------------------------------------------------------\n\nconst QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\n\n/**\n * Implementation of the field.\n */\nclass Field extends TemporalField{\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    _isIso() {\n        return true;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {ValueRange}\n     */\n    static _getWeekRangeByLocalDate(date) {\n        const wby = Field._getWeekBasedYear(date);\n        return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n    }\n\n    /**\n     *\n     * @param {number} wby\n     * @returns {number}\n     */\n    static _getWeekRangeByYear(wby) {\n        const date = LocalDate.of(wby, 1, 1);\n        // 53 weeks if standard year starts on Thursday, or Wed in a leap year\n        if (date.dayOfWeek() === DayOfWeek.THURSDAY || (date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear())) {\n            return 53;\n        }\n        return 52;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeek(date) {\n        const dow0 = date.dayOfWeek().ordinal();\n        const doy0 = date.dayOfYear() - 1;\n        const doyThu0 = doy0 + (3 - dow0);  // adjust to mid-week Thursday (which is 3 indexed from zero)\n        const alignedWeek = MathUtil.intDiv(doyThu0, 7);\n        const firstThuDoy0 = doyThu0 - (alignedWeek * 7);\n        let firstMonDoy0 = firstThuDoy0 - 3;\n        if (firstMonDoy0 < -3) {\n            firstMonDoy0 += 7;\n        }\n        if (doy0 < firstMonDoy0) {\n            return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n        }\n        let week = MathUtil.intDiv((doy0 - firstMonDoy0), 7) + 1;\n        if (week === 53) {\n            if ((firstMonDoy0 === -3 || (firstMonDoy0 === -2 && date.isLeapYear())) === false) {\n                week = 1;\n            }\n        }\n        return week;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeekBasedYear(date) {\n        let year = date.year();\n        let doy = date.dayOfYear();\n        if (doy <= 3) {\n            const dow = date.dayOfWeek().ordinal();\n            if (doy - dow < -2) {\n                year--;\n            }\n        } else if (doy >= 363) {\n            const dow = date.dayOfWeek().ordinal();\n            doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n            if (doy - dow >= 0) {\n                year++;\n            }\n        }\n        return year;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    getDisplayName(/*locale*/) {\n        return this.toString();\n    }\n\n    /**\n     *\n     * @returns {null}\n     */\n    resolve() {\n        return null;\n    }\n\n    name(){\n        return this.toString();\n    }\n\n}\n\n\nclass DAY_OF_QUARTER_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'DayOfQuarter';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.DAYS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 90, 92);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) &&\n            temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        const qoy = temporal.getLong(QUARTER_OF_YEAR);\n        if (qoy === 1) {\n            const year = temporal.getLong(ChronoField.YEAR);\n            return (IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90));\n        } else if (qoy === 2) {\n            return ValueRange.of(1, 91);\n        } else if (qoy === 3 || qoy === 4) {\n            return ValueRange.of(1, 92);\n        } // else value not from 1 to 4, so drop through\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        const doy = temporal.get(ChronoField.DAY_OF_YEAR);\n        const moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n        const year = temporal.getLong(ChronoField.YEAR);\n        return doy - QUARTER_DAYS[MathUtil.intDiv((moy - 1), 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        const curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const yearLong = fieldValues.get(ChronoField.YEAR);\n        const qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n        if (yearLong == null || qoyLong == null) {\n            return null;\n        }\n        const y = ChronoField.YEAR.checkValidIntValue(yearLong);\n        const doq = fieldValues.get(DAY_OF_QUARTER);\n        let date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            const qoy = qoyLong;\n            date = LocalDate.of(y, 1, 1);\n            date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n            date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n        } else {\n            const qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                let max = 92;\n                if (qoy === 1) {\n                    max = (IsoChronology.isLeapYear(y) ? 91 : 90);\n                } else if (qoy === 2) {\n                    max = 91;\n                }\n                ValueRange.of(1, max).checkValidValue(doq, this);\n            } else {\n                this.range().checkValidValue(doq, this);  // leniently check from 1 to 92\n            }\n            date = LocalDate.of(y, ((qoy - 1) * 3) + 1, 1).plusDays(doq - 1);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(ChronoField.YEAR);\n        fieldValues.remove(QUARTER_OF_YEAR);\n        return date;\n    }\n}\n\nclass QUARTER_OF_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'QuarterOfYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 4);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    //eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n        }\n        const moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n        return MathUtil.intDiv((moy + 2), 3);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        const curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n    }\n\n}\n\nclass WEEK_OF_WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekOfWeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.WEEKS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 52, 53);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeek(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        this.range().checkValidValue(newValue, this);\n        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n        const dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n        if (wbyLong == null || dowLong == null) {\n            return null;\n        }\n        const wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n        const wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n        let date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            let dow = dowLong;\n            let weeks = 0;\n            if (dow > 7) {\n                weeks = MathUtil.intDiv((dow - 1), 7);\n                dow = (MathUtil.intMod((dow - 1), 7) + 1);\n            } else if (dow < 1) {\n                weeks = MathUtil.intDiv(dow, 7) - 1;\n                dow = MathUtil.intMod(dow, 7) + 7;\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n        } else {\n            const dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                const temp = LocalDate.of(wby, 1, 4);\n                const range = Field._getWeekRangeByLocalDate(temp);\n                range.checkValidValue(wowby, this);\n            } else {\n                this.range().checkValidValue(wowby, this);  // leniently check from 1 to 53\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, dow);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(WEEK_BASED_YEAR);\n        fieldValues.remove(ChronoField.DAY_OF_WEEK);\n        return date;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    getDisplayName() {\n        return 'Week';\n    }\n\n}\n\nclass WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.FOREVER;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    //eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        return Field._getWeekBasedYear(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        if (this.isSupportedBy(temporal) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        const newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);  // strict check\n        const date = LocalDate.from(temporal);\n        const dow = date.get(ChronoField.DAY_OF_WEEK);\n        let week = Field._getWeek(date);\n        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n            week = 52;\n        }\n        let resolved = LocalDate.of(newWby, 1, 4);  // 4th is guaranteed to be in week one\n        const days = (dow - resolved.get(ChronoField.DAY_OF_WEEK)) + ((week - 1) * 7);\n        resolved = resolved.plusDays(days);\n        return temporal.with(resolved);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Implementation of the period unit.\n */\nclass Unit extends TemporalUnit {\n\n    /**\n     *\n     * @param {string} name\n     * @param {Duration} estimatedDuration\n     * @private\n     */\n    constructor(name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    /**\n     *\n     * @returns {Duration}\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDurationEstimated() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} periodToAdd\n     * @returns {number}\n     */\n    addTo(temporal, periodToAdd) {\n        switch(this) {\n            case WEEK_BASED_YEARS: {\n                const added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n                return temporal.with(WEEK_BASED_YEAR, added);\n            }\n            case QUARTER_YEARS:\n                // no overflow (256 is multiple of 4)\n                return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal1\n     * @param {Temporal} temporal2\n     * @returns {number}\n     */\n    between(temporal1, temporal2) {\n        switch(this) {\n            case WEEK_BASED_YEARS:\n                return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n            case QUARTER_YEARS:\n                return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    toString() {\n        return name;\n    }\n}\n\nlet DAY_OF_QUARTER = null;\nlet QUARTER_OF_YEAR = null;\nlet WEEK_OF_WEEK_BASED_YEAR = null;\nlet WEEK_BASED_YEAR = null;\nlet WEEK_BASED_YEARS = null;\nlet QUARTER_YEARS = null;\n\nexport function _init() {\n    DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n    QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n    WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n    WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n\n    WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n    QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n\n    IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n    IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n    IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n    IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n\n    // this differs from threeten, but for ease of use we bring back good old joda time functionality\n    /**\n     * the week of the week based year as defined by the ISO8601 Standard with a Monday-based week\n     *\n     * @returns {number} the week a the week based year\n     */\n    LocalDate.prototype.isoWeekOfWeekyear = function () {\n        return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n    };\n    /**\n     * the year of the week based year as defined by the ISO8601 Standard with a Monday-based week\n     *\n     * @returns {number} the year a the week based year\n     */\n    LocalDate.prototype.isoWeekyear = function () {\n        return this.get(IsoFields.WEEK_BASED_YEAR);\n    };\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class DecimalStyle {\n    /**\n     *\n     * @param zeroChar\n     * @param positiveSignChar\n     * @param negativeSignChar\n     * @param decimalPointChar\n     * @private\n     */\n    constructor(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n        this._zeroDigit = zeroChar;\n        this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n        this._positiveSign = positiveSignChar;\n        this._negativeSign = negativeSignChar;\n        this._decimalSeparator = decimalPointChar;\n    }\n\n    positiveSign(){\n        return this._positiveSign;\n    }\n\n    withPositiveSign(positiveSign) {\n        if (positiveSign === this._positiveSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    negativeSign(){\n        return this._negativeSign;\n    }\n\n    withNegativeSign(negativeSign) {\n        if (negativeSign === this._negativeSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n    }\n\n    zeroDigit(){\n        return this._zeroDigit;\n    }\n\n    withZeroDigit(zeroDigit) {\n        if (zeroDigit === this._zeroDigit) {\n            return this;\n        }\n        return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    decimalSeparator(){\n        return this._decimalSeparator;\n    }\n\n    withDecimalSeparator(decimalSeparator) {\n        if (decimalSeparator === this._decimalSeparator) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n    }\n\n    convertToDigit(char){\n        const val = char.charCodeAt(0) - this._zeroDigitCharCode;\n        return (val >= 0 && val <= 9) ? val : -1;\n    }\n\n    convertNumberToI18N(numericText) {\n        if (this._zeroDigit === '0') {\n            return numericText;\n        }\n        const diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n        let convertedText = '';\n        for (let i = 0; i < numericText.length; i++) {\n            convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n        }\n        return convertedText;\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof DecimalStyle) {\n            return (this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign &&\n                this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator);\n        }\n        return false;\n    }\n\n    hashCode() {\n        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n    }\n\n    toString() {\n        return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';\n    }\n\n    static of(){\n        throw new Error('not yet supported');\n    }\n    static availableLocales(){\n        throw new Error('not yet supported');\n    }\n\n}\n\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\n/**\n * Enumeration of the style of text formatting and parsing.\n *\n * Text styles define three sizes for the formatted text - 'full', 'short' and 'narrow'.\n * Each of these three sizes is available in both 'standard' and 'stand-alone' variations.\n *\n * The difference between the three sizes is obvious in most languages.\n * For example, in English the 'full' month is 'January', the 'short' month is 'Jan'\n * and the 'narrow' month is 'J'. Note that the narrow size is often not unique.\n * For example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.\n *\n * The difference between the 'standard' and 'stand-alone' forms is trickier to describe\n * as there is no difference in English. However, in other languages there is a difference\n * in the word used when the text is used alone, as opposed to in a complete date.\n * For example, the word used for a month when used alone in a date picker is different\n * to the word used for month in association with a day and year in a date.\n *\n * ### Specification for implementors\n *\n * This is immutable and thread-safe enum.\n */\nexport class TextStyle extends Enum {\n    /**\n     * Checks if the style is stand-alone.\n     *\n     * @return {boolean} true if the style is stand-alone\n     */\n    isStandalone() {\n        switch (this) {\n            case TextStyle.FULL_STANDALONE:\n            case TextStyle.SHORT_STANDALONE:\n            case TextStyle.NARROW_STANDALONE:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Converts the style to the equivalent stand-alone style.\n     *\n     * @return {TextStyle} the matching stand-alone style\n     */\n    asStandalone() {\n        switch (this) {\n            case TextStyle.FULL:\n                return TextStyle.FULL_STANDALONE;\n            case TextStyle.SHORT:\n                return TextStyle.SHORT_STANDALONE;\n            case TextStyle.NARROW:\n                return TextStyle.NARROW_STANDALONE;\n            default:\n                // all others are already standalone\n                return this;\n        }\n    }\n\n    /**\n     * Converts the style to the equivalent normal style.\n     *\n     * @return {TextStyle} the matching normal style\n     */\n    asNormal() {\n        switch (this) {\n            case TextStyle.FULL_STANDALONE:\n                return TextStyle.FULL;\n            case TextStyle.SHORT_STANDALONE:\n                return TextStyle.SHORT;\n            case TextStyle.NARROW_STANDALONE:\n                return TextStyle.NARROW;\n            default:\n                // all others are already normal\n                return this;\n        }\n    }\n}\n\n/**\n * Full text, typically the full description.\n * For example, day-of-week Monday might output \"Monday\".\n */\nTextStyle.FULL = new TextStyle('FULL');\n/**\n * Full text for stand-alone use, typically the full description.\n * For example, day-of-week Monday might output \"Monday\".\n */\nTextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');\n/**\n * Short text, typically an abbreviation.\n * For example, day-of-week Monday might output \"Mon\".\n */\nTextStyle.SHORT = new TextStyle('SHORT');\n/**\n * Short text for stand-alone use, typically an abbreviation.\n * For example, day-of-week Monday might output \"Mon\".\n */\nTextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');\n/**\n * Narrow text, typically a single letter.\n * For example, day-of-week Monday might output \"M\".\n */\nTextStyle.NARROW = new TextStyle('NARROW');\n/**\n * Narrow text for stand-alone use, typically a single letter.\n * For example, day-of-week Monday might output \"M\".\n */\nTextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {IllegalArgumentException} from '../../errors';\n\n/**\n * Prints or parses a char literal.\n * @private\n */\nexport class CharLiteralPrinterParser {\n\n    constructor(literal) {\n        if (literal.length > 1) {\n            throw new IllegalArgumentException('invalid literal, too long: \"' + literal + '\"');\n        }\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        const length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        const ch = text.charAt(position);\n        if (context.charEquals(this._literal, ch) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        if (this._literal === '\\'') {\n            return \"''\";\n        }\n        return \"'\" + this._literal + \"'\";\n    }\n}\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class CompositePrinterParser {\n\n    constructor(printerParsers, optional) {\n        this._printerParsers = printerParsers;\n        this._optional = optional;\n    }\n\n    /**\n     * Returns a copy of this printer-parser with the optional flag changed.\n     *\n     * @param {boolean} optional  the optional flag to set in the copy\n     * @return {CompositePrinterParser} the new printer-parser, not null\n     */\n    withOptional(optional) {\n        if (optional === this._optional) {\n            return this;\n        }\n        return new CompositePrinterParser(this._printerParsers, optional);\n    }\n\n    print(context, buf) {\n        const length = buf.length();\n        if (this._optional) {\n            context.startOptional();\n        }\n        try {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                if (pp.print(context, buf) === false) {\n                    buf.setLength(length);  // reset buffer\n                    return true;\n                }\n            }\n        } finally {\n            if (this._optional) {\n                context.endOptional();\n            }\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        if (this._optional) {\n            context.startOptional();\n            let pos = position;\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                pos = pp.parse(context, text, pos);\n                if (pos < 0) {\n                    context.endOptional(false);\n                    return position;  // return original position\n                }\n            }\n            context.endOptional(true);\n            return pos;\n        } else {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                position = pp.parse(context, text, position);\n                if (position < 0) {\n                    break;\n                }\n            }\n            return position;\n        }\n    }\n\n    toString() {\n        let buf = '';\n        if (this._printerParsers != null) {\n            buf += this._optional ? '[' : '(';\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                buf += pp.toString();\n            }\n            buf += this._optional ? ']' : ')';\n        }\n        return buf;\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../../assert';\nimport {IllegalArgumentException} from '../../errors';\nimport {MathUtil} from '../../MathUtil';\n\n/**\n * TODO optimize FractionPrinterParser, fix documentation\n *\n * Prints and parses a numeric date-time field with optional padding.\n * @private\n */\nexport class FractionPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to output, not null\n     * @param {Number} minWidth  the minimum width to output, from 0 to 9\n     * @param {Number} maxWidth  the maximum width to output, from 0 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     */\n    constructor(field, minWidth, maxWidth, decimalPoint) {\n        requireNonNull(field, 'field');\n        if (field.range().isFixed() === false) {\n            throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);\n        }\n        if (minWidth < 0 || minWidth > 9) {\n            throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);\n        }\n        if (maxWidth < 1 || maxWidth > 9) {\n            throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' +\n                maxWidth + ' < ' + minWidth);\n        }\n        this.field = field;\n        this.minWidth = minWidth;\n        this.maxWidth = maxWidth;\n        this.decimalPoint = decimalPoint;\n    }\n\n    print(context, buf) {\n        const value = context.getValue(this.field);\n        if (value === null) {\n            return false;\n        }\n        const symbols = context.symbols();\n        if (value === 0) {  // scale is zero if value is zero\n            if (this.minWidth > 0) {\n                if (this.decimalPoint) {\n                    buf.append(symbols.decimalSeparator());\n                }\n                for (let i = 0; i < this.minWidth; i++) {\n                    buf.append(symbols.zeroDigit());\n                }\n            }\n        } else {\n            let fraction = this.convertToFraction(value, symbols.zeroDigit());\n            const outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n            fraction = fraction.substr(0, outputScale);\n            if(fraction * 1 > 0 ) {\n                while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n                    fraction = fraction.substr(0, fraction.length - 1);\n                }\n            }\n            let str = fraction;\n            str = symbols.convertNumberToI18N(str);\n            if (this.decimalPoint) {\n                buf.append(symbols.decimalSeparator());\n            }\n            buf.append(str);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        const effectiveMin = (context.isStrict() ? this.minWidth : 0);\n        const effectiveMax = (context.isStrict() ? this.maxWidth : 9);\n        const length = text.length;\n        if (position === length) {\n            // valid if whole field is optional, invalid if minimum width\n            return (effectiveMin > 0 ? ~position : position);\n        }\n        if (this.decimalPoint) {\n            if (text[position] !== context.symbols().decimalSeparator()) {\n                // valid if whole field is optional, invalid if minimum width\n                return (effectiveMin > 0 ? ~position : position);\n            }\n            position++;\n        }\n        const minEndPos = position + effectiveMin;\n        if (minEndPos > length) {\n            return ~position;  // need at least min width digits\n        }\n        const maxEndPos = Math.min(position + effectiveMax, length);\n        let total = 0;  // can use int because we are only parsing up to 9 digits\n        let pos = position;\n        while (pos < maxEndPos) {\n            const ch = text.charAt(pos++);\n            const digit = context.symbols().convertToDigit(ch);\n            if (digit < 0) {\n                if (pos < minEndPos) {\n                    return ~position;  // need at least min width digits\n                }\n                pos--;\n                break;\n            }\n            total = total * 10 + digit;\n        }\n        const moveLeft = pos - position;\n        const scale = Math.pow(10, moveLeft);\n        const value = this.convertFromFraction(total, scale);\n        return context.setParsedField(this.field, value, position, pos);\n    }\n\n    /**\n     *\n     * @param {Number} value  the value to convert, must be valid for this rule\n     * @param {String} zeroDigit  the character for zero\n     * @return {String} the value as a fraction within the range, from 0 to 1, not null\n     */\n    convertToFraction(value, zeroDigit) {\n        const range = this.field.range();\n        range.checkValidValue(value, this.field);\n        const _min = range.minimum();\n        const _range = range.maximum() - _min + 1;\n        const _value = value - _min;\n        const _scaled = MathUtil.intDiv((_value * 1000000000),  _range);\n        let fraction = '' + _scaled;\n        while(fraction.length < 9){\n            fraction = zeroDigit + fraction;\n        }\n        return fraction;\n    }\n\n    /**\n     *\n     * @param {Number} total  the fraction to convert, not null\n     * @param {Number} scale  the scale, not null\n     * @return {Number} the value of the field, valid for this rule\n     * @throws DateTimeException if the value cannot be converted\n     */\n    convertFromFraction(total, scale) {\n        const range = this.field.range();\n        const _min = range.minimum();\n        const _range = range.maximum() - _min + 1;\n        const _value = MathUtil.intDiv((total * _range), scale);\n        return _value;\n    }\n\n    toString() {\n        const decimal = (this.decimalPoint ? ',DecimalPoint' : '');\n        return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';\n    }\n}\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from '../../assert';\nimport {ArithmeticException, DateTimeException, IllegalArgumentException} from '../../errors';\nimport {MathUtil} from '../../MathUtil';\n\nimport {IsoChronology} from '../../chrono/IsoChronology';\n\nimport {SignStyle} from '../SignStyle';\n\n\nconst MAX_WIDTH = 15; // can't parse all numbers with more then 15 digits in javascript\n\nconst EXCEED_POINTS = [\n    0,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000\n];\n\n/**\n * @private\n */\nexport class NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param field  the field to print, not null\n     * @param minWidth  the minimum field width, from 1 to 19\n     * @param maxWidth  the maximum field width, from minWidth to 19\n     * @param signStyle  the positive/negative sign style, not null\n     * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,\n     *  -1 if fixed width due to active adjacent parsing\n     */\n    constructor(field, minWidth, maxWidth, signStyle, subsequentWidth=0){\n        this._field = field;\n        this._minWidth = minWidth;\n        this._maxWidth = maxWidth;\n        this._signStyle = signStyle;\n        this._subsequentWidth = subsequentWidth;\n    }\n\n    field(){ return this._field;}\n    minWidth(){ return this._minWidth;}\n    maxWidth(){ return this._maxWidth;}\n    signStyle(){ return this._signStyle;}\n\n    withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n    }\n\n    withSubsequentWidth(subsequentWidth) {\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n    }\n\n    _isFixedWidth() {\n        return this._subsequentWidth === -1 ||\n            (this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE);\n    }\n\n    print(context, buf) {\n        const contextValue = context.getValue(this._field);\n        if (contextValue == null) {\n            return false;\n        }\n        const value = this._getValue(context, contextValue);\n        const symbols = context.symbols();\n        let str = '' + Math.abs(value);\n        if (str.length > this._maxWidth) {\n            throw new DateTimeException('Field ' + this._field +\n                ' cannot be printed as the value ' + value +\n                ' exceeds the maximum print width of ' + this._maxWidth);\n        }\n        str = symbols.convertNumberToI18N(str);\n\n        if (value >= 0) {\n            switch (this._signStyle) {\n                case SignStyle.EXCEEDS_PAD:\n                    if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n                        buf.append(symbols.positiveSign());\n                    }\n                    break;\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.positiveSign());\n                    break;\n            }\n        } else {\n            switch (this._signStyle) {\n                case SignStyle.NORMAL:\n                case SignStyle.EXCEEDS_PAD:\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.negativeSign());\n                    break;\n                case SignStyle.NOT_NEGATIVE:\n                    throw new DateTimeException('Field ' + this._field +\n                        ' cannot be printed as the value ' + value +\n                        ' cannot be negative according to the SignStyle');\n            }\n        }\n        for (let i = 0; i < this._minWidth - str.length; i++) {\n            buf.append(symbols.zeroDigit());\n        }\n        buf.append(str);\n        return true;\n    }\n\n    parse(context, text, position){\n        const length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        assert(position>=0 && position<length);\n        const sign = text.charAt(position);  // IOOBE if invalid position\n        let negative = false;\n        let positive = false;\n        if (sign === context.symbols().positiveSign()) {\n            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            positive = true;\n            position++;\n        } else if (sign === context.symbols().negativeSign()) {\n            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            negative = true;\n            position++;\n        } else {\n            if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n                return ~position;\n            }\n        }\n        const effMinWidth = (context.isStrict() || this._isFixedWidth() ? this._minWidth : 1);\n        const minEndPos = position + effMinWidth;\n        if (minEndPos > length) {\n            return ~position;\n        }\n        let effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n        let total = 0;\n        let pos = position;\n        for (let pass = 0; pass < 2; pass++) {\n            const maxEndPos = Math.min(pos + effMaxWidth, length);\n            while (pos < maxEndPos) {\n                const ch = text.charAt(pos++);\n                const digit = context.symbols().convertToDigit(ch);\n                if (digit < 0) {\n                    pos--;\n                    if (pos < minEndPos) {\n                        return ~position;  // need at least min width digits\n                    }\n                    break;\n                }\n                if ((pos - position) > MAX_WIDTH) {\n                    throw new ArithmeticException('number text exceeds length');\n                } else {\n                    total = total * 10 + digit;\n                }\n            }\n            if (this._subsequentWidth > 0 && pass === 0) {\n                // re-parse now we know the correct width\n                const parseLen = pos - position;\n                effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n                pos = position;\n                total = 0;\n            } else {\n                break;\n            }\n        }\n        if (negative) {\n            if (total === 0 && context.isStrict()) {\n                return ~(position - 1);  // minus zero not allowed\n            }\n            if(total !== 0) {\n                total = -total;\n            }\n        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n            const parseLen = pos - position;\n            if (positive) {\n                if (parseLen <= this._minWidth) {\n                    return ~(position - 1);  // '+' only parsed if minWidth exceeded\n                }\n            } else {\n                if (parseLen > this._minWidth) {\n                    return ~position;  // '+' must be parsed if minWidth exceeded\n                }\n            }\n        }\n        return this._setValue(context, total, position, pos);\n    }\n\n    /**\n     * Gets the value to output.\n     * (This is needed to allow e.g. ReducedPrinterParser to override this and change the value!\n     *\n     * @param context  the context\n     * @param value  the value of the field, not null\n     * @return the value\n     * @private\n     */\n    _getValue(context, value) {\n        return value;\n    }\n\n    /**\n     * Stores the value.\n     *\n     * @param context  the context to store into, not null\n     * @param value  the value\n     * @param errorPos  the position of the field being parsed\n     * @param successPos  the position after the field being parsed\n     * @return the new position\n     */\n    _setValue(context, value, errorPos, successPos) {\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    toString() {\n        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n            return 'Value(' + this._field + ')';\n        }\n        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n            return 'Value(' + this._field + ',' + this._minWidth + ')';\n        }\n        return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';\n    }\n\n}\n//-----------------------------------------------------------------------\n/**\n * Prints and parses a reduced numeric date-time field.\n * @private\n */\nexport class ReducedPrinterParser extends NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to print, validated not null\n     * @param {number} width  the field width, from 1 to 10\n     * @param {number} maxWidth  the field max width, from 1 to 10\n     * @param {number} baseValue  the base value\n     * @param {ChronoLocalDate} baseDate  the base date\n     */\n    constructor(field, width, maxWidth, baseValue, baseDate) {\n        super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);\n        if (width < 1 || width > 10) {\n            throw new IllegalArgumentException('The width must be from 1 to 10 inclusive but was ' + width);\n        }\n        if (maxWidth < 1 || maxWidth > 10) {\n            throw new IllegalArgumentException('The maxWidth must be from 1 to 10 inclusive but was ' + maxWidth);\n        }\n        if (maxWidth < width) {\n            throw new IllegalArgumentException('The maxWidth must be greater than the width');\n        }\n        if (baseDate === null) {\n            if (field.range().isValidValue(baseValue) === false) {\n                throw new IllegalArgumentException('The base value must be within the range of the field');\n            }\n            if ((baseValue + EXCEED_POINTS[width]) > MathUtil.MAX_SAFE_INTEGER) {\n                throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');\n            }\n        }\n        this._baseValue = baseValue;\n        this._baseDate = baseDate;\n    }\n\n    /**\n     *\n     * @param {DateTimePrintContext} context\n     * @param {number} value\n     */\n    _getValue(context, value) {\n        const absValue = Math.abs(value);\n        let baseValue = this._baseValue;\n        if (this._baseDate !== null) {\n            // TODO: in threetenbp the following line is used, but we dont have Chronology yet,\n            // let chrono = Chronology.from(context.getTemporal());\n            // so let's use IsoChronology for now\n            context.temporal();\n            const chrono = IsoChronology.INSTANCE;\n            baseValue = chrono.date(this._baseDate).get(this._field);\n        }\n        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n            return absValue % EXCEED_POINTS[this._minWidth];\n        }\n        return absValue % EXCEED_POINTS[this._maxWidth];\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {number} value\n     * @param {number} errorPos\n     * @param {number} successPos\n     */\n    _setValue(context, value, errorPos, successPos) {\n        let baseValue = this._baseValue;\n        if (this._baseDate != null) {\n            const chrono = context.getEffectiveChronology();\n            baseValue = chrono.date(this._baseDate).get(this._field);\n            // TODO: not implemented??\n            // context.addChronologyChangedParser(this, value, errorPos, successPos);\n        }\n        const parseLen = successPos - errorPos;\n        if (parseLen === this._minWidth && value >= 0) {\n            const range = EXCEED_POINTS[this._minWidth];\n            const lastPart = baseValue % range;\n            const basePart = baseValue - lastPart;\n            if (baseValue > 0) {\n                value = basePart + value;\n            } else {\n                value = basePart - value;\n            }\n            if (value < baseValue) {\n                value += range;\n            }\n        }\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);\n    }\n\n    /**\n     *\n     * @param {number} subsequentWidth\n     * @returns {ReducedPrinterParser}\n     */\n    withSubsequentWidth(subsequentWidth) {\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate,\n            this._subsequentWidth + subsequentWidth);\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     */\n    isFixedWidth(context) {\n        if (context.isStrict() === false) {\n            return false;\n        }\n        return super.isFixedWidth(context);\n    }\n\n    toString() {\n        return 'ReducedValue(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + (this._baseDate != null ? this._baseDate : this._baseValue) + ')';\n    }\n}\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../../assert';\nimport {IllegalArgumentException} from '../../errors';\nimport {MathUtil} from '../../MathUtil';\n\nimport {ChronoField} from '../../temporal/ChronoField';\n\n//-----------------------------------------------------------------------\nconst PATTERNS = [\n    '+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'\n];\n/**\n * Prints or parses an offset ID.\n * @private\n */\nexport class OffsetIdPrinterParser  {\n\n    /**\n     * Constructor.\n     *\n     * @param {string} noOffsetText  the text to use for UTC, not null\n     * @param {string} pattern  the pattern\n     */\n    constructor(noOffsetText, pattern) {\n        requireNonNull(noOffsetText, 'noOffsetText');\n        requireNonNull(pattern, 'pattern');\n        this.noOffsetText = noOffsetText;\n        this.type = this._checkPattern(pattern);\n    }\n\n    /**\n     * @param {String} pattern\n     * @return {number}\n     */\n    _checkPattern(pattern) {\n        for (let i = 0; i < PATTERNS.length; i++) {\n            if (PATTERNS[i] === pattern) {\n                return i;\n            }\n        }\n        throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);\n    }\n\n    /**\n     * @param {DateTimePrintContext} context\n     * @param {StringBuilder} buf\n     * @return {boolean}\n     */\n    print(context, buf) {\n        const offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n        if (offsetSecs == null) {\n            return false;\n        }\n        const totalSecs = MathUtil.safeToInt(offsetSecs);\n        if (totalSecs === 0) {\n            buf.append(this.noOffsetText);\n        } else {\n            const absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));  // anything larger than 99 silently dropped\n            const absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n            const absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n            const bufPos = buf.length();\n            let output = absHours;\n            buf.append(totalSecs < 0 ? '-' : '+')\n                .appendChar((MathUtil.intDiv(absHours, 10) + '0')).appendChar(MathUtil.intMod(absHours, 10) + '0');\n            if (this.type >= 3 || (this.type >= 1 && absMinutes > 0)) {\n                buf.append((this.type % 2) === 0 ? ':' : '')\n                    .appendChar((MathUtil.intDiv(absMinutes, 10) + '0')).appendChar((absMinutes % 10 + '0'));\n                output += absMinutes;\n                if (this.type >= 7 || (this.type >= 5 && absSeconds > 0)) {\n                    buf.append((this.type % 2) === 0 ? ':' : '')\n                        .appendChar((MathUtil.intDiv(absSeconds, 10) + '0')).appendChar((absSeconds % 10 + '0'));\n                    output += absSeconds;\n                }\n            }\n            if (output === 0) {\n                buf.setLength(bufPos);\n                buf.append(this.noOffsetText);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        const length = text.length;\n        const noOffsetLen = this.noOffsetText.length;\n        if (noOffsetLen === 0) {\n            if (position === length) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n            }\n        } else {\n            if (position === length) {\n                return ~position;\n            }\n            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n            }\n        }\n\n        // parse normal plus/minus offset\n        const sign = text[position];  // IOOBE if invalid position\n        if (sign === '+' || sign === '-') {\n            // starts\n            const negative = (sign === '-' ? -1 : 1);\n            const array = [0,0,0,0];\n            array[0] = position + 1;\n            if ((this._parseNumber(array, 1, text, true) ||\n                this._parseNumber(array, 2, text, this.type >=3) ||\n                this._parseNumber(array, 3, text, false)) === false) {\n                // success\n                const offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n            }\n        }\n        // handle special case of empty no offset text\n        if (noOffsetLen === 0) {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n        }\n        return ~position;\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {number[]} array  the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null\n     * @param {number} arrayIndex  the index to parse the value into\n     * @param {string} parseText  the offset ID, not null\n     * @param {boolean} required  whether this number is required\n     * @return {boolean} true if an error occurred\n     */\n    _parseNumber(array, arrayIndex, parseText, required) {\n        if ((this.type + 3) / 2 < arrayIndex) {\n            return false;  // ignore seconds/minutes\n        }\n        let pos = array[0];\n        if ((this.type % 2) === 0 && arrayIndex > 1) {\n            if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n                return required;\n            }\n            pos++;\n        }\n        if (pos + 2 > parseText.length) {\n            return required;\n        }\n        const ch1 = parseText[pos++];\n        const ch2 = parseText[pos++];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            return required;\n        }\n        const value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n        if (value < 0 || value > 59) {\n            return required;\n        }\n        array[arrayIndex] = value;\n        array[0] = pos;\n        return false;\n    }\n\n\n    toString() {\n        const converted = this.noOffsetText.replace('\\'', '\\'\\'');\n        return 'Offset(' + PATTERNS[this.type] + ',\\'' + converted + '\\')';\n    }\n}\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from '../../assert';\n\nimport {DateTimeException} from '../../errors';\n\n/**\n * Pads the output to a fixed width.\n * @private\n */\nexport class PadPrinterParserDecorator {\n\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer, not null\n     * @param padWidth  the width to pad to, 1 or greater\n     * @param padChar  the pad character\n     */\n    constructor(printerParser, padWidth, padChar) {\n        // input checked by DateTimeFormatterBuilder\n        this._printerParser = printerParser;\n        this._padWidth = padWidth;\n        this._padChar = padChar;\n    }\n\n    print(context, buf) {\n        const preLen = buf.length();\n        if (this._printerParser.print(context, buf) === false) {\n            return false;\n        }\n        const len = buf.length() - preLen;\n        if (len > this._padWidth) {\n            throw new DateTimeException(\n                `Cannot print as output of ${len} characters exceeds pad width of ${this._padWidth}`);\n        }\n        for (let i = 0; i < this._padWidth - len; i++) {\n            buf.insert(preLen, this._padChar);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        // cache context before changed by decorated parser\n        const strict = context.isStrict();\n        const caseSensitive = context.isCaseSensitive();\n        // parse\n        assert(!(position > text.length));\n        assert(position >= 0);\n        if (position === text.length) {\n            return ~position;  // no more characters in the string\n        }\n        let endPos = position + this._padWidth;\n        if (endPos > text.length) {\n            if (strict) {\n                return ~position;  // not enough characters in the string to meet the parse width\n            }\n            endPos = text.length;\n        }\n        let pos = position;\n        while (pos < endPos &&\n        (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n            pos++;\n        }\n        text = text.substring(0, endPos);\n        const resultPos = this._printerParser.parse(context, text, pos);\n        if (resultPos !== endPos && strict) {\n            return ~(position + pos);  // parse of decorated field didn't parse to the end\n        }\n        return resultPos;\n    }\n\n    toString() {\n        return `Pad(${this._printerParser},${this._padWidth}${(this._padChar === ' ' ? ')' : ',\\'' + this._padChar + '\\')')}`;\n    }\n}\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { Enum } from '../../Enum';\n\n/**\n * @private\n */\nexport class SettingsParser extends Enum {\n\n    print(/*context, buf*/) {\n        return true;  // nothing to do here\n    }\n\n    parse(context, text, position) {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   context.setCaseSensitive(true); break;\n            case SettingsParser.INSENSITIVE: context.setCaseSensitive(false); break;\n            case SettingsParser.STRICT:      context.setStrict(true); break;\n            case SettingsParser.LENIENT:     context.setStrict(false); break;\n        }\n        return position;\n    }\n\n    toString() {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   return 'ParseCaseSensitive(true)';\n            case SettingsParser.INSENSITIVE: return 'ParseCaseSensitive(false)';\n            case SettingsParser.STRICT:      return 'ParseStrict(true)';\n            case SettingsParser.LENIENT:     return 'ParseStrict(false)';\n        }\n    }\n}\n\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from '../../assert';\n\n/**\n * Prints or parses a string literal.\n * @private\n */\nexport class StringLiteralPrinterParser {\n\n    constructor(literal) {\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        const length = text.length;\n        assert(!(position > length || position < 0));\n\n        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        const converted = this._literal.replace(\"'\", \"''\");\n        return '\\'' + converted + '\\'';\n    }\n}\n\n","/*\n * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException} from '../errors';\n\nexport class ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     *\n     * This returns the latest available rules for the zone ID.\n     *\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        throw new DateTimeException('unsupported ZoneId:' + zoneId);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * These zone IDs are loaded and available for use by {@link ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return [];\n    }\n}\n\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport {ZoneId} from './ZoneId';\nimport {ZoneRulesProvider} from './zone/ZoneRulesProvider';\n\n/**\n * A geographical region where the same time-zone rules apply.\n *\n * Time-zone information is categorized as a set of rules defining when and\n * how the offset from UTC/Greenwich changes. These rules are accessed using\n * identifiers based on geographical regions, such as countries or states.\n * The most common region classification is the Time Zone Database (TZDB),\n * which defines regions such as 'Europe/Paris' and 'Asia/Tokyo'.\n *\n * The region identifier, modeled by this class, is distinct from the\n * underlying rules, modeled by {@link ZoneRules}.\n * The rules are defined by governments and change frequently.\n * By contrast, the region identifier is well-defined and long-lived.\n * This separation also allows rules to be shared between regions if appropriate.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class ZoneRegion extends ZoneId {\n    /**\n     * not yet implemented\n     * @param {string} zoneId\n     * @return {ZoneId}\n     */\n    static ofId(zoneId){\n        const rules = ZoneRulesProvider.getRules(zoneId);\n        return new ZoneRegion(zoneId, rules);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {string} id  the time-zone ID, not null\n     * @param {ZoneRules} rules  the rules, null for lazy lookup\n     * @private\n     */\n    constructor(id, rules) {\n        super();\n        this._id = id;\n        this._rules = rules;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @returns {ZoneRules}\n     */\n    rules() {\n        return this._rules;\n    }\n\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ZoneOffset} from '../../ZoneOffset';\nimport {ZoneId} from '../../ZoneId';\nimport {ZoneRegion} from '../../ZoneRegion';\n\nimport {ChronoField} from '../../temporal/ChronoField';\n\nimport { ZoneRulesProvider } from '../../zone/ZoneRulesProvider';\n\nimport {OffsetIdPrinterParser} from './OffsetIdPrinterParser';\n\n/**\n * Prints or parses a zone ID.\n * @private\n */\nexport class ZoneIdPrinterParser {\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @param {string} description\n     */\n    constructor(query, description) {\n        this.query = query;\n        this.description = description;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {DateTimePrintContext } context\n     * @param {StringBuilder} buf\n     * @returns {boolean}\n     */\n    print(context, buf) {\n        const zone = context.getValueQuery(this.query);\n        if (zone == null) {\n            return false;\n        }\n        buf.append(zone.id());\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This implementation looks for the longest matching string.\n     * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just\n     * Etc/GMC although both are valid.\n     *\n     * This implementation uses a tree to search for valid time-zone names in\n     * the parseText. The top level node of the tree has a length equal to the\n     * length of the shortest time-zone as well as the beginning characters of\n     * all other time-zones.\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        const length = text.length;\n        if (position > length) {\n            return ~position;\n        }\n        if (position === length) {\n            return ~position;\n        }\n\n        // handle fixed time-zone IDs\n        const nextChar = text.charAt(position);\n        if (nextChar === '+' || nextChar === '-') {\n            const newContext = context.copy();\n            const endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n            if (endPos < 0) {\n                return endPos;\n            }\n            const offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n            const zone = ZoneOffset.ofTotalSeconds(offset);\n            context.setParsedZone(zone);\n            return endPos;\n        } else if (length >= position + 2) {\n            const nextNextChar = text.charAt(position + 1);\n            if (context.charEquals(nextChar, 'U') &&\n                context.charEquals(nextNextChar, 'T')) {\n                if (length >= position + 3 &&\n                    context.charEquals(text.charAt(position + 2), 'C')) {\n                    return this._parsePrefixedOffset(context, text, position, position + 3);\n                }\n                return this._parsePrefixedOffset(context, text, position, position + 2);\n            } else if (context.charEquals(nextChar, 'G') &&\n                length >= position + 3 &&\n                context.charEquals(nextNextChar, 'M') &&\n                context.charEquals(text.charAt(position + 2), 'T')) {\n                return this._parsePrefixedOffset(context, text, position, position + 3);\n            }\n        }\n        // javascript special case\n        if(text.substr(position, 6) === 'SYSTEM'){\n            context.setParsedZone(ZoneId.systemDefault());\n            return position + 6;\n        }\n\n        // ...\n        if (context.charEquals(nextChar, 'Z')) {\n            context.setParsedZone(ZoneOffset.UTC);\n            return position + 1;\n        }\n\n        const availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();\n        if (zoneIdTree.size !== availableZoneIds.length) {\n            zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);\n        }\n\n        const maxParseLength = length - position;\n        let treeMap = zoneIdTree.treeMap;\n        let parsedZoneId = null;\n        let parseLength = 0;\n        while(treeMap != null) {\n            const parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));\n            treeMap = treeMap.get(parsedSubZoneId);\n            if (treeMap != null && treeMap.isLeaf) {\n                parsedZoneId = parsedSubZoneId;\n                parseLength = treeMap.length;\n            }\n        }\n        if (parsedZoneId != null) {\n            context.setParsedZone(ZoneRegion.ofId(parsedZoneId));\n            return position + parseLength;\n        }\n\n        return ~position;\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} prefixPos\n     * @param {number} position\n     * @return {number}\n     */\n    _parsePrefixedOffset(context, text, prefixPos, position) {\n        const prefix = text.substring(prefixPos, position).toUpperCase();\n        const newContext = context.copy();\n        if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        const endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n        if (endPos < 0) {\n            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        const offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n        const offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        context.setParsedZone(ZoneId.ofOffset(prefix, offset));\n        return endPos;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this.description;\n    }\n}\n\nclass ZoneIdTree {\n\n    static createTreeMap(availableZoneIds) {\n        const sortedZoneIds =  availableZoneIds.sort((a, b) => a.length - b.length);\n        const treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);\n        for (let i=0; i<sortedZoneIds.length; i++){\n            treeMap.add(sortedZoneIds[i]);\n        }\n        return new ZoneIdTree(sortedZoneIds.length, treeMap);\n    }\n\n    constructor(size, treeMap) {\n        this.size = size;\n        this.treeMap = treeMap;\n    }\n}\n\nclass ZoneIdTreeMap {\n    constructor(length = 0, isLeaf = false){\n        this.length = length;\n        this.isLeaf = isLeaf;\n        this._treeMap = {};\n    }\n\n    add(zoneId){\n        const idLength = zoneId.length;\n        if(idLength === this.length) {\n            this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);\n        } else if (idLength > this.length) {\n            const subZoneId = zoneId.substr(0, this.length);\n            let subTreeMap = this._treeMap[subZoneId];\n            if (subTreeMap == null) {\n                subTreeMap = new ZoneIdTreeMap(idLength, false);\n                this._treeMap[subZoneId] = subTreeMap;\n            }\n            subTreeMap.add(zoneId);\n        }\n    }\n\n    get(zoneId){\n        return this._treeMap[zoneId];\n    }\n}\n\nlet zoneIdTree = new ZoneIdTree([]);","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull, requireInstance} from '../assert';\nimport {IllegalArgumentException, IllegalStateException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {LocalDate} from '../LocalDate';\nimport {LocalDateTime} from '../LocalDateTime';\nimport {ZoneOffset} from '../ZoneOffset';\nimport {ChronoLocalDate} from '../chrono/ChronoLocalDate';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {IsoFields} from '../temporal/IsoFields';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nimport {DateTimeFormatter} from './DateTimeFormatter';\nimport {DecimalStyle} from './DecimalStyle';\nimport {SignStyle} from './SignStyle';\nimport {TextStyle} from './TextStyle';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {CharLiteralPrinterParser} from './parser/CharLiteralPrinterParser';\nimport {CompositePrinterParser} from './parser/CompositePrinterParser';\nimport {FractionPrinterParser} from './parser/FractionPrinterParser';\nimport {NumberPrinterParser, ReducedPrinterParser} from './parser/NumberPrinterParser';\nimport {OffsetIdPrinterParser} from './parser/OffsetIdPrinterParser';\nimport {PadPrinterParserDecorator} from './parser/PadPrinterParserDecorator';\nimport {SettingsParser} from './parser/SettingsParser';\nimport {StringLiteralPrinterParser} from './parser/StringLiteralPrinterParser';\nimport {ZoneIdPrinterParser} from './parser/ZoneIdPrinterParser';\n\nconst MAX_WIDTH = 15; // can't parse all numbers with more then 15 digits in javascript\n\nexport class DateTimeFormatterBuilder {\n\n    /**\n     * Constructs a new instance of the builder.\n     */\n    constructor() {\n        /**\n         * The currently active builder, used by the outermost builder.\n         */\n        this._active = this;\n        /**\n         * The parent builder, null for the outermost builder.\n         */\n        this._parent = null;\n\n        /**\n         * The list of printers that will be used.\n         */\n        this._printerParsers = [];\n\n        /**\n         * Whether this builder produces an optional formatter.\n         */\n        this._optional = false;\n        /**\n         * The width to pad the next field to.\n         */\n        this._padNextWidth = 0;\n\n        /**\n         * The character to pad the next field with.\n         */\n        this._padNextChar = null;\n\n        /**\n         * The index of the last variable width value parser.\n         */\n        this._valueParserIndex = -1;\n    }\n\n    /**\n     * Private static factory, replaces private threeten constructor\n     * Returns a new instance of the builder.\n     *\n     * @param {DateTimeFormatterBuilder} parent  the parent builder, not null\n     * @param {boolean} optional  whether the formatter is optional, not null\n     * @return {DateTimeFormatterBuilder} new instance\n     */\n    static _of(parent, optional){\n        requireNonNull(parent, 'parent');\n        requireNonNull(optional, 'optional');\n\n        const dtFormatterBuilder = new DateTimeFormatterBuilder();\n        dtFormatterBuilder._parent = parent;\n        dtFormatterBuilder._optional = optional;\n\n        return dtFormatterBuilder;\n    }\n\n    /**\n     * Changes the parse style to be case sensitive for the remainder of the formatter.\n     *\n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     *\n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link parseCaseInsensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * Since the default is case sensitive, this method should only be used after\n     * a previous call to {@link parseCaseInsensitive}.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseSensitive() {\n        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be case insensitive for the remainder of the formatter.\n     *\n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     *\n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link parseCaseSensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseInsensitive() {\n        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Changes the parse style to be strict for the remainder of the formatter.\n     *\n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     *\n     * When used, this method changes the parsing to be strict from this point onwards.\n     * As strict is the default, this is normally only needed after calling {@link parseLenient}.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@link parseLenient} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseStrict() {\n        this._appendInternalPrinterParser(SettingsParser.STRICT);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be lenient for the remainder of the formatter.\n     * Note that case sensitivity is set separately to this method.\n     *\n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     * Applications calling this method should typically also call {@link parseCaseInsensitive}.\n     *\n     * When used, this method changes the parsing to be strict from this point onwards.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@link parseStrict} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseLenient() {\n        this._appendInternalPrinterParser(SettingsParser.LENIENT);\n        return this;\n    }\n\n    /**\n     * appendValue function overloading\n     */\n    appendValue(){\n        if(arguments.length === 1){\n            return this._appendValue1.apply(this, arguments);\n        } else if(arguments.length === 2){\n            return this._appendValue2.apply(this, arguments);\n        } else {\n            return this._appendValue4.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a normal\n     * output style.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * The value will be printed as per the normal print of an integer value.\n     * Only negative numbers will be signed. No padding will be added.\n     *\n     * The parser for a variable width value such as this normally behaves greedily,\n     * requiring one digit, but accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link appendValue} for full details.\n     *\n     * @param field  the field to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValue1(field) {\n        requireNonNull(field);\n        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a fixed\n     * width, zero-padded approach.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * The value will be zero-padded on the left. If the size of the value\n     * means that it cannot be printed within the width then an exception is thrown.\n     * If the value of the field is negative then an exception is thrown during printing.\n     *\n     * This method supports a special technique of parsing known as 'adjacent value parsing'.\n     * This technique solves the problem where a variable length value is followed by one or more\n     * fixed length values. The standard parser is greedy, and thus it would normally\n     * steal the digits that are needed by the fixed width value parsers that follow the\n     * variable width one.\n     *\n     * No action is required to initiate 'adjacent value parsing'.\n     * When a call to {@link appendValue} with a variable width is made, the builder\n     * enters adjacent value parsing setup mode. If the immediately subsequent method\n     * call or calls on the same builder are to this method, then the parser will reserve\n     * space so that the fixed width values can be parsed.\n     *\n     * For example, consider `builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2)`.\n     * The year is a variable width parse of between 1 and 19 digits.\n     * The month is a fixed width parse of 2 digits.\n     * Because these were appended to the same builder immediately after one another,\n     * the year parser will reserve two digits for the month to parse.\n     * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.\n     * Without adjacent value parsing, the year would greedily parse all six digits and leave\n     * nothing for the month.\n     *\n     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser\n     * that immediately follow any kind of variable width value.\n     * Calling any other append method will end the setup of adjacent value parsing.\n     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,\n     * simply add the `appendValue` to another {@link DateTimeFormatterBuilder}\n     * and add that to this builder.\n     *\n     * If adjacent parsing is active, then parsing must match exactly the specified\n     * number of digits in both strict and lenient modes.\n     * In addition, no positive or negative sign is permitted.\n     *\n     * @param field  the field to append, not null\n     * @param width  the width of the printed field, from 1 to 19\n     * @return this, for chaining, not null\n     * @throws IllegalArgumentException if the width is invalid\n     */\n    _appendValue2(field, width) {\n        requireNonNull(field);\n        if (width < 1 || width > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The width must be from 1 to ${MAX_WIDTH} inclusive but was ${width}`);\n        }\n        const pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter providing full\n     * control over printing.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * This method provides full control of the numeric formatting, including\n     * zero-padding and the positive/negative sign.\n     *\n     * The parser for a variable width value such as this normally behaves greedily,\n     * accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link appendValue} for full details.\n     *\n     * In strict parsing mode, the minimum number of parsed digits is `minWidth`.\n     * In lenient parsing mode, the minimum number of parsed digits is one.\n     *\n     * If this method is invoked with equal minimum and maximum widths and a sign style of\n     * `NOT_NEGATIVE` then it delegates to `appendValue(TemporalField, int)`.\n     * In this scenario, the printing and parsing behavior described there occur.\n     *\n     * @param field  the field to append, not null\n     * @param minWidth  the minimum field width of the printed field, from 1 to 19\n     * @param maxWidth  the maximum field width of the printed field, from 1 to 19\n     * @param signStyle  the positive/negative output style, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the widths are invalid\n     */\n    _appendValue4(field, minWidth, maxWidth, signStyle) {\n        requireNonNull(field);\n        requireNonNull(signStyle);\n        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n            return this._appendValue2(field, maxWidth);\n        }\n        if (minWidth < 1 || minWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${minWidth}`);\n        }\n        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${maxWidth}`);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(`The maximum width must exceed or equal the minimum width but ${maxWidth} < ${minWidth}`);\n        }\n        const pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * appendValueReduced function overloading\n     */\n    appendValueReduced() {\n        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n            return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n        } else {\n            return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Appends the reduced value of a date-time field to the formatter.\n     *\n     * Since fields such as year vary by chronology, it is recommended to use the\n     * {@link appendValueReduced} date}\n     * variant of this method in most cases. This variant is suitable for\n     * simple fields or working with only the ISO chronology.\n     *\n     * For formatting, the `width` and `maxWidth` are used to\n     * determine the number of characters to format.\n     * If they are equal then the format is fixed width.\n     * If the value of the field is within the range of the `baseValue` using\n     * `width` characters then the reduced value is formatted otherwise the value is\n     * truncated to fit `maxWidth`.\n     * The rightmost characters are output to match the width, left padding with zero.\n     *\n     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\n     * For lenient parsing, the number of characters must be at least 1 and less than 10.\n     * If the number of digits parsed is equal to `width` and the value is positive,\n     * the value of the field is computed to be the first number greater than\n     * or equal to the `baseValue` with the same least significant characters,\n     * otherwise the value parsed is the field value.\n     * This allows a reduced value to be entered for values in range of the baseValue\n     * and width and absolute values can be entered for values outside the range.\n     *\n     * For example, a base value of `1980` and a width of `2` will have\n     * valid values from `1980` to `2079`.\n     * During parsing, the text `\"12\"` will result in the value `2012` as that\n     * is the value within the range where the last two characters are \"12\".\n     * By contrast, parsing the text `\"1915\"` will result in the value `1915`.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {number} width  the field width of the printed and parsed field, from 1 to 10\n     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10\n     * @param {number} baseValue  the base value of the range of valid values\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the width or base value is invalid\n     */\n    _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n        requireNonNull(field, 'field');\n        const pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the reduced value of a date-time field to the formatter.\n     *\n     * This is typically used for formatting and parsing a two digit year.\n     *\n     * The base date is used to calculate the full value during parsing.\n     * For example, if the base date is 1950-01-01 then parsed values for\n     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.\n     * Only the year would be extracted from the date, thus a base date of\n     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.\n     * This behavior is necessary to support fields such as week-based-year\n     * or other calendar systems where the parsed value does not align with\n     * standard ISO years.\n     *\n     * The exact behavior is as follows. Parse the full set of fields and\n     * determine the effective chronology using the last chronology if\n     * it appears more than once. Then convert the base date to the\n     * effective chronology. Then extract the specified field from the\n     * chronology-specific base date and use it to determine the\n     * `baseValue` used below.\n     *\n     * For formatting, the `width` and `maxWidth` are used to\n     * determine the number of characters to format.\n     * If they are equal then the format is fixed width.\n     * If the value of the field is within the range of the `baseValue` using\n     * `width` characters then the reduced value is formatted otherwise the value is\n     * truncated to fit `maxWidth`.\n     * The rightmost characters are output to match the width, left padding with zero.\n     *\n     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\n     * For lenient parsing, the number of characters must be at least 1 and less than 10.\n     * If the number of digits parsed is equal to `width` and the value is positive,\n     * the value of the field is computed to be the first number greater than\n     * or equal to the `baseValue` with the same least significant characters,\n     * otherwise the value parsed is the field value.\n     * This allows a reduced value to be entered for values in range of the baseValue\n     * and width and absolute values can be entered for values outside the range.\n     *\n     * For example, a base value of `1980` and a width of `2` will have\n     * valid values from `1980` to `2079`.\n     * During parsing, the text `\"12\"` will result in the value `2012` as that\n     * is the value within the range where the last two characters are \"12\".\n     * By contrast, parsing the text `\"1915\"` will result in the value `1915`.\n     *\n     * @param {TemporaField} field  the field to append, not null\n     * @param {number} width  the field width of the printed and parsed field, from 1 to 10\n     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10\n     * @param {ChronoLocalDate} baseDate  the base date used to calculate the base value for the range\n     *  of valid values in the parsed chronology, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the width or base value is invalid\n     */\n    _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n        requireNonNull(field, 'field');\n        requireNonNull(baseDate, 'baseDate');\n        requireInstance(baseDate, ChronoLocalDate, 'baseDate');\n        const pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends a fixed width printer-parser.\n     *\n     * @param pp  the printer-parser, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValuePrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._valueParserIndex >= 0 &&\n                this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n            const activeValueParser = this._active._valueParserIndex;\n\n            // adjacent parsing mode, update setting in previous parsers\n            let basePP = this._active._printerParsers[activeValueParser];\n            if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n                // Append the width to the subsequentWidth of the active parser\n                basePP = basePP.withSubsequentWidth(pp.maxWidth());\n                // Append the new parser as a fixed width\n                this._appendInternal(pp.withFixedWidth());\n                // Retain the previous active parser\n                this._active._valueParserIndex = activeValueParser;\n            } else {\n                // Modify the active parser to be fixed width\n                basePP = basePP.withFixedWidth();\n                // The new parser becomes the mew active parser\n                this._active._valueParserIndex = this._appendInternal(pp);\n            }\n            // Replace the modified parser with the updated one\n            this._active._printerParsers[activeValueParser] = basePP;\n        } else {\n            // The new Parser becomes the active parser\n            this._active._valueParserIndex = this._appendInternal(pp);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the fractional value of a date-time field to the formatter.\n     *\n     * The fractional value of the field will be output including the\n     * preceding decimal point. The preceding value is not output.\n     * For example, the second-of-minute value of 15 would be output as `.25`.\n     *\n     * The width of the printed fraction can be controlled. Setting the\n     * minimum width to zero will cause no output to be generated.\n     * The printed fraction will have the minimum width necessary between\n     * the minimum and maximum widths - trailing zeroes are omitted.\n     * No rounding occurs due to the maximum width - digits are simply dropped.\n     *\n     * When parsing in strict mode, the number of parsed digits must be between\n     * the minimum and maximum width. When parsing in lenient mode, the minimum\n     * width is considered to be zero and the maximum is nine.\n     *\n     * If the value cannot be obtained then an exception will be thrown.\n     * If the value is negative an exception will be thrown.\n     * If the field does not have a fixed set of valid values then an\n     * exception will be thrown.\n     * If the field value in the date-time to be printed is invalid it\n     * cannot be printed and an exception will be thrown.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {Number} minWidth  the minimum width of the field excluding the decimal point, from 0 to 9\n     * @param {Number} maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the field has a variable set of valid values or\n     *  either width is invalid\n     */\n    appendFraction(field, minWidth, maxWidth, decimalPoint) {\n        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n        return this;\n    }\n\n    /**\n     * Appends an instant using ISO-8601 to the formatter with control over\n     * the number of fractional digits.\n     *\n     * Instants have a fixed output format, although this method provides some\n     * control over the fractional digits. They are converted to a date-time\n     * with a zone-offset of UTC and printed using the standard ISO-8601 format.\n     * The localized decimal style is not used.\n     *\n     * The {@link this.fractionalDigits} parameter allows the output of the fractional\n     * second to be controlled. Specifying zero will cause no fractional digits\n     * to be output. From 1 to 9 will output an increasing number of digits, using\n     * zero right-padding if necessary. The special value -1 is used to output as\n     * many digits as necessary to avoid any trailing zeroes.\n     *\n     * When parsing in strict mode, the number of parsed digits must match the\n     * fractional digits. When parsing in lenient mode, any number of fractional\n     * digits from zero to nine are accepted.\n     *\n     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS}\n     * and optionally (@code NANO_OF_SECOND). The value of {@link INSTANT_SECONDS}\n     * may be outside the maximum range of {@link LocalDateTime}.\n     *\n     * The {@link ResolverStyle} has no effect on instant parsing.\n     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.\n     * The leap-second time of '23:59:59' is handled to some degree, see\n     * {@link DateTimeFormatter#parsedLeapSecond} for full details.\n     *\n     * An alternative to this method is to format/parse the instant as a single\n     * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.\n     *\n     * @param {number} [fractionalDigits=-2] - the number of fractional second digits to format with,\n     *  from 0 to 9, or -1 to use as many digits as necessary\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendInstant(fractionalDigits=-2) {\n        if (fractionalDigits < -2 || fractionalDigits > 9) {\n            throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);\n        }\n        this._appendInternal(new InstantPrinterParser(fractionalDigits));\n        return this;\n    }\n\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     *\n     * This appends an instruction to print/parse the offset ID to the builder.\n     * This is equivalent to calling `appendOffset(\"HH:MM:ss\", \"Z\")`.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffsetId() {\n        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n        return this;\n    }\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     *\n     * This appends an instruction to print/parse the offset ID to the builder.\n     *\n     * During printing, the offset is obtained using a mechanism equivalent\n     * to querying the temporal with {@link TemporalQueries#offset}.\n     * It will be printed using the format defined below.\n     * If the offset cannot be obtained then an exception is thrown unless the\n     * section of the formatter is optional.\n     *\n     * During parsing, the offset is parsed using the format defined below.\n     * If the offset cannot be parsed then an exception is thrown unless the\n     * section of the formatter is optional.\n     *\n     * The format of the offset is controlled by a pattern which must be one\n     * of the following:\n     *\n     * * `+HH` - hour only, ignoring minute and second\n     * * `+HHmm` - hour, with minute if non-zero, ignoring second, no colon\n     * * `+HH:mm` - hour, with minute if non-zero, ignoring second, with colon\n     * * `+HHMM` - hour and minute, ignoring second, no colon\n     * * `+HH:MM` - hour and minute, ignoring second, with colon\n     * * `+HHMMss` - hour and minute, with second if non-zero, no colon\n     * * `+HH:MM:ss` - hour and minute, with second if non-zero, with colon\n     * * `+HHMMSS` - hour, minute and second, no colon\n     * * `+HH:MM:SS` - hour, minute and second, with colon\n     *\n     * The \"no offset\" text controls what text is printed when the total amount of\n     * the offset fields to be output is zero.\n     * Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.\n     * Three formats are accepted for parsing UTC - the \"no offset\" text, and the\n     * plus and minus versions of zero defined by the pattern.\n     *\n     * @param {String} pattern  the pattern to use, not null\n     * @param {String} noOffsetText  the text to use when the offset is zero, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffset(pattern, noOffsetText) {\n        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n        return this;\n    }\n\n    /**\n      * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.\n      *\n      * This appends an instruction to print/parse the zone ID to the builder.\n      * The zone ID is obtained in a strict manner suitable for {@link ZonedDateTime}.\n      * By contrast, {@link OffsetDateTime} does not have a zone ID suitable\n      * for use with this method, see {@link appendZoneOrOffsetId}.\n      *\n      * During printing, the zone is obtained using a mechanism equivalent\n      * to querying the temporal with {@link TemporalQueries#zoneId}.\n      * It will be printed using the result of {@link ZoneId#getId}.\n      * If the zone cannot be obtained then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * During parsing, the zone is parsed and must match a known zone or offset.\n      * If the zone cannot be parsed then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * @return {DateTimeFormatterBuilder} this, for chaining, not null\n      * @see #appendZoneRegionId()\n      */\n    appendZoneId() {\n        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the elements defined by the specified pattern to the builder.\n     *\n     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n     * The characters '{' and '}' are reserved for future use.\n     * The characters '[' and ']' indicate optional patterns.\n     * The following pattern letters are defined:\n     * <pre>\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | u      | year                       | year             | 2004; 04\n     *  | y      | year-of-era                | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     * </pre>\n     *\n     * The count of pattern letters determine the format.\n     *\n     * **Text**: The text style is determined based on the number of pattern letters used.\n     * Less than 4 pattern letters will use the short form (see {@link TextStyle#SHORT}).\n     * Exactly 4 pattern letters will use the full form (see {@link TextStyle#FULL}).\n     * Exactly 5 pattern letters will use the narrow form (see {@link TextStyle#NARROW}).\n     *\n     * **Number**: If the count of letters is one, then the value is printed using the minimum number\n     * of digits and without padding as per {@link appendValue}. Otherwise, the\n     * count of digits is used as the width of the output field as per {@link appendValue}.\n     *\n     * **Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\n     * Otherwise use the Number rules above.\n     *\n     * **Fraction**: Outputs the nano-of-second field as a fraction-of-second.\n     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\n     * If it is less than 9, then the nano-of-second value is truncated, with only the most\n     * significant digits being output.\n     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.\n     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern\n     * letters, up to 9 digits.\n     *\n     * **Year**: The count of letters determines the minimum field width below which padding is used.\n     * If the count of letters is two, then a reduced (see {@link appendValueReduced}) two digit form is used.\n     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the\n     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\n     * If the count of letters is less than four (but not two), then the sign is only output for negative\n     * years as per {@link SignStyle#NORMAL}.\n     * Otherwise, the sign is output if the pad width is exceeded, as per {@link SignStyle#EXCEEDS_PAD}\n     *\n     * **ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\n     * If the count of letters is two, then the time-zone ID is output.\n     * Any other count of letters throws {@link IllegalArgumentException}.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   VV          appendZoneId()\n     * </pre>\n     *\n     * **Zone names**: This outputs the display name of the time-zone ID.\n     * If the count of letters is one, two or three, then the short name is output.\n     * If the count of letters is four, then the full name is output.\n     * Five or more letters throws {@link IllegalArgumentException}.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   z           appendZoneText(TextStyle.SHORT)\n     *   zz          appendZoneText(TextStyle.SHORT)\n     *   zzz         appendZoneText(TextStyle.SHORT)\n     *   zzzz        appendZoneText(TextStyle.FULL)\n     * </pre>\n     *\n     * **Offset X and x**: This formats the offset based on the number of pattern letters.\n     * One letter outputs just the hour', such as '+01', unless the minute is non-zero\n     * in which case the minute is also output, such as '+0130'.\n     * Two letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Three letters outputs the hour and minute, with a colon, such as '+01:30'.\n     * Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\n     * Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\n     * Six or more letters throws {@link IllegalArgumentException}.\n     * Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\n     * whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   X           appendOffset(\"+HHmm\",\"Z\")\n     *   XX          appendOffset(\"+HHMM\",\"Z\")\n     *   XXX         appendOffset(\"+HH:MM\",\"Z\")\n     *   XXXX        appendOffset(\"+HHMMss\",\"Z\")\n     *   XXXXX       appendOffset(\"+HH:MM:ss\",\"Z\")\n     *   x           appendOffset(\"+HHmm\",\"+00\")\n     *   xx          appendOffset(\"+HHMM\",\"+0000\")\n     *   xxx         appendOffset(\"+HH:MM\",\"+00:00\")\n     *   xxxx        appendOffset(\"+HHMMss\",\"+0000\")\n     *   xxxxx       appendOffset(\"+HH:MM:ss\",\"+00:00\")\n     * </pre>\n     *\n     * **Offset Z**: This formats the offset based on the number of pattern letters.\n     * One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Four or more letters throws {@link IllegalArgumentException}.\n     * The output will be '+0000' when the offset is zero.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   Z           appendOffset(\"+HHMM\",\"+0000\")\n     *   ZZ          appendOffset(\"+HHMM\",\"+0000\")\n     *   ZZZ         appendOffset(\"+HHMM\",\"+0000\")\n     * </pre>\n     *\n     * **Optional section**: The optional section markers work exactly like calling {@link optionalStart}\n     * and {@link optionalEnd}.\n     *\n     * **Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\n     * The pad width is determined by the number of pattern letters.\n     * This is the same as calling {@link padNext}.\n     *\n     * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n     *\n     * Any unrecognized letter is an error.\n     * Any non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\n     * Despite this, it is recommended to use single quotes around all characters that you want to\n     * output directly to ensure that future changes do not break your application.\n     *\n     * Note that the pattern string is similar, but not identical, to\n     * {@link java.text.SimpleDateFormat}.\n     * The pattern string is also similar, but not identical, to that defined by the\n     * Unicode Common Locale Data Repository (CLDR/LDML).\n     * Pattern letters 'E' and 'u' are merged, which changes the meaning of \"E\" and \"EE\" to be numeric.\n     * Pattern letters 'X' is aligned with Unicode CLDR/LDML, which affects pattern 'X'.\n     * Pattern letter 'y' and 'Y' parse years of two digits and more than 4 digits differently.\n     * Pattern letters 'n', 'A', 'N', 'I' and 'p' are added.\n     * Number types will reject large numbers.\n     *\n     * @param {String} pattern  the pattern to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    appendPattern(pattern) {\n        requireNonNull(pattern, 'pattern');\n        this._parsePattern(pattern);\n        return this;\n    }\n\n\n    //-----------------------------------------------------------------------\n    // empty implementations of locale functionality, be implemented/overridden by js-joda-locale\n\n    appendZoneText() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n    }\n\n    appendText() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n    }\n\n    appendLocalizedOffset() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n    }\n\n    appendWeekField() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n    }\n\n    //-----------------------------------------------------------------------\n\n    _parsePattern(pattern) {\n        /** Map of letters to fields. */\n        const FIELD_MAP = {\n            'G': ChronoField.ERA,\n            'y': ChronoField.YEAR_OF_ERA,\n            'u': ChronoField.YEAR,\n            'Q': IsoFields.QUARTER_OF_YEAR,\n            'q': IsoFields.QUARTER_OF_YEAR,\n            'M': ChronoField.MONTH_OF_YEAR,\n            'L': ChronoField.MONTH_OF_YEAR,\n            'D': ChronoField.DAY_OF_YEAR,\n            'd': ChronoField.DAY_OF_MONTH,\n            'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n            'E': ChronoField.DAY_OF_WEEK,\n            'c': ChronoField.DAY_OF_WEEK,\n            'e': ChronoField.DAY_OF_WEEK,\n            'a': ChronoField.AMPM_OF_DAY,\n            'H': ChronoField.HOUR_OF_DAY,\n            'k': ChronoField.CLOCK_HOUR_OF_DAY,\n            'K': ChronoField.HOUR_OF_AMPM,\n            'h': ChronoField.CLOCK_HOUR_OF_AMPM,\n            'm': ChronoField.MINUTE_OF_HOUR,\n            's': ChronoField.SECOND_OF_MINUTE,\n            'S': ChronoField.NANO_OF_SECOND,\n            'A': ChronoField.MILLI_OF_DAY,\n            'n': ChronoField.NANO_OF_SECOND,\n            'N': ChronoField.NANO_OF_DAY\n        };\n\n        for (let pos = 0; pos < pattern.length; pos++) {\n            let cur = pattern.charAt(pos);\n            if ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z')) {\n                let start = pos++;\n                for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);  // short loop\n                let count = pos - start;\n                // padding\n                if (cur === 'p') {\n                    let pad = 0;\n                    if (pos < pattern.length) {\n                        cur = pattern.charAt(pos);\n                        if ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z')) {\n                            pad = count;\n                            start = pos++;\n                            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);  // short loop\n                            count = pos - start;\n                        }\n                    }\n                    if (pad === 0) {\n                        throw new IllegalArgumentException(\n                            'Pad letter \\'p\\' must be followed by valid pad pattern: ' + pattern);\n                    }\n                    this.padNext(pad); // pad and continue parsing\n                }\n                // main rules\n                const field = FIELD_MAP[cur];\n                if (field != null) {\n                    this._parseField(cur, count, field);\n                } else if (cur === 'z') {\n                    if (count > 4) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    } else if (count === 4) {\n                        this.appendZoneText(TextStyle.FULL);\n                    } else {\n                        this.appendZoneText(TextStyle.SHORT);\n                    }\n                } else if (cur === 'V') {\n                    if (count !== 2) {\n                        throw new IllegalArgumentException('Pattern letter count must be 2: ' + cur);\n                    }\n                    this.appendZoneId();\n                } else if (cur === 'Z') {\n                    if (count < 4) {\n                        this.appendOffset('+HHMM', '+0000');\n                    } else if (count === 4) {\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else if (count === 5) {\n                        this.appendOffset('+HH:MM:ss', 'Z');\n                    } else {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                } else if (cur === 'O') {\n                    if (count === 1) {\n                        this.appendLocalizedOffset(TextStyle.SHORT);\n                    } else if (count === 4) {\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else {\n                        throw new IllegalArgumentException('Pattern letter count must be 1 or 4: ' + cur);\n                    }\n                } else if (cur === 'X') {\n                    if (count > 5) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');\n                } else if (cur === 'x') {\n                    if (count > 5) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    const zero = (count === 1 ? '+00' : (count % 2 === 0 ? '+0000' : '+00:00'));\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n                } else if (cur === 'W') {\n                    if (count > 1) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    this.appendWeekField('W', count);\n                } else if (cur === 'w') {\n                    if (count > 2) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    this.appendWeekField('w', count);\n                } else if (cur === 'Y') {\n                    this.appendWeekField('Y', count);\n                } else {\n                    throw new IllegalArgumentException('Unknown pattern letter: ' + cur);\n                }\n                pos--;\n\n            } else if (cur === '\\'') {\n                // parse literals\n                const start = pos++;\n                for (; pos < pattern.length; pos++) {\n                    if (pattern.charAt(pos) === '\\'') {\n                        if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\\'') {\n                            pos++;\n                        } else {\n                            break;  // end of literal\n                        }\n                    }\n                }\n                if (pos >= pattern.length) {\n                    throw new IllegalArgumentException('Pattern ends with an incomplete string literal: ' + pattern);\n                }\n                const str = pattern.substring(start + 1, pos);\n                if (str.length === 0) {\n                    this.appendLiteral('\\'');\n                } else {\n                    this.appendLiteral(str.replace('\\'\\'', '\\''));\n                }\n\n            } else if (cur === '[') {\n                this.optionalStart();\n\n            } else if (cur === ']') {\n                if (this._active._parent === null) {\n                    throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');\n                }\n                this.optionalEnd();\n\n            } else if (cur === '{' || cur === '}' || cur === '#') {\n                throw new IllegalArgumentException('Pattern includes reserved character: \\'' + cur + '\\'');\n            } else {\n                this.appendLiteral(cur);\n            }\n        }\n    }\n\n    _parseField(cur, count, field) {\n        switch (cur) {\n            case 'u':\n            case 'y':\n                if (count === 2) {\n                    this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n                } else if (count < 4) {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);\n                } else {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);\n                }\n                break;\n            case 'M':\n            case 'Q':\n                switch (count) {\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'L':\n            case 'q':\n                switch (count) {\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'e':\n                switch (count) {\n                    case 1:\n                    case 2:\n                        this.appendWeekField('e', count);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'c':\n                switch (count) {\n                    case 1:\n                        this.appendWeekField('c', count);\n                        break;\n                    case 2:\n                        throw new IllegalArgumentException('Invalid number of pattern letters: ' + cur);\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'a':\n                if (count === 1) {\n                    this.appendText(field, TextStyle.SHORT);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'E':\n            case 'G':\n                switch (count) {\n                    case 1:\n                    case 2:\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'S':\n                this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n                break;\n            case 'F':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'd':\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n            case 'm':\n            case 's':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count === 2) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'D':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count <= 3) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            default:\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    this.appendValue(field, count);\n                }\n                break;\n        }\n    }\n\n    /**\n     * padNext function overloading\n     */\n    padNext() {\n        if (arguments.length === 1) {\n            return this._padNext1.apply(this, arguments);\n        } else {\n            return this._padNext2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Causes the next added printer/parser to pad to a fixed width using a space.\n     *\n     * This padding will pad to a fixed width using spaces.\n     *\n     * During formatting, the decorated element will be output and then padded\n     * to the specified width. An exception will be thrown during printing if\n     * the pad width is exceeded.\n     *\n     * During parsing, the padding and decorated element are parsed.\n     * If parsing is lenient, then the pad width is treated as a maximum.\n     * If parsing is case insensitive, then the pad character is matched ignoring case.\n     * The padding is parsed greedily. Thus, if the decorated element starts with\n     * the pad character, it will not be parsed.\n     *\n     * @param {number} padWidth  the pad width, 1 or greater\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if pad width is too small\n     */\n    _padNext1(padWidth) {\n        return this._padNext2(padWidth, ' ');\n    }\n\n    /**\n     * Causes the next added printer/parser to pad to a fixed width.\n     *\n     * This padding is intended for padding other than zero-padding.\n     * Zero-padding should be achieved using the appendValue methods.\n     *\n     * During formatting, the decorated element will be output and then padded\n     * to the specified width. An exception will be thrown during printing if\n     * the pad width is exceeded.\n     *\n     * During parsing, the padding and decorated element are parsed.\n     * If parsing is lenient, then the pad width is treated as a maximum.\n     * If parsing is case insensitive, then the pad character is matched ignoring case.\n     * The padding is parsed greedily. Thus, if the decorated element starts with\n     * the pad character, it will not be parsed.\n     *\n     * @param {number} padWidth  the pad width, 1 or greater\n     * @param {String} padChar  the pad character\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if pad width is too small\n     */\n    _padNext2(padWidth, padChar) {\n        if (padWidth < 1) {\n            throw new IllegalArgumentException('The pad width must be at least one but was ' + padWidth);\n        }\n        this._active._padNextWidth = padWidth;\n        this._active._padNextChar = padChar;\n        this._active._valueParserIndex = -1;\n        return this;\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Mark the start of an optional section.\n     *\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling this method and ended by calling\n     * {@link optionalEnd} or by ending the build process.\n     *\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@link TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     *\n     * For example, consider a builder setup as\n     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)`.\n     * The optional section ends automatically at the end of the builder.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    optionalStart() {\n        this._active._valueParserIndex = -1;\n        this._active = DateTimeFormatterBuilder._of(this._active, true);\n        return this;\n    }\n\n    /**\n     * Ends an optional section.\n     *\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling {@link optionalStart} and ended\n     * using this method (or at the end of the builder).\n     *\n     * Calling this method without having previously called `optionalStart`\n     * will throw an exception.\n     * Calling this method immediately after calling `optionalStart` has no effect\n     * on the formatter other than ending the (empty) optional section.\n     *\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@link TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     *\n     * For example, consider a builder setup as\n     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()`.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalStateException if there was no previous call to `optionalStart`\n     */\n    optionalEnd() {\n        if (this._active._parent == null) {\n            throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n        }\n        if (this._active._printerParsers.length > 0) {\n            const cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n            this._active = this._active._parent;\n            this._appendInternal(cpp);\n        } else {\n            this._active = this._active._parent;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternal(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    /**\n     * Appends a string literal to the formatter.\n     *\n     * This string will be output during a print.\n     *\n     * If the literal is empty, nothing is added to the formatter.\n     *\n     * @param literal  the literal to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendLiteral(literal) {\n        assert(literal != null);\n        if (literal.length > 0) {\n            if (literal.length === 1) {\n                this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n            } else {\n                this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternalPrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends all the elements of a formatter to the builder.\n     *\n     * This method has the same effect as appending each of the constituent\n     * parts of the formatter directly to this builder.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    append(formatter) {\n        requireNonNull(formatter, 'formatter');\n        this._appendInternal(formatter._toPrinterParser(false));\n        return this;\n    }\n\n    /**\n     * Completes this builder by creating the DateTimeFormatter.\n     *\n     * This will create a formatter with the specified locale.\n     * Numbers will be printed and parsed using the standard non-localized set of symbols.\n     *\n     * Calling this method will end any open optional sections by repeatedly\n     * calling {@link optionalEnd} before creating the formatter.\n     *\n     * This builder can still be used after creating the formatter if desired,\n     * although the state may have been changed by calls to `optionalEnd`.\n     *\n     * @param resolverStyle  the new resolver style\n     * @return the created formatter, not null\n     */\n    toFormatter(resolverStyle=ResolverStyle.SMART) {\n        while (this._active._parent != null) {\n            this.optionalEnd();\n        }\n        const pp = new CompositePrinterParser(this._printerParsers, false);\n        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n    }\n\n}\n\n// days in a 400 year cycle = 146097\n// days in a 10,000 year cycle = 146097 * 25\n// seconds per day = 86400\nconst SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nconst SECONDS_0000_TO_1970 = ((146097 * 5) - (30 * 365 + 7)) * 86400;\n\n/**\n * Prints or parses an ISO-8601 instant.\n */\nclass InstantPrinterParser  {\n\n    constructor(fractionalDigits) {\n        this.fractionalDigits = fractionalDigits;\n    }\n\n    print(context, buf) {\n        // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n        const inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n        let inNanos = 0;\n        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n        }\n        if (inSecs == null) {\n            return false;\n        }\n        const inSec = inSecs;\n        let inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n        if (inSec >= -SECONDS_0000_TO_1970) {\n            // current era\n            const zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n            const hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n            const lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            const ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            if (hi > 0) {\n                buf.append('+').append(hi);\n            }\n            buf.append(ldt);\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n        } else {\n            // before current era\n            const zeroSecs = inSec + SECONDS_0000_TO_1970;\n            const hi = MathUtil.intDiv(zeroSecs, SECONDS_PER_10000_YEARS);\n            const lo = MathUtil.intMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            const ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            const pos = buf.length();\n            buf.append(ldt);\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n            if (hi < 0) {\n                if (ldt.year() === -10000) {\n                    buf.replace(pos, pos + 2, '' + (hi - 1));\n                } else if (lo === 0) {\n                    buf.insert(pos, hi);\n                } else {\n                    buf.insert(pos + 1, Math.abs(hi));\n                }\n            }\n        }\n        //fraction\n        if (this.fractionalDigits === -2) {\n            if (inNano !== 0) {\n                buf.append('.');\n                if (MathUtil.intMod(inNano, 1000000) === 0) {\n                    buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n                } else if (MathUtil.intMod(inNano, 1000) === 0) {\n                    buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n                } else {\n                    buf.append(('' + ((inNano) + 1000000000)).substring(1));\n                }\n            }\n        } else if (this.fractionalDigits > 0 || (this.fractionalDigits === -1 && inNano > 0)) {\n            buf.append('.');\n            let div = 100000000;\n            for (let i = 0; ((this.fractionalDigits === -1 && inNano > 0) || i < this.fractionalDigits); i++) {\n                const digit = MathUtil.intDiv(inNano, div);\n                buf.append(digit);\n                inNano = inNano - (digit * div);\n                div = MathUtil.intDiv(div, 10);\n            }\n        }\n        buf.append('Z');\n        return true;\n    }\n\n    parse(context, text, position) {\n        // new context to avoid overwriting fields like year/month/day\n        const newContext = context.copy();\n        const minDigits = (this.fractionalDigits < 0 ? 0 : this.fractionalDigits);\n        const maxDigits = (this.fractionalDigits < 0 ? 9 : this.fractionalDigits);\n        const parser = new DateTimeFormatterBuilder()\n            .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')\n            .appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':')\n            .appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z')\n            .toFormatter()._toPrinterParser(false);\n        const pos = parser.parse(newContext, text, position);\n        if (pos < 0) {\n            return pos;\n        }\n        // parser restricts most fields to 2 digits, so definitely int\n        // correctly parsed nano is also guaranteed to be valid\n        const yearParsed = newContext.getParsed(ChronoField.YEAR);\n        const month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n        const day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n        let hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n        const min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n        const secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n        const nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n        let sec = (secVal != null ? secVal : 0);\n        const nano = (nanoVal != null ? nanoVal : 0);\n        const year = MathUtil.intMod(yearParsed, 10000);\n        let days = 0;\n        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n            hour = 0;\n            days = 1;\n        } else if (hour === 23 && min === 59 && sec === 60) {\n            context.setParsedLeapSecond();\n            sec = 59;\n        }\n        let instantSecs;\n        try {\n            const ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n        } catch (ex) {\n            return ~position;\n        }\n        let successPos = pos;\n        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n    }\n\n    toString() {\n        return 'Instant()';\n    }\n}\n\n\nexport function _init() {\n    ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n\n    DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n    DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n    DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n    DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n    DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n    DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n    DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n    DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from './assert';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {DateTimeException, IllegalArgumentException, UnsupportedTemporalTypeException} from './errors';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\n/**\n * A month-of-year, such as 'July'.\n *\n * {@link Month} is representing the 12 months of the year -\n * January, February, March, April, May, June, July, August, September, October,\n * November and December.\n *\n * In addition to the textual name, each month-of-year has an `int` value.\n * The `int` value follows normal usage and the ISO-8601 standard,\n * from 1 (January) to 12 (December). It is recommended that applications use the static values defined by this class\n * rather than the `int` value to ensure code clarity.\n *\n * This class represents a common concept that is found in many calendar systems.\n * As such, this class may be used by any calendar system that has the month-of-year\n * concept defined exactly equivalent to the ISO-8601 calendar system.\n *\n * ### Static properties of Class {@link Month}\n *\n * Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n * Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n *\n */\nexport class Month extends Temporal {\n\n    /**\n     *\n     * @param {number} value\n     * @private\n     */\n    constructor(value) {\n        super();\n        this._value = MathUtil.safeToInt(value);\n    }\n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._value;\n    }\n\n    /**\n     * Gets the textual representation, such as 'Jan' or 'December'.\n     *\n     * This returns the textual name used to identify the month-of-year.\n     * The parameters control the length of the returned text and the locale.\n     *\n     * If no textual mapping is found then the numeric value (see {@link getValue}) is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    getDisplayName(style, locale) {\n        // TODO:\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n        //eslint-disable-next-line no-unreachable\n        return new DateTimeFormatterBuilder().appendText(ChronoField.MONTH_OF_YEAR, style).toFormatter(locale).format(this);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this month-of-year can be queried for the specified field.\n     * If false, then calling the range (see {@link range}) and\n     * get (see {@link get}) methods will throw an exception.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then\n     * this method returns true.\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-of-year, false if not\n     */\n    isSupported(field) {\n        if (null === field) {\n            return false;\n        }\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as an `int`.\n     *\n     * This queries this month for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an `int`\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as a `long`.\n     *\n     * This queries this month for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * Returns the month-of-year that is the specified number of months after this one.\n     *\n     * The calculation rolls around the end of the year from December to January.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    plus(months) {\n        const amount = MathUtil.intMod(months, 12) + 12; // + 12 to make sure negative arguments are positive, the total is \"corrected\" by the next % 12\n        let newMonthVal = MathUtil.intMod((this.value() + amount), 12);\n        /* December is 12, not 0, but 12 % 12 = 0 */\n        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n        return Month.of(newMonthVal);\n    }\n\n    /**\n     * Returns the month-of-year that is the specified number of months before this one.\n     *\n     * The calculation rolls around the start of the year from January to December.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    minus(months) {\n        return this.plus(-1 * MathUtil.intMod(months, 12));\n    }\n\n    /**\n     * Gets the length of this month in days.\n     *\n     * This takes a flag to determine whether to return the length for a leap year or not.\n     *\n     * February has 28 days in a standard year and 29 days in a leap year.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the length of this month in days, from 28 to 31\n     */\n    length(leapYear) {\n        switch (this) {\n            case Month.FEBRUARY:\n                return (leapYear ? 29 : 28);\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the minimum length of this month in days.\n     *\n     * February has a minimum length of 28 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the minimum length of this month in days, from 28 to 31\n     */\n    minLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 28;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the maximum length of this month in days.\n     *\n     * February has a maximum length of 29 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the maximum length of this month in days, from 29 to 31\n     */\n    maxLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 29;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the day-of-year corresponding to the first day of this month.\n     *\n     * This returns the day-of-year that this month begins on, using the leap\n     * year flag to determine the length of February.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the day of year corresponding to the first day of this month, from 1 to 336\n     */\n    firstDayOfYear(leapYear) {\n        const leap = leapYear ? 1 : 0;\n        switch (this) {\n            case Month.JANUARY:\n                return 1;\n            case Month.FEBRUARY:\n                return 32;\n            case Month.MARCH:\n                return 60 + leap;\n            case Month.APRIL:\n                return 91 + leap;\n            case Month.MAY:\n                return 121 + leap;\n            case Month.JUNE:\n                return 152 + leap;\n            case Month.JULY:\n                return 182 + leap;\n            case Month.AUGUST:\n                return 213 + leap;\n            case Month.SEPTEMBER:\n                return 244 + leap;\n            case Month.OCTOBER:\n                return 274 + leap;\n            case Month.NOVEMBER:\n                return 305 + leap;\n            case Month.DECEMBER:\n            default:\n                return 335 + leap;\n        }\n    }\n\n    /**\n     * Gets the month corresponding to the first month of this quarter.\n     *\n     * The year can be divided into four quarters.\n     * This method returns the first month of the quarter for the base month.\n     * January, February and March return January.\n     * April, May and June return April.\n     * July, August and September return July.\n     * October, November and December return October.\n     *\n     * @return {Month} the first month of the quarter corresponding to this month, not null\n     */\n    firstMonthOfQuarter() {\n        switch (this) {\n            case Month.JANUARY:\n            case Month.FEBRUARY:\n            case Month.MARCH:\n                return Month.JANUARY;\n            case Month.APRIL:\n            case Month.MAY:\n            case Month.JUNE:\n                return Month.APRIL;\n            case Month.JULY:\n            case Month.AUGUST:\n            case Month.SEPTEMBER:\n                return Month.JULY;\n            case Month.OCTOBER:\n            case Month.NOVEMBER:\n            case Month.DECEMBER:\n            default:\n                return Month.OCTOBER;\n        }\n    }\n\n    /**\n     * Queries this month-of-year using the specified query.\n     *\n     * This queries this month-of-year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        assert(query != null, 'query() parameter must not be null', DateTimeException);\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        }\n        return super.query(query);\n    }\n\n\n\n    /**\n     * toString implementation... in JDK this is inherited from the Enum class\n     *\n     * @return {String}\n     */\n    toString() {\n        switch (this) {\n            case Month.JANUARY:\n                return 'JANUARY';\n            case Month.FEBRUARY:\n                return 'FEBRUARY';\n            case Month.MARCH:\n                return 'MARCH';\n            case Month.APRIL:\n                return 'APRIL';\n            case Month.MAY:\n                return 'MAY';\n            case Month.JUNE:\n                return 'JUNE';\n            case Month.JULY:\n                return 'JULY';\n            case Month.AUGUST:\n                return 'AUGUST';\n            case Month.SEPTEMBER:\n                return 'SEPTEMBER';\n            case Month.OCTOBER:\n                return 'OCTOBER';\n            case Month.NOVEMBER:\n                return 'NOVEMBER';\n            case Month.DECEMBER:\n                return 'DECEMBER';\n            default:\n                return 'unknown Month, value: ' + this.value();\n        }\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-of-year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the month-of-year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#MONTH_OF_YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonth);\n     * </pre>\n     *\n     * For example, given a date in May, the following are output:\n     * <pre>\n     *   dateInMay.with(JANUARY);    // four months earlier\n     *   dateInMay.with(APRIL);      // one months earlier\n     *   dateInMay.with(MAY);        // same date\n     *   dateInMay.with(JUNE);       // one month later\n     *   dateInMay.with(DECEMBER);   // seven months later\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        /* we support only ISO for now\n            if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) === false) {\n                throw new DateTimeException('Adjustment only supported on ISO date-time');\n            }\n        */\n        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n    }\n\n    /**\n     * replacement for enum values\n     * @return {Month[]}\n     */\n    static values(){\n        return MONTHS.slice();\n    }\n\n    /**\n     *\n     * @param {number} month\n     * @return {Month} not null\n     **/\n    static of(month) {\n        if (month < 1 || month > 12) {\n            assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);\n        }\n        return MONTHS[month-1];\n    }\n\n    /**\n     * Obtains an instance of {@link Month} from a temporal object.\n     *\n     * This obtains a month based on the specified temporal.\n     * A {@link TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@link Month}.\n     *\n     * The conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link Month::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {Month} the month-of-year, not null\n     * @throws DateTimeException if unable to convert to a {@link Month}\n     */\n    static from(temporal) {\n        if (temporal instanceof Month) {\n            return temporal;\n        }\n        try {\n            /* only ISO for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Month from TemporalAccessor: ' +\n                    temporal + ' of type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);\n        }\n    }\n}\n\nlet MONTHS;\n\nexport function _init() {\n    Month.JANUARY = new Month(1);\n    Month.FEBRUARY = new Month(2);\n    Month.MARCH = new Month(3);\n    Month.APRIL = new Month(4);\n    Month.MAY = new Month(5);\n    Month.JUNE = new Month(6);\n    Month.JULY = new Month(7);\n    Month.AUGUST = new Month(8);\n    Month.SEPTEMBER = new Month(9);\n    Month.OCTOBER = new Month(10);\n    Month.NOVEMBER = new Month(11);\n    Month.DECEMBER = new Month(12);\n\n    MONTHS = [\n        Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n        Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n    ];\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {Clock} from './Clock';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {LocalDate} from './LocalDate';\nimport {Month} from './Month';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalAccessor} from './temporal/TemporalAccessor';\nimport {TemporalQuery, createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {ValueRange} from './temporal/ValueRange';\nimport {Year} from './Year';\nimport {ZoneId} from './ZoneId';\n\n/**\n * A month-day in the ISO-8601 calendar system, such as `--12-03`.\n *\n * {@link MonthDay} is an immutable date-time object that represents the combination\n * of a year and month. Any field that can be derived from a month and day, such as\n * quarter-of-year, can be obtained.\n *\n * This class does not store or represent a year, time or time-zone.\n * For example, the value \"December 3rd\" can be stored in a {@link MonthDay}.\n *\n * Since a {@link MonthDay} does not possess a year, the leap day of\n * February 29th is considered valid.\n *\n * This class implements {@link TemporalAccessor} rather than {@link Temporal}.\n * This is because it is not possible to define whether February 29th is valid or not\n * without external information, preventing the implementation of plus/minus.\n * Related to this, {@link MonthDay} only provides access to query and set the fields\n * {@link MONTH_OF_YEAR} and {@link DAY_OF_MONTH}.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class MonthDay extends Temporal {\n    /**\n     * function overloading for {@link MonthDay.now}\n     *\n     * if called with 0 argument {@link MonthDay.now0} is executed,\n     *\n     * if called with 1 argument and first argument is an instance of ZoneId, then {@link MonthDay.nowZoneId} is executed,\n     *\n     * otherwise {@link MonthDay.nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @returns {MonthDay}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return MonthDay.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return MonthDay.nowZoneId(zoneIdOrClock);\n        } else {\n            return MonthDay.nowClock(zoneIdOrClock);\n        }\n    }\n    /**\n     * Obtains the current month-day from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current month-day.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {MonthDay} the current month-day using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return this.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current month-day from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current month-day.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {MonthDay} the current month-day using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        requireNonNull(zone, 'zone');\n        return this.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current month-day from the specified clock.\n     *\n     * This will query the specified clock to obtain the current month-day.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection (see {@link Clock}).\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {MonthDay} the current month-day, not null\n     */\n    static nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        const now = LocalDate.now(clock);  // called once\n        return MonthDay.of(now.month(), now.dayOfMonth());\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link MonthDay.of}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link MonthDay.ofMonthNumber} is executed,\n     *\n     * otherwise {@link MonthDay.ofNumberNumber} is executed\n     *\n     * @param {!(Month|number)} monthOrNumber\n     * @param {?number} number\n     * @returns {MonthDay}\n     */\n    static of(monthOrNumber, number) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return MonthDay.ofMonthNumber(monthOrNumber, number);\n        } else {\n            return MonthDay.ofNumberNumber(monthOrNumber, number);\n        }\n    }\n    /**\n     * Obtains an instance of {@link MonthDay}.\n     *\n     * The day-of-month must be valid for the month within a leap year.\n     * Hence, for February, day 29 is valid.\n     *\n     * For example, passing in April and day 31 will throw an exception, as\n     * there can never be April 31st in any year. By contrast, passing in\n     * February 29th is permitted, as that month-day can sometimes be valid.\n     *\n     * @param {Month} month  the month-of-year to represent, not null\n     * @param {number} dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if the value of any field is out of range\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    static ofMonthNumber(month, dayOfMonth) {\n        requireNonNull(month, 'month');\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > month.maxLength()) {\n            throw new DateTimeException('Illegal value for DayOfMonth field, value ' + dayOfMonth +\n                    ' is not valid for month ' + month.toString());\n        }\n        return new MonthDay(month.value(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay}.\n     *\n     * The day-of-month must be valid for the month within a leap year.\n     * Hence, for month 2 (February), day 29 is valid.\n     *\n     * For example, passing in month 4 (April) and day 31 will throw an exception, as\n     * there can never be April 31st in any year. By contrast, passing in\n     * February 29th is permitted, as that month-day can sometimes be valid.\n     *\n     * @param {number} month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if the value of any field is out of range\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    static ofNumberNumber(month, dayOfMonth) {\n        requireNonNull(month, 'month');\n        requireNonNull(dayOfMonth, 'dayOfMonth');\n        return MonthDay.of(Month.of(month), dayOfMonth);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link MonthDay} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link MonthDay}.\n     *\n     * The conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) and\n     * DAY_OF_MONTH (see {@link ChronoField#DAY_OF_MONTH}) fields.\n     * The extraction is only permitted if the date-time has an ISO chronology.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link MonthDay::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if unable to convert to a {@link MonthDay}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof MonthDay) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain MonthDay from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link MonthDay.parse}\n     *\n     * if called with 1 argument, then {@link MonthDay.parseString} is executed,\n     *\n     * otherwise {@link MonthDay.parseStringFormatter} is executed\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {MonthDay}\n     */\n    static parse(text, formatter) {\n        if (arguments.length === 1) {\n            return MonthDay.parseString(text);\n        } else {\n            return MonthDay.parseStringFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay} from a text string such as `--12-03`.\n     *\n     * The string must represent a valid month-day.\n     * The format is `--MM-dd`.\n     *\n     * @param {String} text  the text to parse such as \"--12-03\", not null\n     * @return {MonthDay} the parsed month-day, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseString(text) {\n        return MonthDay.parseStringFormatter(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a month-day.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {MonthDay} the parsed month-day, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseStringFormatter(text, formatter) {\n        requireNonNull(text, 'text');\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, MonthDay.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} month  the month-of-year to represent, validated from 1 to 12\n     * @param {number} dayOfMonth  the day-of-month to represent, validated from 1 to 29-31\n     * @private\n     */\n    constructor(month, dayOfMonth) {\n        super();\n        this._month = MathUtil.safeToInt(month);\n        this._day = MathUtil.safeToInt(dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the int value (see {@link Month#getValue}).\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this month-day can be queried for the specified field.\n     * If false, then calling the range (see {@link range}) and\n     * get (see {@link get}) methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link MONTH_OF_YEAR}\n     * * {@link YEAR}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-day, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This month-day is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return field.range();\n        } else if (field === ChronoField.DAY_OF_MONTH) {\n            return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-day as an `int`.\n     *\n     * This queries this month-day for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this month-day.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-day as a `long`.\n     *\n     * This queries this month-day for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this month-day.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                // alignedDOW and alignedWOM not supported because they cannot be set in with()\n                case ChronoField.DAY_OF_MONTH: return this._day;\n                case ChronoField.MONTH_OF_YEAR: return this._month;\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is valid for this month-day.\n     *\n     * This method checks whether this month and day and the input year form\n     * a valid date. This can only return false for February 29th.\n     *\n     * @param {number} year  the year to validate, an out of range value returns false\n     * @return {boolean} true if the year is valid for this month-day\n     * @see Year#isValidMonthDay(MonthDay)\n     */\n    isValidYear(year) {\n        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link MonthDay} with the month-of-year altered.\n     *\n     * This returns a month-day with the specified month.\n     * If the day-of-month is invalid for the specified month, the day will\n     * be adjusted to the last valid day-of-month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month  the month-of-year to set in the returned month-day, from 1 (January) to 12 (December)\n     * @return {MonthDay} based on this month-day with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this.with(Month.of(month));\n    }\n\n    /**\n    * Returns a copy of this {@link MonthDay} with the month-of-year altered.\n    *\n    * This returns a month-day with the specified month.\n    * If the day-of-month is invalid for the specified month, the day will\n    * be adjusted to the last valid day-of-month.\n    *\n    * This instance is immutable and unaffected by this method call.\n    *\n    * @param {Month} month  the month-of-year to set in the returned month-day, not null\n    * @return {MonthDay} based on this month-day with the requested month, not null\n    */\n    with(month) {\n        requireNonNull(month, 'month');\n        if (month.value() === this._month) {\n            return this;\n        }\n        const day = Math.min(this._day, month.maxLength());\n        return new MonthDay(month.value(), day);\n    }\n\n    /**\n     * Returns a copy of this {@link MonthDay} with the day-of-month altered.\n     *\n     * This returns a month-day with the specified day-of-month.\n     * If the day-of-month is invalid for the month, an exception is thrown.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth  the day-of-month to set in the return month-day, from 1 to 31\n     * @return {MonthDay} based on this month-day with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (dayOfMonth === this._day) {\n            return this;\n        }\n        return MonthDay.of(this._month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this month-day using the specified query.\n     *\n     * This queries this month-day using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-day.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the month and day-of-month changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH} as the fields.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonthDay.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonthDay);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this month-day with a year to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this month-day and the specified year.\n     *\n     * A month-day of February 29th will be adjusted to February 28th in the resulting\n     * date if the year is not a leap year.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year  the year to use, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDate} the local date formed from this month-day and the specified year, not null\n     * @throws DateTimeException if the year is outside the valid range of years\n     */\n    atYear(year) {\n        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this month-day to another month-day.\n     *\n     * The comparison is based first on value of the month, then on the value of the day.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        let cmp = (this._month - other.monthValue());\n        if (cmp === 0) {\n            cmp = (this._day - other.dayOfMonth());\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this month-day after the specified month-day.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {boolean} true if this is after the specified month-day\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this month-day before the specified month-day.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {boolean} true if this point is before the specified month-day\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        return this.compareTo(other) < 0;\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this month-day is equal to another month-day.\n     *\n     * The comparison is based on the time-line position of the month-day within a year.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other month-day\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof MonthDay) {\n            const other = obj;\n            return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n        }\n        return false;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this month-day as a string, such as `--12-03`.\n     *\n     * The output will be in the format `--MM-dd`:\n     *\n     * @return {String} a string representation of this month-day, not null\n     */\n    toString() {\n        return '--'\n            + (this._month < 10 ? '0' : '') + this._month\n            + (this._day < 10 ? '-0' : '-') + this._day;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this month-day as a string using the formatter.\n     *\n     * This month-day will be passed to the formatter\n     * print method (see {@link DateTimeFormatter#format}).\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted month-day string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nlet PARSER;\n\nexport function _init() {\n    PARSER = new DateTimeFormatterBuilder()\n        .appendLiteral('--')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter();\n\n    MonthDay.FROM = createTemporalQuery('MonthDay.FROM', (temporal) => {\n        return MonthDay.from(temporal);\n    });\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Clock} from './Clock';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {LocalDate} from './LocalDate';\nimport {Month} from './Month';\nimport {SignStyle} from './format/SignStyle';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalAmount} from './temporal/TemporalAmount';\nimport {TemporalField} from './temporal/TemporalField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {TemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalUnit} from './temporal/TemporalUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {ValueRange} from './temporal/ValueRange';\nimport {Year} from './Year';\nimport {ZoneId} from './ZoneId';\n\n/**\n * A year-month in the ISO-8601 calendar system, such as `2007-12`.\n *\n * {@link YearMonth} is an immutable date-time object that represents the combination\n * of a year and month. Any field that can be derived from a year and month, such as\n * quarter-of-year, can be obtained.\n *\n * This class does not store or represent a day, time or time-zone.\n * For example, the value \"October 2007\" can be stored in a {@link YearMonth}.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class YearMonth extends Temporal {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.now}\n     *\n     * if called with 0 argument {@link YearMonth.now0} is executed,\n     *\n     * if called with 1 argument and first argument is an instance of ZoneId, then {@link YearMonth.nowZoneId} is executed,\n     *\n     * otherwise {@link YearMonth.nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @returns {YearMonth}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return YearMonth.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return YearMonth.nowZoneId(zoneIdOrClock);\n        } else {\n            return YearMonth.nowClock(zoneIdOrClock);\n        }\n    }\n\n    /**\n     * Obtains the current year-month from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current year-month.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {YearMonth} the current year-month using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return YearMonth.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year-month from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current year-month.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {YearMonth} the current year-month using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        return YearMonth.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year-month from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year-month.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {YearMonth} the current year-month, not null\n     */\n    static nowClock(clock) {\n        const now = LocalDate.now(clock);\n        return YearMonth.of(now.year(), now.month());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.of}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link YearMonth.ofNumberMonth} is executed,\n     *\n     * otherwise {@link YearMonth.ofNumberNumber} is executed\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} monthOrNumber\n     * @returns {YearMonth}\n     */\n    static of(year, monthOrNumber) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return YearMonth.ofNumberMonth(year, monthOrNumber);\n        } else {\n            return YearMonth.ofNumberNumber(year, monthOrNumber);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a year and month.\n     *\n     * @param {number} year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {Month} month  the month-of-year to represent, not null\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    static ofNumberMonth(year, month) {\n        requireNonNull(month, 'month');\n        requireInstance(month, Month, 'month');\n        return YearMonth.ofNumberNumber(year, month.value());\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a year and month.\n     *\n     * @param {number} year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if either field value is invalid\n     */\n    static ofNumberNumber(year, month) {\n        requireNonNull(year, 'year');\n        requireNonNull(month, 'month');\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return new YearMonth(year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link YearMonth} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link YearMonth}.\n     *\n     * The conversion extracts the {@link ChronoField#YEAR} and\n     * {@link ChronoField#MONTH_OF_YEAR} fields.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link YearMonth::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if unable to convert to a {@link YearMonth}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof YearMonth) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain YearMonth from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.parse}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link YearMonth.parseString} is executed,\n     *\n     * otherwise {@link YearMonth.parseStringFormatter} is executed\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {YearMonth}\n     */\n    static parse(text, formatter) {\n        if (arguments.length === 1) {\n            return YearMonth.parseString(text);\n        } else {\n            return YearMonth.parseStringFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a text string such as `2007-12`.\n     *\n     * The string must represent a valid year-month.\n     * The format must be {@link yyyy-MM}.\n     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.\n     *\n     * @param {String} text  the text to parse such as \"2007-12\", not null\n     * @return {YearMonth} the parsed year-month, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseString(text) {\n        return YearMonth.parseStringFormatter(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year-month.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return the parsed year-month, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseStringFormatter(text, formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, YearMonth.FROM);\n    }\n\n\n    /**\n     * Constructor.\n     *\n     * @param {number} year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {number} month  the month-of-year to represent, validated from 1 (January) to 12 (December)\n     * @private\n     */\n    constructor(year, month) {\n        super();\n        this._year = MathUtil.safeToInt(year);\n        this._month = MathUtil.safeToInt(month);\n    }\n\n    /**\n     * function overloading for {@link YearMonth.isSupported}\n     *\n     * if called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n     *\n     * otherwise {@link YearMonth.isSupportedUnit} is executed\n     *\n     * @param {!(TemporalField|ChronoUnit)} fieldOrUnit\n     * @returns {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year-month can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link MONTH_OF_YEAR}\n     * * {@link EPOCH_MONTH}\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year-month, false if not\n     */\n    isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR ||\n                    field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year-month is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.YEAR_OF_ERA) {\n            return (this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-month as an `int`.\n     *\n     * This queries this year-month for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year-month, except {@link EPOCH_MONTH} which is too\n     * large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-month as a `long`.\n     *\n     * This queries this year-month for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year-month.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong( field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.MONTH_OF_YEAR: return this._month;\n                case ChronoField.PROLEPTIC_MONTH: return this._getProlepticMonth();\n                case ChronoField.YEAR_OF_ERA: return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR: return this._year;\n                case ChronoField.ERA: return (this._year < 1 ? 0 : 1);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    _getProlepticMonth() {\n        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), (this._month - 1));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per {@link get}.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Checks if the day-of-month is valid for this year-month.\n     *\n     * This method checks whether this year and month and the input day form\n     * a valid date.\n     *\n     * @param {number} dayOfMonth  the day-of-month to validate, from 1 to 31, invalid value returns false\n     * @return {boolean} true if the day is valid for this year-month\n     */\n    isValidDay(dayOfMonth) {\n        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n    }\n\n    /**\n     * Returns the length of the month, taking account of the year.\n     *\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days, from 28 to 31\n     */\n    lengthOfMonth() {\n        return this.month().length(this.isLeapYear());\n    }\n\n    /**\n     * Returns the length of the year.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * function overloading for {@link YearMonth.with}\n     *\n     * if called with 1 argument, then {@link YearMonth.withAdjuster} is executed,\n     *\n     * if called with 2 arguments and first argument is an instance of TemporalField, then {@link YearMonth.withFieldValue} is executed,\n     *\n     * otherwise {@link YearMonth.withYearMonth} is executed\n     *\n     * @param {!(TemporalAdjuster|TemporalField|Number)} adjusterOrFieldOrNumber\n     * @param {?number} value nullable only of first argument is an instance of TemporalAdjuster\n     * @returns {YearMonth}\n     */\n    with(adjusterOrFieldOrNumber, value) {\n        if (arguments.length === 1) {\n            return this.withAdjuster(adjusterOrFieldOrNumber);\n        } else if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField){\n            return this.withFieldValue(adjusterOrFieldOrNumber, value);\n        } else {\n            return this.withYearMonth(adjusterOrFieldOrNumber, value);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the new year and month, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {number} newYear  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {number} newMonth  the month-of-year to represent, validated not null\n     * @return the year-month, not null\n     */\n    withYearMonth(newYear, newMonth) {\n        requireNonNull(newYear);\n        requireNonNull(newMonth);\n        if (this._year === newYear && this._month === newMonth) {\n            return this;\n        }\n        return new YearMonth(newYear, newMonth);\n    }\n\n    /**\n     * Returns an adjusted copy of this year-month.\n     *\n     * This returns a new {@link YearMonth}, based on this one, with the year-month adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the year-month to the next month that\n     * Halley's comet will pass the Earth.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @return {YearMonth} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified field set to a new value.\n     *\n     * This returns a new {@link YearMonth}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year or month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link MONTH_OF_YEAR} -\n     *   Returns a {@link YearMonth} with the specified month-of-year.\n     *   The year will be unchanged.\n     * * {@link PROLEPTIC_MONTH} -\n     *   Returns a {@link YearMonth} with the specified proleptic-month.\n     *   This completely replaces the year and month of this object.\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link YearMonth} with the specified year-of-era\n     *   The month and era will be unchanged.\n     * * {@link YEAR} -\n     *   Returns a {@link YearMonth} with the specified year.\n     *   The month will be unchanged.\n     * * {@link ERA} -\n     *   Returns a {@link YearMonth} with the specified era.\n     *   The month and year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field  the field to set in the result, not null\n     * @param {number} newValue  the new value of the field in the result\n     * @return a {@link YearMonth} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withFieldValue(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            const f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year < 1 ? 1 - newValue : newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link YearMonth} with the year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year  the year to set in the returned year-month, from MIN_YEAR to MAX_YEAR\n     * @return {YearMonth} based on this year-month with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        ChronoField.YEAR.checkValidValue(year);\n        return this.withYearMonth(year, this._month);\n    }\n\n    /**\n     * Returns a copy of this {@link YearMonth} with the month-of-year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month  the month-of-year to set in the returned year-month, from 1 (January) to 12 (December)\n     * @return {YearMonth} based on this year-month with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return this.withYearMonth(this._year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.plus}\n     *\n     * if called with 1 arguments, then {@link YearMonth.plusAmount} is executed.\n     *\n     * Otherwise {@link YearMonth.plusAmountUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit nullable only if first argument is an instance of TemporalAmount\n     * @returns {YearMonth}\n     */\n    plus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.plusAmount(amountOrNumber);\n        } else {\n            return this.plusAmountUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period added.\n     *\n     * This method returns a new year-month based on this year-month with the specified period added.\n     * The adder is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to add, not null\n     * @return {YearMonth} based on this year-month with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {number} amountToAdd\n     * @param {TemporalUnit} unit\n     * @return {YearMonth} based on this year-month with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd  the years to add, may be negative\n     * @return {YearMonth} based on this year-month with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return this.withYearMonth(newYear, this._month);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in months added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd  the months to add, may be negative\n     * @return {YearMonth} based on this year-month with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        const monthCount = (this._year * 12) + (this._month - 1);\n        const calcMonths = monthCount + monthsToAdd;\n        const newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        const newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return this.withYearMonth(newYear, newMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.minus}\n     *\n     * if called with 1 arguments, then {@link YearMonth.minusAmount} is executed.\n     *\n     * Otherwise {@link YearMonth.minusAmountUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit\n     * @returns {YearMonth}\n     */\n    minus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusAmount(amountOrNumber);\n        } else {\n            return this.minusAmountUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period subtracted.\n     *\n     * This method returns a new year-month based on this year-month with the specified period subtracted.\n     * The subtractor is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to subtract, not null\n     * @return {YearMonth} based on this year-month with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {number} amountToSubtract  the amount to subtract, not null\n     * @param {TemporalUnit} unit\n     * @return {YearMonth} based on this year-month with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        return (amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusAmountUnit(MathUtil.MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract  the years to subtract, may be negative\n     * @return {YearMonth} based on this year-month with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in months subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract  the months to subtract, may be negative\n     * @return {YearMonth} based on this year-month with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    minusMonths(monthsToSubtract) {\n        return (monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year-month using the specified query.\n     *\n     * This queries this year-month using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year-month.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year and month changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#PROLEPTIC_MONTH} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYearMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisYearMonth);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, Temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n    }\n\n    /**\n     * Calculates the period between this year-month and another year-month in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two year-months in terms of a single unit.\n     * The start and end points are `this` and the specified year-month.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link YearMonth}.\n     * For example, the period in years between two year-months can be calculated\n     * using {@link startYearMonth.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two year-months.\n     * For example, the period in decades between 2012-06 and 2032-05\n     * will only be one decade as it is one month short of two decades.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, YEARS);   // this method\n     *   dateTime.plus(YEARS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end year-month, which is converted to a {@link YearMonth}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this year-month and the end year-month\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        requireInstance(endExclusive, Temporal, 'endExclusive');\n        requireInstance(unit, TemporalUnit, 'unit');\n\n        const end = YearMonth.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();  // no overflow\n            switch (unit) {\n                case ChronoUnit.MONTHS: return monthsUntil;\n                case ChronoUnit.YEARS: return monthsUntil / 12;\n                case ChronoUnit.DECADES: return monthsUntil / 120;\n                case ChronoUnit.CENTURIES: return monthsUntil / 1200;\n                case ChronoUnit.MILLENNIA: return monthsUntil / 12000;\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year-month with a day-of-month to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year-month and the specified day-of-month.\n     *\n     * The day-of-month value must be valid for the year-month.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {number} dayOfMonth  the day-of-month to use, from 1 to 31\n     * @return {LocalDate} the date formed from this year-month and the specified day, not null\n     * @throws DateTimeException if the day is invalid for the year-month\n     * @see #isValidDay(int)\n     */\n    atDay(dayOfMonth) {\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a {@link LocalDate} at the end of the month.\n     *\n     * This returns a {@link LocalDate} based on this year-month.\n     * The day-of-month is set to the last valid day of the month, taking\n     * into account leap years.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atEndOfMonth();\n     * </pre>\n     *\n     * @return {LocalDate} the last valid date of this year-month, not null\n     */\n    atEndOfMonth() {\n        return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year-month to another year-month.\n     *\n     * The comparison is based first on the value of the year, then on the value of the month.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, YearMonth, 'other');\n        let cmp = (this._year - other.year());\n        if (cmp === 0) {\n            cmp = (this._month - other.monthValue());\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this year-month after the specified year-month.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {boolean} true if this is after the specified year-month\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this year-month before the specified year-month.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {boolean} true if this point is before the specified year-month\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this year-month is equal to another year-month.\n     *\n     * The comparison is based on the time-line position of the year-months.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other year-month\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof YearMonth) {\n            const other = obj;\n            return this.year() === other.year() && this.monthValue() === other.monthValue();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this year-month as a string, such as `2007-12`.\n     *\n     * The output will be in the format {@link yyyy-MM}:\n     *\n     * @return {String} a string representation of this year-month, not null\n     */\n    toString() {\n        return PARSER.format(this);\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this year-month as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted year-month string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nlet PARSER;\n\nexport function _init() {\n\n    PARSER = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .toFormatter();\n\n    YearMonth.FROM = createTemporalQuery('YearMonth.FROM', (temporal) => {\n        return YearMonth.from(temporal);\n    });\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\nimport {requireNonNull, requireInstance} from './assert';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Clock} from './Clock';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {LocalDate} from './LocalDate';\nimport {Month} from './Month';\nimport {MonthDay} from './MonthDay';\nimport {SignStyle} from './format/SignStyle';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalAccessor} from './temporal/TemporalAccessor';\nimport {TemporalAmount} from './temporal/TemporalAmount';\nimport {TemporalField} from './temporal/TemporalField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {TemporalQuery, createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalUnit} from './temporal/TemporalUnit';\nimport {YearConstants} from './YearConstants';\nimport {YearMonth} from './YearMonth';\nimport {ZoneId} from './ZoneId';\n\n\n/**\n * A year in the ISO-8601 calendar system, such as `2007`.\n *\n * {@link Year} is an immutable date-time object that represents a year.\n * Any field that can be derived from a year can be obtained.\n *\n * **Note that years in the ISO chronology only align with years in the\n * Gregorian-Julian system for modern years. Parts of Russia did not switch to the\n * modern Gregorian/ISO rules until 1920.\n * As such, historical years must be treated with caution.**\n *\n * This class does not store or represent a month, day, time or time-zone.\n * For example, the value \"2007\" can be stored in a {@link Year}.\n *\n * Years represented by this class follow the ISO-8601 standard and use\n * the proleptic numbering system. Year 1 is preceded by year 0, then by year -1.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * Year.MIN_VALUE = -999.999;\n *\n * The minimum supported year. Theoretically the minimum could be -28.542.4812 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MIN_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n * Year.MAX_VALUE = 999.999;\n *\n * The maximum supported year. Theoretically the maximum could be 285.428.751 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MAX_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n */\nexport class Year extends Temporal {\n\n    /**\n     *\n     * @param {number} value\n     * @private\n     */\n    constructor(value) {\n        super();\n        this._year = MathUtil.safeToInt(value);\n    }\n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._year;\n    }\n\n    /**\n     * function overloading for {@link Year.now}\n     *\n     * if called without arguments, then {@link Year.now0} is executed.\n\n     * if called with 1 arguments and first argument is an instance of ZoneId, then {@link Year.nowZoneId} is executed.\n     *\n     * Otherwise {@link Year.nowClock} is executed.\n     *\n     * @param {!(ZoneId|Clock)} zoneIdOrClock\n     * @returns {Year}\n     */\n    static now(zoneIdOrClock = undefined) {\n        if (zoneIdOrClock === undefined) {\n            return Year.now0();\n        } else if (zoneIdOrClock instanceof ZoneId) {\n            return Year.nowZoneId(zoneIdOrClock);\n        } else {\n            return Year.nowClock(zoneIdOrClock);\n        }\n    }\n\n    /**\n     * Obtains the current year from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current year.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {Year} the current year using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return Year.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current year.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {Year} the current year using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        requireNonNull(zone, 'zone');\n        requireInstance(zone, ZoneId, 'zone');\n        return Year.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {Year} the current year, not null\n     */\n    static nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        requireInstance(clock, Clock, 'clock');\n        const now = LocalDate.now(clock);  // called once\n        return Year.of(now.year());\n    }\n    /**\n     * Obtains an instance of {@link Year}.\n     *\n     * This method accepts a year value from the proleptic ISO calendar system.\n     *\n     * * The year 2AD/CE is represented by 2.\n     * * The year 1AD/CE is represented by 1.\n     * * The year 1BC/BCE is represented by 0.\n     * * The year 2BC/BCE is represented by -1.\n     *\n     * @param {Number} isoYear  the ISO proleptic year to represent, from {@link MIN_VALUE} to {@link MAX_VALUE}\n     * @return {Year} the year, not null\n     * @throws DateTimeException if the field is invalid\n     */\n    static of(isoYear) {\n        requireNonNull(isoYear, 'isoYear');\n        ChronoField.YEAR.checkValidValue(isoYear);\n        return new Year(isoYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Year} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link Year}.\n     *\n     * The conversion extracts the {@link ChronoField#YEAR} field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link Year::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {Year} the year, not null\n     * @throws DateTimeException if unable to convert to a {@link Year}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof Year) {\n            return temporal;\n        }\n        try {\n            /* TODO: we support only ISO for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return Year.of(temporal.get(ChronoField.YEAR));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Year from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Year.parse}\n     *\n     * if called with 1 argument, then {@link Year.parseText} is executed.\n     *\n     * Otherwise {@link Year.parseTextFormatter} is executed.\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {Year}\n     */\n    static parse(text, formatter) {\n        if (arguments.length <= 1) {\n            return Year.parseText(text);\n        } else {\n            return Year.parseTextFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link Year} from a text string such as `2007`.\n     *\n     * The string must represent a valid year.\n     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.\n     *\n     * @param {String} text  the text to parse such as \"2007\", not null\n     * @return {Year} the parsed year, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseText(text) {\n        requireNonNull(text, 'text');\n        return Year.parse(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link Year} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {Year} the parsed year, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseTextFormatter(text, formatter = PARSER) {\n        requireNonNull(text, 'text');\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, Year.FROM);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} year  the year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeap(year) {\n        return ((MathUtil.intMod(year, 4) === 0) && ((MathUtil.intMod(year, 100) !== 0) || (MathUtil.intMod(year, 400) === 0)));\n    }\n\n    /**\n     * function overloading for {@link YearMonth.isSupported}\n     *\n     * if called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n     *\n     * otherwise {@link YearMonth.isSupportedUnit} is executed\n     *\n     * @param {!(TemporalField|ChronoUnit)} fieldOrUnit\n     * @returns {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year, false if not\n     */\n    isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (this.isSupported(field)) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year as an `int`.\n     *\n     * This queries this year for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year as a `long`.\n     *\n     * This queries this year for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA: return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR: return this._year;\n                case ChronoField.ERA: return (this._year < 1 ? 0 : 1);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeap() {\n        return Year.isLeap(this._year);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.with}\n     *\n     * if called with 2 arguments and first argument is an instance of TemporalField, then {@link Year.withFieldValue} is executed,\n\n     * otherwise {@link Year.withAdjuster} is executed,\n     *\n     * @param {!(TemporalAdjuster|TemporalField|Number)} adjusterOrFieldOrNumber\n     * @param {?number} value nullable only of first argument is an instance of TemporalAdjuster\n     * @returns {Year}\n     */\n    with(adjusterOrFieldOrNumber, value) {\n        if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField) {\n            return this.withFieldValue(adjusterOrFieldOrNumber, value);\n        } else {\n            return this.withAdjuster(adjusterOrFieldOrNumber);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this year.\n     *\n     * This returns a new {@link Year}, based on this one, with the year adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @returns {Year} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this year with the specified field set to a new value.\n     *\n     * This returns a new {@link Year}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link Year} with the specified year-of-era\n     *   The era will be unchanged.\n     * * {@link YEAR} -\n     *   Returns a {@link Year} with the specified year.\n     *   This completely replaces the date and is equivalent to {@link of}.\n     * * {@link ERA} -\n     *   Returns a {@link Year} with the specified era.\n     *   The year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field  the field to set in the result, not null\n     * @param {number} newValue  the new value of the field in the result\n     * @returns {Year} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withFieldValue(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA:\n                    return Year.of((this._year < 1 ? 1 - newValue : newValue));\n                case ChronoField.YEAR:\n                    return Year.of(newValue);\n                case ChronoField.ERA:\n                    return (this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * function overloading for {@link Year.plus}\n     *\n     * if called with 1 arguments, then {@link Year.plusAmount} is executed.\n     *\n     * Otherwise {@link Year.plusAmountToAddUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit nullable only if first argument is an instance of TemporalAmount\n     * @returns {Year}\n     */\n    plus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.plusAmount(amountOrNumber);\n        } else {\n            return this.plusAmountToAddUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year with the specified period added.\n     *\n     * This method returns a new year based on this year with the specified period added.\n     * The adder is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to add, not null\n     * @return {Year} based on this year with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {number} amountToAdd\n     * @param {TemporalUnit} unit\n     * @return {Year} based on this year with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountToAddUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year with the specified number of years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd  the years to add, may be negative\n     * @return {Year} based on this year with the period added, not null\n     * @throws DateTimeException if the result exceeds the supported year range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Year.minus}\n     *\n     * if called with 1 argument, then {@link Year.minusAmount} is executed.\n     *\n     * Otherwise {@link Year.minusAmountToSubtractUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit\n     * @returns {Year}\n     */\n    minus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusAmount(amountOrNumber);\n        } else {\n            return this.minusAmountToSubtractUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year with the specified period subtracted.\n     *\n     * This method returns a new year based on this year with the specified period subtracted.\n     * The subtractor is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to subtract, not null\n     * @return {Year} based on this year with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {number} amountToSubtract  the amount to subtract, not null\n     * @param {TemporalUnit} unit\n     * @return {Year} based on this year with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountToSubtractUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        return (amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plus(MathUtil.MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plus(-amountToSubtract, unit));\n    }\n\n    /**\n     * Returns a copy of this year with the specified number of years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract  the years to subtract, may be negative\n     * @return {Year} based on this year with the period subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported year range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYear.adjustInto(temporal);\n     *   temporal = temporal.with(thisYear);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n         if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n         throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n         }*/\n        return temporal.with(ChronoField.YEAR, this._year);\n    }\n\n    /**\n     * Checks if the month-day is valid for this year.\n     *\n     * This method checks whether this year and the input month and day form\n     * a valid date.\n     *\n     * @param {MonthDay} monthDay  the month-day to validate, null returns false\n     * @return {boolean} true if the month and day are valid for this year\n     */\n    isValidMonthDay(monthDay) {\n        return monthDay != null && monthDay.isValidYear(this._year);\n    }\n\n    /**\n     * Gets the length of this year in days.\n     *\n     * @return {number} the length of this year in days, 365 or 366\n     */\n    length() {\n        return this.isLeap() ? 366 : 365;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year with a day-of-year to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year and the specified day-of-year.\n     *\n     * The day-of-year value 366 is only valid in a leap year.\n     *\n     * @param {number} dayOfYear  the day-of-year to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified date of year, not null\n     * @throws DateTimeException if the day of year is zero or less, 366 or greater or equal\n     *  to 366 and this is not a leap year\n     */\n    atDay(dayOfYear) {\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * function overloading for {@link Year.atMonth}\n     *\n     * if called with 1 arguments and first argument is instance of Month, then {@link Year.atMonthMonth} is executed.\n     *\n     * Otherwise {@link Year.atMonthNumber} is executed.\n     *\n     * @param {Month|number} monthOrNumber\n     * @returns {YearMonth}\n     */\n    atMonth(monthOrNumber) {\n        if (arguments.length === 1 && monthOrNumber instanceof Month) {\n            return this.atMonthMonth(monthOrNumber);\n        } else {\n            return this.atMonthNumber(monthOrNumber);\n        }\n    }\n\n    /**\n     * Combines this year with a month to create a {@link YearMonth}.\n     *\n     * This returns a {@link YearMonth} formed from this year and the specified month.\n     * All possible combinations of year and month are valid.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {Month} month  the month-of-year to use, not null\n     * @return {YearMonth} the year-month formed from this year and the specified month, not null\n     */\n    atMonthMonth(month) {\n        requireNonNull(month, 'month');\n        requireInstance(month, Month, 'month');\n        return YearMonth.of(this._year, month);\n    }\n\n    /**\n     * Combines this year with a month to create a {@link YearMonth}.\n     *\n     * This returns a {@link YearMonth} formed from this year and the specified month.\n     * All possible combinations of year and month are valid.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {number} month  the month-of-year to use, from 1 (January) to 12 (December)\n     * @return {YearMonth} the year-month formed from this year and the specified month, not null\n     * @throws DateTimeException if the month is invalid\n     */\n    atMonthNumber(month) {\n        requireNonNull(month, 'month');\n        return YearMonth.of(this._year, month);\n    }\n\n    /**\n     * Combines this year with a month-day to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year and the specified month-day.\n     *\n     * A month-day of February 29th will be adjusted to February 28th in the resulting\n     * date if the year is not a leap year.\n     *\n     * @param {MonthDay} monthDay  the month-day to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified month-day, not null\n     */\n    atMonthDay(monthDay) {\n        requireNonNull(monthDay, 'monthDay');\n        requireInstance(monthDay, MonthDay, 'monthDay');\n        return monthDay.atYear(this._year);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year using the specified query.\n     *\n     * This queries this year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query()');\n        requireInstance(query, TemporalQuery, 'query()');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.YEARS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year to another year.\n     *\n     * The comparison is based on the value of the year.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year - other._year;\n    }\n\n    /**\n     * Is this year after the specified year.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {boolean} true if this is after the specified year\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year > other._year;\n    }\n\n    /**\n     * Is this year before the specified year.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {boolean} true if this point is before the specified year\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year < other._year;\n    }\n    /**\n     * Outputs this year as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted year string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Checks if this year is equal to the specified {@link Year}.\n     *\n     * The comparison is based on the value\n     *\n     * @param {*} otherYear - the other year, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherYear) {\n        if (this === otherYear) {\n            return true;\n        }\n        if (otherYear instanceof Year) {\n            return this.value() === otherYear.value();\n        }\n        return false;\n    }\n    /**\n     * Outputs this year as a string.\n     *\n     * @return {String} a string representation of this year, not null\n     */\n    toString() {\n        return '' + this._year;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nlet PARSER;\n\nexport function _init() {\n\n    Year.MIN_VALUE = YearConstants.MIN_VALUE;\n    Year.MAX_VALUE = YearConstants.MAX_VALUE;\n\n    PARSER = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .toFormatter();\n\n    Year.FROM = createTemporalQuery('Year.FROM', (temporal) => {\n        return Year.from(temporal);\n    });\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * Strategy for adjusting a temporal object.\n *\n * Adjusters are a key tool for modifying temporal objects.\n * They exist to externalize the process of adjustment, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be an adjuster that sets the date avoiding weekends, or one that\n * sets the date to the last day of the month.\n *\n * There are two equivalent ways of using a {@link TemporalAdjuster}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link Temporal#with}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisAdjuster.adjustInto(temporal);\n *   temporal = temporal.with(thisAdjuster);\n * </pre>\n * It is recommended to use the second approach, {@link with},\n * as it is a lot clearer to read in code.\n *\n * See {@link TemporalAdjusters} for a standard set of adjusters, including finding the\n * last day of the month.\n * Adjusters may also be defined by applications.\n *\n * ### Specification for implementors\n *\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalAdjuster {\n\n    /**\n     * Adjusts the specified temporal object.\n     *\n     * This adjusts the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be an adjuster that sets the date avoiding weekends, or one that\n     * sets the date to the last day of the month.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisAdjuster.adjustInto(temporal);\n     *   temporal = temporal.with(thisAdjuster);\n     * </pre>\n     * It is recommended to use the second approach, {@link with},\n     * as it is a lot clearer to read in code.\n     *\n     * ### Specification for implementors\n     *\n     * The implementation must take the input object and adjust it.\n     * The implementation defines the logic of the adjustment and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the adjustment.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @return {Temporal} an object of the same observable type with the adjustment made, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     *\n     * @abstract\n     */\n    // eslint-disable-next-line no-unused-vars\n    adjustInto(temporal){\n        abstractMethodFail('adjustInto');\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {IllegalStateException} from '../errors';\n\nimport {TemporalAdjuster} from './TemporalAdjuster';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {MathUtil} from '../MathUtil';\n\n/**\n * Common implementations of {@link TemporalAdjuster}.\n *\n * This class provides common implementations of {@link TemporalAdjuster}.\n * They are especially useful to document the intent of business logic and\n * often link well to requirements.\n * For example, these two pieces of code do the same thing, but the second\n * one is clearer (assuming that there is a static import of this class):\n * <pre>\n *  // direct manipulation\n *  date.withDayOfMonth(1).plusMonths(1).minusDays(1);\n *  // use of an adjuster from this class\n *  date.with(lastDayOfMonth());\n * </pre>\n * There are two equivalent ways of using a {@link TemporalAdjuster}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link Temporal#with}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = adjuster.adjustInto(dateTime);\n *   dateTime = dateTime.with(adjuster);\n * </pre>\n * It is recommended to use the second approach, {@link with},\n * as it is a lot clearer to read in code.\n *\n * ### Specification for implementors\n *\n * This is a thread-safe utility class.\n * All returned adjusters are immutable and thread-safe.\n *\n * The JDK 8 ofDateAdjuster(UnaryOperator) method is not backported.\n */\nexport class TemporalAdjusters {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of month' adjuster, which returns a new date set to\n     * the first day of the current month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-01.\n     * * The input 2011-02-15 will return 2011-02-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-month adjuster, not null\n     */\n    static firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'last day of month' adjuster, which returns a new date set to\n     * the last day of the current month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-31.\n     * * The input 2011-02-15 will return 2011-02-28.\n     * * The input 2012-02-15 will return 2012-02-29 (leap year).\n     * * The input 2011-04-15 will return 2011-04-30.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_MONTH).getMaximum();\n     *  temporal.with(DAY_OF_MONTH, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-month adjuster, not null\n     */\n    static lastDayOfMonth() {\n        return Impl.LAST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'first day of next month' adjuster, which returns a new date set to\n     * the first day of the next month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-02-01.\n     * * The input 2011-02-15 will return 2011-03-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1).plus(1, MONTHS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextMonth() {\n        return Impl.FIRST_DAY_OF_NEXT_MONTH;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of year' adjuster, which returns a new date set to\n     * the first day of the current year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-01.\n     * * The input 2011-02-15 will return 2011-01-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-year adjuster, not null\n     */\n    static firstDayOfYear() {\n        return Impl.FIRST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'last day of year' adjuster, which returns a new date set to\n     * the last day of the current year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-12-31.\n     * * The input 2011-02-15 will return 2011-12-31.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_YEAR).getMaximum();\n     *  temporal.with(DAY_OF_YEAR, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-year adjuster, not null\n     */\n    static lastDayOfYear() {\n        return Impl.LAST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'first day of next year' adjuster, which returns a new date set to\n     * the first day of the next year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2012-01-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1).plus(1, YEARS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextYear() {\n        return Impl.FIRST_DAY_OF_NEXT_YEAR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the first in month adjuster, which returns a new date\n     * in the same month with the first matching day-of-week.\n     * This is used for expressions like 'first Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (MONDAY) will return 2011-12-05.\n     * * The input 2011-12-15 for (FRIDAY) will return 2011-12-02.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static firstInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(1, dayOfWeek);\n    }\n\n    /**\n     * Returns the last in month adjuster, which returns a new date\n     * in the same month with the last matching day-of-week.\n     * This is used for expressions like 'last Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (MONDAY) will return 2011-12-26.\n     * * The input 2011-12-15 for (FRIDAY) will return 2011-12-30.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static lastInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(-1, dayOfWeek);\n    }\n\n    /**\n     * Returns the day-of-week in month adjuster, which returns a new date\n     * in the same month with the ordinal day-of-week.\n     * This is used for expressions like the 'second Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.\n     * * The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.\n     * * The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.\n     * * The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.\n     * * The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.\n     * * The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).\n     * * The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).\n     * * The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).\n     * * The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).\n     *\n     * For a positive or zero ordinal, the algorithm is equivalent to finding the first\n     * day-of-week that matches within the month and then adding a number of weeks to it.\n     * For a negative ordinal, the algorithm is equivalent to finding the last\n     * day-of-week that matches within the month and then subtracting a number of weeks to it.\n     * The ordinal number of weeks is not validated and is interpreted leniently\n     * according to this algorithm. This definition means that an ordinal of zero finds\n     * the last matching day-of-week in the previous month.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {Number} ordinal  the week within the month, unbounded but typically from -5 to 5\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the day-of-week in month adjuster, not null\n     */\n    static dayOfWeekInMonth(ordinal, dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(ordinal, dayOfWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the next day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the next day-of-week adjuster, not null\n     */\n    static next(dayOfWeek) {\n        return new RelativeDayOfWeek(2, dayOfWeek);\n    }\n\n    /**\n     * Returns the next-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the next-or-same day-of-week adjuster, not null\n     */\n    static nextOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(0, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the previous day-of-week adjuster, not null\n     */\n    static previous(dayOfWeek) {\n        return new RelativeDayOfWeek(3, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the previous-or-same day-of-week adjuster, not null\n     */\n    static previousOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(1, dayOfWeek);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Enum implementing the adjusters.\n */\nclass Impl extends TemporalAdjuster {\n\n    /**\n     *\n     * @param ordinal\n     * @private\n     */\n    constructor(ordinal) {\n        super();\n        this._ordinal = ordinal;\n    }\n\n    adjustInto(temporal) {\n        switch (this._ordinal) {\n            case 0: return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            case 1: return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            case 2: return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n            case 3: return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n            case 4: return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n            case 5: return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n        }\n        throw new IllegalStateException('Unreachable');\n    }\n\n}\n\n/** First day of month adjuster. */\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\n/** Last day of month adjuster. */\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\n/** First day of year adjuster. */\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\n/** Last day of year adjuster. */\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\n\n\n/**\n * Class implementing day-of-week in month adjuster.\n */\nclass DayOfWeekInMonth extends TemporalAdjuster {\n\n    /**\n     *\n     * @param ordinal\n     * @param dow\n     * @private\n     */\n    constructor(ordinal, dow) {\n        super();\n        this._ordinal = ordinal;\n        this._dowValue = dow.value();\n    }\n\n    adjustInto(temporal) {\n        if (this._ordinal >= 0) {\n            const temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            const curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let dowDiff = MathUtil.intMod((this._dowValue - curDow + 7), 7);\n            dowDiff += (this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(dowDiff, ChronoUnit.DAYS);\n        } else {\n            const temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            const curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let daysDiff = this._dowValue - curDow;\n            daysDiff = (daysDiff === 0 ? 0 : (daysDiff > 0 ? daysDiff - 7 : daysDiff));\n            daysDiff -= (-this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n\n/**\n * Implementation of next, previous or current day-of-week.\n */\nclass RelativeDayOfWeek extends TemporalAdjuster {\n\n    /**\n     *\n     * @param relative\n     * @param dayOfWeek\n     * @private\n     */\n    constructor(relative, dayOfWeek) {\n        super();\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        /** Whether the current date is a valid answer. */\n        this._relative = relative;\n        /** The day-of-week value, from 1 to 7. */\n        this._dowValue = dayOfWeek.value();\n    }\n\n    adjustInto(temporal) {\n        const calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        if (this._relative < 2 && calDow === this._dowValue) {\n            return temporal;\n        }\n        if ((this._relative & 1) === 0) {\n            const daysDiff = calDow - this._dowValue;\n            return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        } else {\n            const daysDiff = this._dowValue - calDow;\n            return temporal.minus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\nimport {requireNonNull} from '../assert';\nimport {DateTimeException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {DayOfWeek} from '../DayOfWeek';\nimport {LocalDate} from '../LocalDate';\nimport {Month} from '../Month';\nimport {Year} from '../Year';\n\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ResolverStyle} from '../format/ResolverStyle';\nimport {TemporalAdjusters} from '../temporal/TemporalAdjusters';\n\nexport class IsoChronology extends Enum{\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} prolepticYear - the ISO proleptic year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeapYear(prolepticYear) {\n        return ((prolepticYear & 3) === 0) && ((prolepticYear % 100) !== 0 || (prolepticYear % 400) === 0);\n    }\n\n    /**\n     * Updates the map of field-values during resolution.\n     *\n     * @param {EnumMap} fieldValues  the fieldValues map to update, not null\n     * @param {ChronoField} field  the field to update, not null\n     * @param {number} value  the value to update, not null\n     * @throws DateTimeException if a conflict occurs\n     */\n    _updateResolveMap(fieldValues, field, value) {\n        // TODO: this function is in Chronology in threetenbp, maybe needs to be moved?\n        requireNonNull(fieldValues, 'fieldValues');\n        requireNonNull(field, 'field');\n        const current = fieldValues.get(field);\n        if (current != null && current !== value) {\n            throw new DateTimeException('Invalid state, field: ' + field + ' ' + current + ' conflicts with ' + field + ' ' + value);\n        }\n        fieldValues.put(field, value);\n    }\n\n    resolveDate(fieldValues, resolverStyle) {\n        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n        }\n\n        // normalize fields\n        const prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n        if (prolepticMonth != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n            }\n            this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n        }\n\n        // eras\n        const yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n        if (yoeLong != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n            }\n            const era = fieldValues.remove(ChronoField.ERA);\n            if (era == null) {\n                const year = fieldValues.get(ChronoField.YEAR);\n                if (resolverStyle === ResolverStyle.STRICT) {\n                    // do not invent era if strict, but do cross-check with year\n                    if (year != null) {\n                        this._updateResolveMap(fieldValues, ChronoField.YEAR, (year > 0 ? yoeLong: MathUtil.safeSubtract(1, yoeLong)));\n                    } else {\n                        // reinstate the field removed earlier, no cross-check issues\n                        fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n                    }\n                } else {\n                    // invent era\n                    this._updateResolveMap(fieldValues, ChronoField.YEAR, (year == null || year > 0 ? yoeLong: MathUtil.safeSubtract(1, yoeLong)));\n                }\n            } else if (era === 1) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n            } else if (era === 0) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n            } else {\n                throw new DateTimeException('Invalid value for era: ' + era);\n            }\n        } else if (fieldValues.containsKey(ChronoField.ERA)) {\n            ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));  // always validated\n        }\n\n        // build date\n        if (fieldValues.containsKey(ChronoField.YEAR)) {\n            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    const moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n                    let dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const months = moy - 1;\n                        const days = dom - 1;\n                        return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n                    } else if (resolverStyle === ResolverStyle.SMART){\n                        ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n                        if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n                            dom = Math.min(dom, 30);\n                        } else if (moy === 2) {\n                            dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n                        }\n                        return LocalDate.of(y, moy, dom);\n                    } else {\n                        return LocalDate.of(y, moy, dom);\n                    }\n                }\n                /*\n                if (fieldValues.containsKey(ALIGNED_WEEK_OF_MONTH)) {\n                    if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_MONTH)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int ad = ALIGNED_DAY_OF_WEEK_IN_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                    if (fieldValues.containsKey(DAY_OF_WEEK)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(DAY_OF_WEEK), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int dow = DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(DAY_OF_WEEK));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusWeeks(aw - 1).with(nextOrSame(DayOfWeek.of(dow)));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                }\n*/\n            }\n            if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n                const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                if (resolverStyle === ResolverStyle.LENIENT) {\n                    const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n                    return LocalDate.ofYearDay(y, 1).plusDays(days);\n                }\n                const doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n                return LocalDate.ofYearDay(y, doy);\n            }\n            if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    const aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    const ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                    const date = LocalDate.of(y, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== y) {\n                        throw new DateTimeException('Strict mode rejected date parsed to a different year');\n                    }\n                    return date;\n                }\n                if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    const aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    const dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n                    const date = LocalDate.of(y, 1, 1).plusWeeks(aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== y) {\n                        throw new DateTimeException('Strict mode rejected date parsed to a different month');\n                    }\n                    return date;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Obtains an ISO local date from another date-time object.\n     * <p>\n     * This is equivalent to {@link LocalDate#from(TemporalAccessor)}.\n     *\n     * @param temporal  the date-time object to convert, not null\n     * @return the ISO local date, not null\n     * @throws DateTimeException if unable to create the date\n     */\n    date(temporal) {\n        return LocalDate.from(temporal);\n    }\n\n}\n\nexport function _init() {\n    IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {Instant} from '../Instant';\nimport {LocalDate} from '../LocalDate';\nimport {MathUtil} from '../MathUtil';\n\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nexport class ChronoZonedDateTime  extends Temporal {\n    query(query) {\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone();\n        } else if (query === TemporalQueries.chronology()) {\n            return this.toLocalDate().chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.offset()) {\n            return this.offset();\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Converts this date-time to an {@link Instant}.\n     *\n     * This returns an {@link Instant} representing the same point on the\n     * time-line as this date-time. The calculation combines the\n     * local date-time (see {@link toLocalDateTime}) and\n     * offset (see {@link getOffset}).\n     *\n     * @return {Instant} an {@link Instant} representing the same instant, not null\n     */\n    toInstant() {\n        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * This uses the local date-time (see {@link toLocalDateTime}) and\n     * offset (see {@link getOffset}) to calculate the epoch-second value,\n     * which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond() {\n        const epochDay = this.toLocalDate().toEpochDay();\n        let secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= this.offset().totalSeconds();\n        return secs;\n    }\n\n    /**\n      * Compares this date-time to another date-time, including the chronology.\n      *\n      * The comparison is based first on the instant, then on the local date-time,\n      * then on the zone ID, then on the chronology.\n      * It is \"consistent with equals\", as defined by {@link Comparable}.\n      *\n      * If all the date-time objects being compared are in the same chronology, then the\n      * additional chronology stage is not required.\n      *\n      * @param {ChronoZonedDateTime} other - the other date-time to compare to, not null\n      * @return {number} the comparator value, negative if less, positive if greater\n      */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        let cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n                if (cmp === 0) {\n                    cmp = strcmp(this.zone().id(), other.zone().id());\n                    // we only support iso for now\n                    //if (cmp === 0) {\n                    //    cmp = toLocalDate().getChronology().compareTo(other.toLocalDate().getChronology());\n                    //}\n                }\n            }\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().isAfter(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this is after the specified date-time\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().isBefore(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this point is before the specified date-time\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} and {@link equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().equals(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if the instant equals the instant of the specified date-time\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        return this.toEpochSecond() === other.toEpochSecond() &&\n                this.toLocalTime().nano() === other.toLocalTime().nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * The comparison is based on the offset date-time and the zone.\n     * To compare for the same instant on the time-line, use {@link compareTo}.\n     * Only objects of type {@link ChronoZoneDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ChronoZonedDateTime) {\n            return this.compareTo(other) === 0;\n        }\n        return false;\n    }\n\n}\n\nfunction strcmp(a, b){\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException, IllegalArgumentException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {Clock} from './Clock';\nimport {Instant} from './Instant';\nimport {LocalDate} from './LocalDate';\nimport {LocalDateTime} from './LocalDateTime';\nimport {LocalTime} from './LocalTime';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\nimport {ChronoZonedDateTime} from './chrono/ChronoZonedDateTime';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\n/**\n * A date-time with a time-zone in the ISO-8601 calendar system,\n * such as `2007-12-03T10:15:30+01:00 Europe/Paris`.\n *\n * `ZonedDateTime` is an immutable representation of a date-time with a time-zone.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * and a time-zone, with a zone offset used to handle ambiguous local date-times.\n * For example, the value\n * '2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone'\n * can be stored in a {@link ZonedDateTime}.\n *\n * This class handles conversion from the local time-line of {@link LocalDateTime}\n * to the instant time-line of {@link Instant}.\n * The difference between the two time-lines is the offset from UTC/Greenwich,\n * represented by a {@link ZoneOffset}.\n *\n * Converting between the two time-lines involves calculating the offset using the\n * {@link ZoneRules} rules accessed from the {@link ZoneId}.\n * Obtaining the offset for an instant is simple, as there is exactly one valid\n * offset for each instant. By contrast, obtaining the offset for a local date-time\n * is not straightforward. There are three cases:\n *\n * * Normal, with one valid offset. For the vast majority of the year, the normal\n *   case applies, where there is a single valid offset for the local date-time.\n * * Gap, with zero valid offsets. This is when clocks jump forward typically\n *   due to the spring daylight savings change from 'winter' to 'summer'.\n *   In a gap there are local date-time values with no valid offset.\n * * Overlap, with two valid offsets. This is when clocks are set back typically\n *   due to the autumn daylight savings change from 'summer' to 'winter'.\n *   In an overlap there are local date-time values with two valid offsets.\n *\n * Any method that converts directly or implicitly from a local date-time to an\n * instant by obtaining the offset has the potential to be complicated.\n *\n * For Gaps, the general strategy is that if the local date-time falls in the\n * middle of a Gap, then the resulting zoned date-time will have a local date-time\n * shifted forwards by the length of the Gap, resulting in a date-time in the later\n * offset, typically 'summer' time.\n *\n * For Overlaps, the general strategy is that if the local date-time falls in the\n * middle of an Overlap, then the previous offset will be retained. If there is no\n * previous offset, or the previous offset is invalid, then the earlier offset is\n * used, typically 'summer' time. Two additional methods,\n * {@link withEarlierOffsetAtOverlap} and {@link withLaterOffsetAtOverlap},\n * help manage the case of an overlap.\n *\n * ### Specification for implementors\n *\n * A {@link ZonedDateTime} holds state equivalent to three separate objects,\n * a {@link LocalDateTime}, a {@link ZoneId} and the resolved {@link ZoneOffset}.\n * The offset and local date-time are used to define an instant when necessary.\n * The zone ID is used to obtain the rules for how and when the offset changes.\n * The offset cannot be freely set, as the zone controls which offsets are valid.\n */\nexport class ZonedDateTime extends ChronoZonedDateTime {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone or clock\n     * or default time zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current date-time.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()]\n     * @return {ZonedDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        let clock;\n        if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n        }\n        return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for static {@link ZonedDateTime.of}\n     *\n     * if called with 2 (or less) args {@link ZonedDateTime.of2} is called,\n     * if called with 3 args and the first arg is an instance of LocalDate {@link ZonedDateTime.of3} is called,\n     * otherwise {@link ZonedDateTime.of8} is called.\n     */\n    static of(){\n        if(arguments.length <= 2){\n            return ZonedDateTime.of2.apply(this, arguments);\n        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate){\n            return ZonedDateTime.of3.apply(this, arguments);\n        } else {\n            return ZonedDateTime.of8.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date and time.\n     *\n     * This creates a zoned date-time matching the input local date and time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date time and first combined to form a local date-time.\n     * The local date-time is then resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {LocalDate} date - the local date, not null\n     * @param {LocalTime} time - the local time, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the offset date-time, not null\n     */\n    static of3(date, time, zone) {\n        return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date-time.\n     *\n     * This creates a zoned date-time matching the input local date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static of2(localDateTime, zone) {\n        return ZonedDateTime.ofLocal(localDateTime, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and time-zone.\n     *\n     * This creates a zoned date-time matching the local date-time of the seven\n     * specified fields as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@link LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @param {number} hour - the hour-of-day to represent, from 0 to 23\n     * @param {number} minute - the minute-of-hour to represent, from 0 to 59\n     * @param {number} second - the second-of-minute to represent, from 0 to 59\n     * @param {number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime } the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    static of8(\n        year, month, dayOfMonth,\n        hour, minute, second, nanoOfSecond, zone) {\n        const dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return ZonedDateTime.ofLocal(dt, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date-time\n     * using the preferred offset if possible.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * If the preferred offset is one of the valid offsets then it is used.\n     * Otherwise the earlier valid offset is used, typically corresponding to 'summer'.\n     *\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @param {ZoneOffset} preferredOffset - the zone offset, null if no preference\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLocal(localDateTime, zone, preferredOffset) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset) {\n            return new ZonedDateTime(localDateTime, zone, zone);\n        }\n        let offset = null;\n        const rules = zone.rules();\n        const validOffsets = rules.validOffsets(localDateTime);\n        if (validOffsets.length === 1) {\n            offset = validOffsets[0];\n        } else if (validOffsets.length === 0) {\n            const trans = rules.transition(localDateTime);\n            localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n            offset = trans.offsetAfter();\n        } else {\n            if (preferredOffset != null &&\n                    validOffsets.some((validOffset) => {return validOffset.equals(preferredOffset);})) {\n                offset = preferredOffset;\n            } else {\n                offset = requireNonNull(validOffsets[0], 'offset');  // protect against bad ZoneRules\n            }\n        }\n\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.ofInstant}.\n     * if called with 2 args {@link ZonedDateTime.ofInstant2} is called\n     * otherwise {@link ZonedDateTime.ofInstant3}.\n     */\n    static ofInstant(){\n        if (arguments.length === 2){\n            return ZonedDateTime.ofInstant2.apply(this, arguments);\n        } else {\n            return ZonedDateTime.ofInstant3.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from an {@link Instant}.\n     *\n     * This creates a zoned date-time with the same instant as that specified.\n     * Calling {@link toInstant} will return an instant equal to the one used here.\n     *\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param {!Instant} instant - the instant to create the date-time from, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static ofInstant2(instant, zone) {\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from the instant formed by combining\n     * the local date-time and offset.\n     *\n     * This creates a zoned date-time by combining the {@link LocalDateTime} and {@link ZoneOffset}.\n     * This combination uniquely specifies an instant without ambiguity.\n     *\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant. If the valid offset is different to the offset specified,\n     * the the date-time and offset of the zoned date-time will differ from those specified.\n     *\n     * If the {@link ZoneId} to be used is a {@link ZoneOffset}, this method is equivalent\n     * to {@link of}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofInstant3(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static _create(epochSecond, nanoOfSecond, zone) {\n        const rules = zone.rules();\n        const instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);  // TODO: rules should be queryable by epochSeconds\n        const offset = rules.offset(instant);\n        const ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n        return new ZonedDateTime(ldt, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} strictly validating the\n     * combination of local date-time, offset and zone ID.\n     *\n     * This creates a zoned date-time ensuring that the offset is valid for the\n     * local date-time according to the rules of the specified zone.\n     * If the offset is invalid, an exception is thrown.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofStrict(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        const rules = zone.rules();\n        if (rules.isValidOffset(localDateTime, offset) === false) {\n            const trans = rules.transition(localDateTime);\n            if (trans != null && trans.isGap()) {\n                // error message says daylight savings for simplicity\n                // even though there are other kinds of gaps\n                throw new DateTimeException('LocalDateTime ' + localDateTime +\n                        ' does not exist in zone ' + zone +\n                        ' due to a gap in the local time-line, typically caused by daylight savings');\n            }\n            throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' +\n                localDateTime + '\" in zone \"' + zone + '\"');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} leniently, for advanced use cases,\n     * allowing any combination of local date-time, offset and zone ID.\n     *\n     * This creates a zoned date-time with no checks other than no nulls.\n     * This means that the resulting zoned date-time may have an offset that is in conflict\n     * with the zone ID.\n     *\n     * This method is intended for advanced use cases.\n     * For example, consider the case where a zoned date-time with valid fields is created\n     * and then stored in a database or serialization-based store. At some later point,\n     * the object is then re-loaded. However, between those points in time, the government\n     * that defined the time-zone has changed the rules, such that the originally stored\n     * local date-time now does not occur. This method can be used to create the object\n     * in an 'invalid' state, despite the change in rules.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLenient(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n            throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZonedDateTime}.\n     *\n     * The conversion will first obtain a {@link ZoneId}. It will then try to obtain an instant.\n     * If that fails it will try to obtain a local date-time.\n     * The zoned date time will either be a combination of {@link ZoneId} and instant,\n     * or {@link ZoneId} and local date-time.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZonedDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if unable to convert to an {@link ZonedDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof ZonedDateTime) {\n            return temporal;\n        }\n        const zone = ZoneId.from(temporal);\n        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n            const zdt = ZonedDateTime._from(temporal, zone);\n            if(zdt != null) return zdt;\n        }\n        const ldt = LocalDateTime.from(temporal);\n        return ZonedDateTime.of2(ldt, zone);\n    }\n\n    static _from(temporal, zone){\n        try {\n            return ZonedDateTime.__from(temporal, zone);\n        } catch (ex) {\n            if(!(ex instanceof DateTimeException)) throw ex;\n            // ignore\n        }\n    }\n\n    static __from(temporal, zone){\n        const epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n        const nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n        return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a text string such as\n     * `2007-12-03T10:15:30+01:00[Europe/Paris]`.\n     *\n     * The string must represent a valid date-time and is parsed using\n     * {@link org.threeten.bp.format.DateTimeFormatter#ISO_ZONED_DATE_TIME}.\n     *\n     * @param {!string} text - the text to parse such as '2007-12-03T10:15:30+01:00[Europe/Paris]', not null\n     * @param {!DateTimeFormatter} [formatter=DateTimeFormatter.ISO_ZONED_DATE_TIME] - the formatter to use\n     * @return {ZonedDateTime} the parsed zoned date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME) {\n        requireNonNull(formatter, 'fromatter');\n        return formatter.parse(text, ZonedDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDateTime} dateTime - the date-time, validated as not null\n     * @param {ZoneOffset} offset - the zone offset, validated as not null\n     * @param {ZoneUd} zone - the time-zone, validated as not null\n     * @private\n     */\n    constructor(dateTime, offset, zone) {\n        requireNonNull(dateTime, 'dateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n\n        super();\n\n        /**\n         * The local date-time.\n         */\n        this._dateTime = dateTime;\n        /**\n         * The offset from UTC/Greenwich.\n         */\n        this._offset = offset;\n        /**\n         * The time-zone.\n         */\n        this._zone = zone;\n    }\n\n    /**\n     * Resolves the new local date-time using this zone ID, retaining the offset if possible.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveLocal(newDateTime) {\n        requireNonNull(newDateTime, 'newDateTime');\n        return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n    }\n\n    /**\n     * Resolves the new local date-time using the offset to identify the instant.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveInstant(newDateTime) {\n        return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n    }\n\n    /**\n     * Resolves the offset into this zoned date-time.\n     *\n     * This ignores the offset, unless it can be used in an overlap.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveOffset(offset) {\n        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n            return new ZonedDateTime(this._dateTime, offset, this._zone);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link NANO_OF_SECOND}\n     * * {@link NANO_OF_DAY}\n     * * {@link MICRO_OF_SECOND}\n     * * {@link MICRO_OF_DAY}\n     * * {@link MILLI_OF_SECOND}\n     * * {@link MILLI_OF_DAY}\n     * * {@link SECOND_OF_MINUTE}\n     * * {@link SECOND_OF_DAY}\n     * * {@link MINUTE_OF_HOUR}\n     * * {@link MINUTE_OF_DAY}\n     * * {@link HOUR_OF_AMPM}\n     * * {@link CLOCK_HOUR_OF_AMPM}\n     * * {@link HOUR_OF_DAY}\n     * * {@link CLOCK_HOUR_OF_DAY}\n     * * {@link AMPM_OF_DAY}\n     * * {@link DAY_OF_WEEK}\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link DAY_OF_MONTH}\n     * * {@link DAY_OF_YEAR}\n     * * {@link EPOCH_DAY}\n     * * {@link ALIGNED_WEEK_OF_MONTH}\n     * * {@link ALIGNED_WEEK_OF_YEAR}\n     * * {@link MONTH_OF_YEAR}\n     * * {@link EPOCH_MONTH}\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     * * {@link INSTANT_SECONDS}\n     * * {@link OFFSET_SECONDS}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if(fieldOrUnit instanceof ChronoField){\n            return true;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return (fieldOrUnit != null && fieldOrUnit.isSupportedBy(this));\n    }\n\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an `int`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY}, {@link EPOCH_MONTH} and {@link INSTANT_SECONDS} which are too\n     * large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a `long`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS: return this._offset.totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        requireNonNull(field, 'field');\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as '+01:00'.\n     *\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return {ZoneOffset}the zone offset, not null\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * earlier of the two valid offsets at a local time-line overlap.\n     *\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the earlier of the two selected.\n     *\n     * If this method is called when it is not an overlap, `this`\n     * is returned.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the earlier offset, not null\n     */\n    withEarlierOffsetAtOverlap() {\n        const trans = this._zone.rules().transition(this._dateTime);\n        if (trans != null && trans.isOverlap()) {\n            const earlierOffset = trans.offsetBefore();\n            if (earlierOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * later of the two valid offsets at a local time-line overlap.\n     *\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the later of the two selected.\n     *\n     * If this method is called when it is not an overlap, `this`\n     * is returned.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the later offset, not null\n     */\n    withLaterOffsetAtOverlap() {\n        const trans = this._zone.rules().transition(this.toLocalDateTime());\n        if (trans != null) {\n            const laterOffset = trans.offsetAfter();\n            if (laterOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone, such as 'Europe/Paris'.\n     *\n     * This returns the zone ID. This identifies the time-zone {@link ZoneRules}\n     * that determine when and how the offset from UTC/Greenwich changes.\n     *\n     * The zone ID may be same as the offset (see {@link getOffset}).\n     * If this is true, then any future calculations, such as addition or subtraction,\n     * have no complex edge cases due to time-zone rules.\n     * See also {@link withFixedOffsetZone}.\n     *\n     * @return {ZoneId} the time-zone, not null\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the local date-time if possible.\n     *\n     * This method changes the time-zone and retains the local date-time.\n     * The local date-time is only changed if it is invalid for the new zone,\n     * determined using the same approach as\n     * {@link ofLocal}.\n     *\n     * To change the zone and adjust the local date-time,\n     * use {@link withZoneSameInstant}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested zone, not null\n     */\n    withZoneSameLocal(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the instant.\n     *\n     * This method changes the time-zone and retains the instant.\n     * This normally results in a change to the local date-time.\n     *\n     * This method is based on retaining the same instant, thus gaps and overlaps\n     * in the local time-line have no effect on the result.\n     *\n     * To change the offset while keeping the local time,\n     * use {@link withZoneSameLocal}.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested zone, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    withZoneSameInstant(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this :\n            ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n    }\n\n    /**\n     * Returns a copy of this date-time with the zone ID set to the offset.\n     *\n     * This returns a zoned date-time where the zone ID is the same as {@link getOffset}.\n     * The local date-time, offset and instant of the result will be the same as in this date-time.\n     *\n     * Setting the date-time to a fixed single offset means that any future\n     * calculations, such as addition or subtraction, have no complex edge cases\n     * due to time-zone rules.\n     * This might also be useful when sending a zoned date-time across a network,\n     * as most protocols, such as ISO-8601, only handle offsets,\n     * and not region-based zone IDs.\n     *\n     * This is equivalent to {@link ZonedDateTime.of}.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} with the zone ID set to the offset, not null\n     */\n    withFixedOffsetZone() {\n        return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per {@link get}.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._dateTime.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._dateTime.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._dateTime.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     *\n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._dateTime.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link DayOfWeek#getValue}.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._dateTime.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._dateTime.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._dateTime.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._dateTime.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.with}\n     *\n     * if called with 1 argument {@link ZonedDateTime.withTemporalAdjuster} is applied\n     * otherwise {@link ZonedDateTime.with2}\n     */\n    with(){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster.apply(this, arguments);\n        } else {\n            return this.with2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     *\n     * This returns a new {@link ZonedDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = zonedDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = zonedDateTime.with(date);\n     *  result = zonedDateTime.with(time);\n     * </pre>\n     *\n     * {@link ZoneOffset} also implements {@link TemporalAdjuster} however it is less likely\n     * that setting the offset will have the effect you expect. When an offset is passed in,\n     * the local date-time is combined with the new offset to form an {@link Instant}.\n     * The instant and original zone are then used to create the result.\n     * This algorithm means that it is quite likely that the output has a different offset\n     * to the specified offset. It will however work correctly when passing in the offset\n     * applicable for the instant of the zoned date-time, and will work correctly if passing\n     * one of the two valid offsets during a daylight savings overlap when the same local time\n     * occurs twice.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n        } else if (adjuster instanceof LocalTime) {\n            return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n        } else if (adjuster instanceof LocalDateTime) {\n            return this._resolveLocal(adjuster);\n        } else if (adjuster instanceof Instant) {\n            const instant = adjuster;\n            return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._resolveOffset(adjuster);\n        }\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     *\n     * This returns a {@link ZonedDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     *\n     * The {@link INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The zone and nano-of-second are unchanged.\n     * The result will have an offset derived from the new instant and original zone.\n     * If the new instant value is outside the valid range then a {@link DateTimeException} will be thrown.\n     *\n     * The {@link OFFSET_SECONDS} field will typically be ignored.\n     * The offset of a {@link ZonedDateTime} is controlled primarily by the time-zone.\n     * As such, changing the offset does not generally make sense, because there is only\n     * one valid offset for the local date-time and zone.\n     * If the zoned date-time is in a daylight savings overlap, then the offset is used\n     * to switch between the two valid offsets. In all other cases, the offset is ignored.\n     * If the new offset value is outside the valid range then a {@link DateTimeException} will be thrown.\n     *\n     * The other supported fields (see {@link isSupported}) will behave as in {@link LocalDateTime#with}.\n     * The zone is not part of the calculation and will be unchanged.\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return ZonedDateTime._create(newValue, this.nano(), this._zone);\n                case ChronoField.OFFSET_SECONDS: {\n                    const offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n                    return this._resolveOffset(offset);\n                }\n            }\n            return this._resolveLocal(this._dateTime.with(field, newValue));\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the year value altered.\n     *\n     * This operates on the local time-line,\n     * changing the year (see {@link LocalDateTime#withYear}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        return this._resolveLocal(this._dateTime.withYear(year));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the month-of-year value altered.\n     *\n     * This operates on the local time-line,\n     * changing the month (see {@link LocalDateTime#withMonth}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._resolveLocal(this._dateTime.withMonth(month));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the day-of-month value altered.\n     *\n     * This operates on the local time-line,\n     * changing the day-of-month (see {@link LocalDateTime#withDayOfMonth}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the day-of-year altered.\n     *\n     * This operates on the local time-line,\n     * changing the day-of-year (see {@link LocalDateTime#withDayOfYear}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid\n     * @throws DateTimeException if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the hour-of-day value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withHour}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    withHour(hour) {\n        return this._resolveLocal(this._dateTime.withHour(hour));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the minute-of-hour value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withMinute}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    withMinute(minute) {\n        return this._resolveLocal(this._dateTime.withMinute(minute));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the second-of-minute value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withSecond}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    withSecond(second) {\n        return this._resolveLocal(this._dateTime.withSecond(second));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the nano-of-second value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withNano}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the time truncated.\n     *\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with {@link ChronoUnit#MINUTES}\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This operates on the local time-line, truncating the underlying local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._resolveLocal(this._dateTime.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.plus}\n     *\n     * if called with 1 argument {@link ZonedDateTime.plusTemporalAmount} is applied,\n     * otherwise {@link ZonedDateTime.plus2}\n     */\n    plus(){\n        if(arguments.length === 1){\n            return this.plusTemporalAmount.apply(this, arguments);\n        } else {\n            return this.plus2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalAmount} amount - the amount to add, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusTemporalAmount(amount) {\n        requireNonNull(amount);\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line.\n     * The period is first added to the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link ofLocal}\n     * with the offset before the addition.\n     *\n     * Time units operate on the instant time-line.\n     * The period is first added to the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link ofInstant}\n     * with the offset before the addition.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the specified period added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            if (unit.isDateBased()) {\n                return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n            } else {\n                return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n            }\n        }\n        requireNonNull(unit, 'unit');\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in years added.\n     *\n     * This operates on the local time-line, adding years to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        return this._resolveLocal(this._dateTime.plusYears(years));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in months added.\n     *\n     * This operates on the local time-line, adding months to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        return this._resolveLocal(this._dateTime.plusMonths(months));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in weeks added.\n     *\n     * This operates on the local time-line, adding weeks to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in days added.\n     *\n     * This operates on the local time-line, adding days to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        return this._resolveLocal(this._dateTime.plusDays(days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in hours added.\n     *\n     * This operates on the instant time-line, such that adding one hour will\n     * always be a duration of one hour later.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus adding one day is not the same as adding 24 hours.\n     *\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     *\n     * * Adding one hour to 00:30+02:00 will result in 01:30+02:00\n     * * Adding one hour to 01:30+02:00 will result in 01:30+01:00\n     * * Adding one hour to 01:30+01:00 will result in 02:30+01:00\n     * * Adding three hours to 00:30+02:00 will result in 02:30+01:00\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._resolveInstant(this._dateTime.plusHours(hours));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in minutes added.\n     *\n     * This operates on the instant time-line, such that adding one minute will\n     * always be a duration of one minute later.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in seconds added.\n     *\n     * This operates on the instant time-line, such that adding one second will\n     * always be a duration of one second later.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds added.\n     *\n     * This operates on the instant time-line, such that adding one nano will\n     * always be a duration of one nano later.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._resolveInstant(this._dateTime.plusNanos(nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.minus}\n     *\n     * if called with 1 argument {@link ZonedDateTime.minusTemporalAmount} is applied,\n     * otherwise {@link ZonedDateTime.minus2}\n     */\n    minus(){\n        if(arguments.length === 1){\n            return this.minusTemporalAmount.apply(this, arguments);\n        } else {\n            return this.minus2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line.\n     * The period is first subtracted from the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link ofLocal}\n     * with the offset before the subtraction.\n     *\n     * Time units operate on the instant time-line.\n     * The period is first subtracted from the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link ofInstant}\n     * with the offset before the subtraction.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in years subtracted.\n     *\n     * This operates on the local time-line, subtracting years from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in months subtracted.\n     *\n     * This operates on the local time-line, subtracting months from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in weeks subtracted.\n     *\n     * This operates on the local time-line, subtracting weeks from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in days subtracted.\n     *\n     * This operates on the local time-line, subtracting days from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in hours subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one hour will\n     * always be a duration of one hour earlier.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus subtracting one day is not the same as adding 24 hours.\n     *\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     *\n     * * Subtracting one hour from 02:30+01:00 will result in 01:30+02:00\n     * * Subtracting one hour from 01:30+01:00 will result in 01:30+02:00\n     * * Subtracting one hour from 01:30+02:00 will result in 00:30+01:00\n     * * Subtracting three hours from 02:30+01:00 will result in 00:30+02:00\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this.plusHours(-1 * hours);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in minutes subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one minute will\n     * always be a duration of one minute earlier.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this.plusMinutes(-1 * minutes);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in seconds subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one second will\n     * always be a duration of one second earlier.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this.plusSeconds(-1 * seconds);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one nano will\n     * always be a duration of one nano earlier.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this.plusNanos(-1 * nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     *\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        requireNonNull(query, 'query');\n        return super.query(query);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are `this` and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the period in days between two date-times can be calculated\n     * using {@link startDateTime.until}.\n     *\n     * The {@link Temporal} passed to this method must be a {@link ZonedDateTime}.\n     * If the time-zone differs between the two zoned date-times, the specified\n     * end date-time is normalized to have the same zone as this date-time.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line, using the local date-time.\n     * For example, the period from noon on day 1 to noon the following day\n     * in days will always be counted as exactly one day, irrespective of whether\n     * there was a daylight savings change or not.\n     *\n     * Time units operate on the instant time-line.\n     * The calculation effectively converts both zoned date-times to instants\n     * and then calculates the period between the instants.\n     * For example, the period from noon on day 1 to noon the following day\n     * in hours may be 23, 24 or 25 hours (or some other amount) depending on\n     * whether there was a daylight savings change or not.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end date-time, which is converted to a {@link ZonedDateTime}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        let end = ZonedDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withZoneSameInstant(this._zone);\n            if (unit.isDateBased()) {\n                return this._dateTime.until(end._dateTime, unit);\n            } else {\n                const difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n                const adjustedEnd = end._dateTime.plusSeconds(difference);\n                return this._dateTime.until(adjustedEnd, unit);\n            }\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDateTime} part of this date-time.\n     *\n     * This returns a {@link LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return {LocalDateTime} the local date-time part of this date-time, not null\n     */\n    toLocalDateTime() {\n        return this._dateTime;\n    }\n\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     *\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     *\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._dateTime.toLocalTime();\n    }\n\n    /**\n     * Converts this date-time to an {@link OffsetDateTime}.\n     *\n     * This creates an offset date-time using the local date-time and offset.\n     * The zone ID is ignored.\n     *\n     * @return {OffsetDateTime} an offset date-time representing the same local date-time and offset, not null\n     */\n    /**\n     * we will not support OffsetDateTime in the near future\n        toOffsetDateTime() {\n            return OffsetDateTime.of(this._dateTime, this._offset);\n        }\n    */\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * The comparison is based on the offset date-time and the zone.\n     * Only objects of type {@link ZonedDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZonedDateTime) {\n            return this._dateTime.equals(other._dateTime) &&\n                this._offset.equals(other._offset) &&\n                this._zone.equals(other._zone);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a string, such as\n     * `2007-12-03T10:15:30+01:00[Europe/Paris]`.\n     *\n     * The format consists of the {@link LocalDateTime} followed by the {@link ZoneOffset}.\n     * If the {@link ZoneId} is not the same as the offset, then the ID is output.\n     * The output is compatible with ISO-8601 if the offset and ID are the same.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        let str = this._dateTime.toString() + this._offset.toString();\n        if (this._offset !== this._zone) {\n            str += '[' + this._zone.toString() + ']';\n        }\n        return str;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link ZonedDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        return super.format(formatter);\n    }\n\n}\n\nexport function _init(){\n    ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', (temporal) => {\n        return ZonedDateTime.from(temporal);\n    });\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull, requireInstance} from './assert';\n\nimport {MathUtil} from './MathUtil';\nimport {DateTimeException, UnsupportedTemporalTypeException, NullPointerException, IllegalArgumentException} from './errors';\n\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {ChronoLocalDate} from './chrono/ChronoLocalDate';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {ValueRange} from './temporal/ValueRange';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nimport {Clock} from './Clock';\nimport {DayOfWeek} from './DayOfWeek';\nimport {Month} from './Month';\nimport {Period} from './Period';\nimport {YearConstants} from './YearConstants';\nimport {LocalTime} from './LocalTime';\nimport {LocalDateTime} from './LocalDateTime';\nimport {Year} from './Year';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\nimport {ZonedDateTime} from './ZonedDateTime';\n\n/**\n * The number of days in a 400 year cycle.\n */\nconst  DAYS_PER_CYCLE = 146097;\n\n/**\n* The number of days from year zero to year 1970.\n* There are five 400 year cycles from year zero to 2000.\n* There are 7 leap years from 1970 to 2000.\n*/\nconst  DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5) - (30 * 365 + 7);\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as 2007-12-03.\n *\n * LocalDate is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n *\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * LocalDate.MIN = LocalDate.of(Year.MIN_VALUE, 1, 1);\n *\n * The minimum supported {@link LocalDate}\n * This could be used by an application as a \"far past\" date.\n *\n * LocalDate.MAX = LocalDate.of(Year.MAX_VALUE, 12, 31);\n *\n * The maximum supported {@link LocalDate}\n * This could be used by an application as a \"far future\" date.\n *\n * LocalDate.EPOCH_0\n *\n * The date at epoch day 0, that is 1970-01-01.\n */\n\nexport class LocalDate extends ChronoLocalDate{\n\n    /**\n     * Obtains the current date from the system clock in the default time-zone or\n     * if specified, the current date from the specified clock or\n     * if argument is a ZoneId this will query a clock with the specified ZoneId.\n     *\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()] - the clock or zone to use,\n     * if null, the system clock and default time-zone is used.\n     * @return {LocalDate} the current date, not null\n     */\n    static now(clockOrZone) {\n        let clock;\n        if(clockOrZone == null){\n            clock = Clock.systemDefaultZone();\n        } else if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone;\n        }\n        return LocalDate.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalDate from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalDate} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        requireNonNull(instant, 'instant');\n        const offset = zone.rules().offset(instant);\n        const epochSec = instant.epochSecond() + offset.totalSeconds();\n        const epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n        return LocalDate.ofEpochDay(epochDay);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year, month and day.\n     *\n     * This returns a {@link LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!(Month|Number)} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {!number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    static of(year, month, dayOfMonth) {\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year and day-of-year.\n     *\n     * This returns a {@link LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} dayOfYear - the day-of-year to represent, from 1 to 366\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    static ofYearDay(year, dayOfYear) {\n        ChronoField.YEAR.checkValidValue(year);\n        //TODO: ChronoField.DAY_OF_YEAR.checkValidValue(dayOfYear);\n        const leap = IsoChronology.isLeapYear(year);\n        if (dayOfYear === 366 && leap === false) {\n            assert(false, 'Invalid date \\'DayOfYear 366\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n        }\n        let moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n        const monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear > monthEnd) {\n            moy = moy.plus(1);\n        }\n        const dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.value(), dom);\n    }\n\n    /**\n     * Obtains an instance of LocalDate from the epoch day count.\n     *\n     * This returns a LocalDate with the specified epoch-day.\n     * The {@link ChronoField.EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param {number} [epochDay=0] - the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return {LocalDate} the local date, not null\n     * @throws {AssertionError} if the epoch days exceeds the supported date range\n     */\n    static ofEpochDay(epochDay=0) {\n        let adjust, adjustCycles, doyEst, yearEst, zeroDay;\n        zeroDay = epochDay + DAYS_0000_TO_1970;\n        zeroDay -= 60;\n        adjust = 0;\n        if (zeroDay < 0) {\n            adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n            adjust = adjustCycles * 400;\n            zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n        }\n        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        if (doyEst < 0) {\n            yearEst--;\n            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        }\n        yearEst += adjust;\n        const marchDoy0 = doyEst;\n        const marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n        const month = (marchMonth0 + 2) % 12 + 1;\n        const dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n        yearEst += MathUtil.intDiv(marchMonth0, 10);\n        const year = yearEst;\n        return new LocalDate(year, month, dom);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDate}.\n     *\n     * The conversion uses the {@link TemporalQueries.localDate} query, which relies\n     * on extracting the {@link ChronoField.EPOCH_DAY} field.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDate::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDate}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const date = temporal.query(TemporalQueries.localDate());\n        if (date == null) {\n            throw new DateTimeException(\n                `Unable to obtain LocalDate from TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return date;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE] - the formatter to use, default is\n     * {@link DateTimeFormatter.ISO_LOCAL_DATE}\n     * @return {LocalDate} the parsed local date, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE){\n        assert(formatter != null, 'formatter', NullPointerException);\n        return formatter.parse(text, LocalDate.FROM);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param {!number} year - the year to represent, validated from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} month - the month-of-year to represent, validated from 1 to 12\n     * @param {!number} day - the day-of-month to represent, validated from 1 to 31\n     * @return {LocalDate} resolved date, not null\n     */\n    static _resolvePreviousValid(year, month, day) {\n        switch (month) {\n            case 2:\n                day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day = Math.min(day, 30);\n                break;\n        }\n        return LocalDate.of(year, month, day);\n    }\n\n    /**\n     * Do not call the constructor directly, use the of*() factories instead like {@link LocalDate.of}\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} month\n     * @param {!number} dayOfMonth\n     * @private\n     */\n    constructor(year, month, dayOfMonth){\n        super();\n        if (month instanceof Month) {\n            month = month.value();\n        }\n        this._year = MathUtil.safeToInt(year);\n        this._month = MathUtil.safeToInt(month);\n        this._day = MathUtil.safeToInt(dayOfMonth);\n        LocalDate._validate(this._year, this._month, this._day);\n    }\n\n\n    /**\n     *\n     * @param {!number} year\n     * @param {!number} month\n     * @param {!number} dayOfMonth\n     * @throws {DateTimeException} if date values are invalid\n     * @private\n     */\n    static _validate(year, month, dayOfMonth) {\n        let dom;\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\n        if (dayOfMonth > 28) {\n            dom = 31;\n            switch (month) {\n                case 2:\n                    dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom = 30;\n            }\n            if (dayOfMonth > dom) {\n                if (dayOfMonth === 29) {\n                    assert(false, 'Invalid date \\'February 29\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n                } else {\n                    assert(false, 'Invalid date \\'' + year + '\\' \\'' + month + '\\' \\'' + dayOfMonth + '\\'', DateTimeException);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link LocalDate.range} range and\n     * {@link LocalDate.get} get methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.DAY_OF_WEEK}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link ChronoField.DAY_OF_MONTH}\n     * * {@link ChronoField.DAY_OF_YEAR}\n     * * {@link ChronoField.EPOCH_DAY}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * * {@link ChronoField.MONTH_OF_YEAR}\n     * * {@link ChronoField.EPOCH_MONTH}\n     * * {@link ChronoField.YEAR_OF_ERA}\n     * * {@link ChronoField.YEAR}\n     * * {@link ChronoField.ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date, false if not\n     */\n    isSupported(field) {\n        return super.isSupported(field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field.isDateBased()) {\n                switch (field) {\n                    case ChronoField.DAY_OF_MONTH: return ValueRange.of(1, this.lengthOfMonth());\n                    case ChronoField.DAY_OF_YEAR: return ValueRange.of(1, this.lengthOfYear());\n                    case ChronoField.ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n                    case ChronoField.YEAR_OF_ERA:\n                        return (this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an `int`.\n     *\n     * This queries this date for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date, except {@link ChronoField.EPOCH_DAY} and {@link ChronoField.EPOCH_MONTH}\n     * which are too large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * see {LocalDate.get}, get and getLong are identical in javascript, because we are only limited by\n     * {@link MathUtil.MIN_SAFE_INTEGER}/ {@link MathUtil.MAX_SAFE_INTEGER}\n     *\n     * @param {!TemporalField} field\n     * @returns {*}\n     */\n    getLong(field) {\n        assert(field != null, '', NullPointerException);\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * TODO tests are missing for the ALIGNED_* ChronoFields\n     *\n     * @param {!TemporalField} field\n     * @returns {*}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.DAY_OF_WEEK: return this.dayOfWeek().value();\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return MathUtil.intMod((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return MathUtil.intMod((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.DAY_OF_MONTH: return this._day;\n            case ChronoField.DAY_OF_YEAR: return this.dayOfYear();\n            case ChronoField.EPOCH_DAY: return this.toEpochDay();\n            case ChronoField.ALIGNED_WEEK_OF_MONTH: return MathUtil.intDiv((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_WEEK_OF_YEAR: return MathUtil.intDiv((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.MONTH_OF_YEAR: return this._month;\n            case ChronoField.PROLEPTIC_MONTH: return this._prolepticMonth();\n            case ChronoField.YEAR_OF_ERA: return (this._year >= 1 ? this._year : 1 - this._year);\n            case ChronoField.YEAR: return this._year;\n            case ChronoField.ERA: return (this._year >= 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    /**\n     *\n     * @return {number}\n     * @private\n     */\n    _prolepticMonth() {\n        return (this._year * 12) + (this._month - 1);\n    }\n\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     *\n     * The {@link Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which todays's rules for leap years are applied for all time.\n     *\n     * @return {Chronology} the ISO chronology, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     *\n     * @return {number} gets the year\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     *\n     * @return {number} gets the month value\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     *\n     * @returns {Month} month\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     *\n     * @return {number} gets the day of month\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    /**\n      * Gets the day-of-year field.\n      *\n      * This method returns the primitive int value for the day-of-year.\n      *\n      * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n      */\n    dayOfYear() {\n        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the {@link DayOfWeek.value} int value.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        const dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     *\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days\n     */\n    lengthOfMonth() {\n        switch (this._month) {\n            case 2:\n                return (this.isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * function overloading for the {@link LocalDate.with} method.\n     *\n     * calling \"with\" with one (or less) argument, assumes that the argument is an TemporalAdjuster\n     * and {@link LocalDate.withTemporalAdjuster} is called.\n     *\n     * Otherwise a TemporalField and newValue argument is expected and\n     * {@link LocalDate.withFieldAndValue} is called.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} fieldOrAdjuster\n     * @param {number} newValue - required if first argument is a TemporalField\n     * @return {LocalDate} the new LocalDate with the newValue set.\n     */\n    with(fieldOrAdjuster, newValue){\n        if(arguments.length < 2){\n            return this.withTemporalAdjuster(fieldOrAdjuster);\n        } else {\n            return this.withFieldAndValue(fieldOrAdjuster, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date.\n     *\n     * This returns a new {@link LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDate.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalDate} a {@link LocalDate} based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link DAY_OF_WEEK} -\n     *   Returns a {@link LocalDate} with the specified day-of-week.\n     *   The date is adjusted up to 6 days forward or backward within the boundary\n     *   of a Monday to Sunday week.\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *   Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *   The date is adjusted to the specified month-based aligned-day-of-week.\n     *   Aligned weeks are counted such that the first week of a given month starts\n     *   on the first day of that month.\n     *   This may cause the date to be moved up to 6 days into the following month.\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *   Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *   The date is adjusted to the specified year-based aligned-day-of-week.\n     *   Aligned weeks are counted such that the first week of a given year starts\n     *   on the first day of that year.\n     *   This may cause the date to be moved up to 6 days into the following year.\n     * * {@link DAY_OF_MONTH} -\n     *   Returns a {@link LocalDate} with the specified day-of-month.\n     *   The month and year will be unchanged. If the day-of-month is invalid for the\n     *   year and month, then a {@link DateTimeException} is thrown.\n     * * {@link DAY_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified day-of-year.\n     *   The year will be unchanged. If the day-of-year is invalid for the\n     *   year, then a {@link DateTimeException} is thrown.\n     * * {@link EPOCH_DAY} -\n     *   Returns a {@link LocalDate} with the specified epoch-day.\n     *   This completely replaces the date and is equivalent to {@link ofEpochDay}.\n     * * {@link ALIGNED_WEEK_OF_MONTH} -\n     *   Returns a {@link LocalDate} with the specified aligned-week-of-month.\n     *   Aligned weeks are counted such that the first week of a given month starts\n     *   on the first day of that month.\n     *   This adjustment moves the date in whole week chunks to match the specified week.\n     *   The result will have the same day-of-week as this date.\n     *   This may cause the date to be moved into the following month.\n     * * {@link ALIGNED_WEEK_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified aligned-week-of-year.\n     *   Aligned weeks are counted such that the first week of a given year starts\n     *   on the first day of that year.\n     *   This adjustment moves the date in whole week chunks to match the specified week.\n     *   The result will have the same day-of-week as this date.\n     *   This may cause the date to be moved into the following year.\n     * * {@link MONTH_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified month-of-year.\n     *   The year will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link PROLEPTIC_MONTH} -\n     *   Returns a {@link LocalDate} with the specified proleptic-month.\n     *   The day-of-month will be unchanged, unless it would be invalid for the new month\n     *   and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *   for the new month and year.\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link LocalDate} with the specified year-of-era.\n     *   The era and month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link YEAR} -\n     *   Returns a {@link LocalDate} with the specified year.\n     *   The month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link ERA} -\n     *   Returns a {@link LocalDate} with the specified era.\n     *   The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDate} a {@link LocalDate} based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withFieldAndValue(field, newValue) {\n        assert(field != null, 'field', NullPointerException);\n        if (field instanceof ChronoField) {\n            const f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.DAY_OF_WEEK: return this.plusDays(newValue - this.dayOfWeek().value());\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case ChronoField.DAY_OF_MONTH: return this.withDayOfMonth(newValue);\n                case ChronoField.DAY_OF_YEAR: return this.withDayOfYear(newValue);\n                case ChronoField.EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ChronoField.ALIGNED_WEEK_OF_MONTH: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n                case ChronoField.ALIGNED_WEEK_OF_YEAR: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year >= 1 ? newValue : 1 - newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * Returns a copy of this date with the year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!number} year  the year to set in the result, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        if (this._year === year) {\n            return this;\n        }\n        ChronoField.YEAR.checkValidValue(year);\n        return LocalDate._resolvePreviousValid(year, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this date with the month-of-year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!(Month|number)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        const m = (month instanceof Month) ? month.value() : month;\n        if (this._month === m) {\n            return this;\n        }\n        ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n        return LocalDate._resolvePreviousValid(this._year, m, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the day-of-month altered.\n     *\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param {!number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (this._day === dayOfMonth) {\n            return this;\n        }\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this date with the day-of-year altered.\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        if (this.dayOfYear() === dayOfYear) {\n            return this;\n        }\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * function overloading for plus\n     *\n     * called with 1 (or less) arguments, p1 is expected to be a TemporalAmount and {@link LocalDate.plus1}\n     * is called.\n     *\n     * Otherwise {@link LocalDate.plus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} p1\n     * @param {TemporalUnit} p2 - required if called with 2 arguments\n     * @return {LocalDate}\n     */\n    plus(p1, p2){\n        if(arguments.length < 2){\n            return this.plus1(p1);\n        } else {\n            return this.plus2(p1, p2);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new date based on this date with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link LocalDate.plus2}.\n     *\n     * @param {!TemporalAmount} amount - the amount to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new date based on this date with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.plusDays(amountToAdd);\n                case ChronoUnit.WEEKS: return this.plusWeeks(amountToAdd);\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years added.\n     *\n     * This method adds the specified amount to the years field in three steps:\n     *\n     * 1. Add the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * @param {!number} yearsToAdd - the years to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months added.\n     *\n     * This method adds the specified amount to the months field in three steps:\n     *\n     * 1. Add the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * @param {number} monthsToAdd - the months to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        const monthCount = this._year * 12 + (this._month - 1);\n        const calcMonths = monthCount + monthsToAdd;  // safe overflow\n        const newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        const newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks added.\n     *\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * @param {!number} weeksToAdd - the weeks to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeksToAdd) {\n        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n    }\n\n\n    /**\n     * Returns a copy of this LocalDate with the specified number of days added.\n     *\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * @param {number} daysToAdd - the days to add, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days added, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        const mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    /**\n      * function overloading for minus\n      *\n      * called with 1 (or less) arguments, p1 is expected to be a TemporalAmount and {@link LocalDate.minus1}\n      * is called.\n      *\n      * Otherwise {@link LocalDate.minus2} is called.\n      *\n      * @param {!(TemporalAmount|number)} p1\n      * @param {TemporalUnit} p2 - required if called with 2 arguments\n      * @return {LocalDate}\n      */\n    minus(p1, p2){\n        if(arguments.length < 2){\n            return this.minus1(p1);\n        } else {\n            return this.minus2(p1, p2);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     *\n     * This method returns a new date based on this date with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * @param {!TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     *\n     * This method returns a new date based on this date with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {!TemporalUnit} unit  the unit of the period to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years subtracted.\n     *\n     * This method subtracts the specified amount from the years field in three steps:\n     *\n     * 1. Subtract the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} yearsToSubtract - the years to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(yearsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months subtracted.\n     *\n     * This method subtracts the specified amount from the months field in three steps:\n     *\n     * 1. Subtract the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} monthsToSubtract - the months to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(monthsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks subtracted.\n     *\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * @param {!number} weeksToSubtract - the weeks to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeksToSubtract) {\n        return this.plusWeeks(weeksToSubtract * -1);\n    }\n\n    /*\n     * Returns a copy of this LocalDate with the specified number of days subtracted.\n     *\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * @param {number} daysToSubtract - the days to subtract, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days subtracted, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(daysToSubtract * -1);\n    }\n\n    /**\n     * Queries this date using the specified query.\n     *\n     * This queries this date using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField.EPOCH_DAY} as the field.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDate.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDate);\n     * </pre>\n     *\n     * @param {!TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * function overloading for {@link LocalDate.until}\n     *\n     * called with 1 (or less) arguments {{@link LocalDate.until1}} is called\n     * otherwise {@link LocalDate.until2}\n     *\n     * @param {!TemporalAccessor} p1\n     * @param {TemporalUnit} p2 - not null if called with 2 arguments\n     * @return {number|Period}\n     */\n    until(p1, p2){\n        if(arguments.length < 2){\n            return this.until1(p1);\n        } else {\n            return this.until2(p1, p2);\n        }\n    }\n\n    /**\n     * Calculates the period between this date and another date in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two dates in terms of a single unit.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDate}.\n     * For example, the period in days between two dates can be calculated\n     * using {@link startDate.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the period in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link DAYS}, {@link WEEKS}, {@link MONTHS}, {@link YEARS},\n     * {@link DECADES}, {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * @param {!TemporalAccessor} endExclusive - the end date, which is converted to a {@link LocalDate}, not null\n     * @param {!TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until2(endExclusive, unit) {\n        const end = LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.daysUntil(end);\n                case ChronoUnit.WEEKS: return MathUtil.intDiv(this.daysUntil(end), 7);\n                case ChronoUnit.MONTHS: return this._monthsUntil(end);\n                case ChronoUnit.YEARS: return MathUtil.intDiv(this._monthsUntil(end), 12);\n                case ChronoUnit.DECADES: return MathUtil.intDiv(this._monthsUntil(end), 120);\n                case ChronoUnit.CENTURIES: return MathUtil.intDiv(this._monthsUntil(end), 1200);\n                case ChronoUnit.MILLENNIA: return MathUtil.intDiv(this._monthsUntil(end), 12000);\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {!LocalDate} end\n     * @returns {number}\n     * @protected\n     */\n    daysUntil(end) {\n        return end.toEpochDay() - this.toEpochDay();  // no overflow\n    }\n\n    /**\n     *\n     * @param {!LocalDate} end\n     * @returns {number}\n     * @private\n     */\n    _monthsUntil(end) {\n        const packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();  // no overflow\n        const packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();  // no overflow\n        return MathUtil.intDiv((packed2 - packed1), 32);\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@link Period}.\n     *\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     *\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     *\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from `2010-01-15` to `2011-03-18` is \"1 year, 2 months and 3 days\".\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   period = start.until(end);\n     *   period = Period.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param {!TemporalAccessor} endDate - the end date, exclusive, which may be in any chronology, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    until1(endDate) {\n        const end = LocalDate.from(endDate);\n        let totalMonths = end._prolepticMonth() - this._prolepticMonth();  // safe\n        let days = end._day - this._day;\n        if (totalMonths > 0 && days < 0) {\n            totalMonths--;\n            const calcDate = this.plusMonths(totalMonths);\n            days = (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths < 0 && days > 0) {\n            totalMonths++;\n            days -= end.lengthOfMonth();\n        }\n        const years = MathUtil.intDiv(totalMonths, 12);  // safe\n        const months = MathUtil.intMod(totalMonths, 12);  // safe\n        return Period.of(years, months, days);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.atTime}\n     *\n     * if called with 1 argument {@link LocalDate.atTime1} is called\n     * otherwise {@link LocalDate.atTime4}\n     *\n     * @return {LocalDateTime} the local date-time formed from this date and the specified params\n     */\n    atTime(){\n        if(arguments.length===1){\n            return this.atTime1.apply(this, arguments);\n        } else {\n            return this.atTime4.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalTime} time - the time to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     */\n    atTime1(time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {!number} hour - the hour-of-day to use, from 0 to 23\n     * @param {!number} minute - the minute-of-hour to use, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    atTime4(hour, minute, second=0, nanoOfSecond=0) {\n        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {OffsetTime} time - the time to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date and the specified time, not null\n     */\n    /*\n    _atTimeOffsetTime(time) { // atTime(offsetTime)\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n*/\n\n    /**\n     * Combines this date with the time of midnight to create a {@link LocalDateTime}\n     * at the start of this date.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @param {ZoneId} zone - if zone is not null @see {@link LocalDate.atStartOfDayWithZone}\n     * @return {LocalDateTime|ZonedDateTime} the local date-time of midnight at the start of this date, not null\n     */\n    atStartOfDay(zone) {\n        if(zone != null){\n            return this.atStartOfDayWithZone(zone);\n        } else {\n            return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n        }\n    }\n\n    /**\n     * Combines this date with a time-zone to create a {@link ZonedDateTime}\n     * at the start of the day\n     *\n     * This returns a {@link ZonedDateTime} formed from this date at the\n     * specified zone, with the time set to be the earliest valid time according\n     * to the rules in the time-zone.\n     *\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     *\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     *\n     * To convert to a specific time in a given time-zone call {@link atTime}\n     * followed by {@link LocalDateTime#atZone}.\n     *\n     * @param {!ZoneId} zone - the zone ID to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    atStartOfDayWithZone(zone) {\n        requireNonNull(zone, 'zone');\n        let ldt = this.atTime(LocalTime.MIDNIGHT);\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        if (zone instanceof ZoneOffset === false) {\n            const trans = zone.rules().transition(ldt);\n            if (trans != null && trans.isGap()) {\n                ldt = trans.dateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n\n    /**\n     * Converts this date to the Epoch Day.\n     *\n     * The Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 (ISO).\n     * This definition is the same for all chronologies, enabling conversion.\n     *\n     * @return {number} the Epoch Day equivalent to this date\n     */\n    toEpochDay() {\n        const y = this._year;\n        const m = this._month;\n        let total = 0;\n        total += 365 * y;\n        if (y >= 0) {\n            total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n        } else {\n            total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n        }\n        total += MathUtil.intDiv(367 * m - 362, 12);\n        total += this.dayOfMonth() - 1;\n        if (m > 2) {\n            total--;\n            if (!IsoChronology.isLeapYear(y)) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Compares this date to another date.\n     *\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * If all the dates being compared are instances of {@link LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDate.compareTo}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDate, 'other');\n        return this._compareTo0(other);\n        // return super.compareTo(other);  if not instanceof LocalDate\n    }\n\n    /**\n     *\n     * @param {!LocalDate} otherDate\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(otherDate) {\n        let cmp = (this._year - otherDate._year);\n        if (cmp === 0) {\n            cmp = (this._month - otherDate._month);\n            if (cmp === 0) {\n                cmp = (this._day - otherDate._day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     *\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is after the specified date\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     *\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is before the specified date\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     *\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo}\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is equal to the specified date\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to another date.\n     *\n     * Compares this LocalDate with another ensuring that the date is the same.\n     *\n     * Only objects of type LocalDate are compared, other types return false.\n     *\n     * @param {*} otherDate - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date\n     */\n    equals(otherDate) {\n        if (this === otherDate) {\n            return true;\n        }\n        if (otherDate instanceof LocalDate) {\n            return this._compareTo0(otherDate) === 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const yearValue = this._year;\n        const monthValue = this._month;\n        const dayValue = this._day;\n        return MathUtil.hash((yearValue & 0xFFFFF800) ^ ((yearValue << 11) + (monthValue << 6) + (dayValue)));\n    }\n\n    /**\n     * Outputs this date as a String, such as 2007-12-03.\n     * The output will be in the ISO-8601 format uuuu-MM-dd.\n     *\n     * @return {string} a string representation of this date, not null\n     */\n    toString() {\n        let dayString, monthString, yearString;\n\n        const yearValue = this._year;\n        const monthValue = this._month;\n        const dayValue = this._day;\n\n        const absYear = Math.abs(yearValue);\n\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = '-' + ('' + (yearValue - 10000)).slice(-4);\n            } else {\n                yearString = ('' + (yearValue + 10000)).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = '+' + yearValue;\n            } else {\n                yearString = '' + yearValue;\n            }\n        }\n\n        if (monthValue < 10) {\n            monthString = '-0' + monthValue;\n        } else {\n            monthString = '-' + monthValue;\n        }\n\n        if (dayValue < 10) {\n            dayString = '-0' + dayValue;\n        } else {\n            dayString = '-' + dayValue;\n        }\n\n        return yearString + monthString + dayString;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDate.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return super.format(formatter);\n    }\n}\n\nexport function _init() {\n    /**\n     * The minimum supported {@link LocalDate}\n     * This could be used by an application as a \"far past\" date.\n     */\n    LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@link LocalDate}\n     * This could be used by an application as a \"far future\" date.\n     */\n    LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n    /**\n     * The date at epoch day 0, that is 1970-01-01.\n     */\n    LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n\n    LocalDate.FROM = createTemporalQuery('LocalDate.FROM', (temporal) => {\n        return LocalDate.from(temporal);\n    });\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from '../assert';\nimport {MathUtil} from '../MathUtil';\n\nimport {LocalDate} from '../LocalDate';\nimport {Instant} from '../Instant';\nimport {ZoneOffset} from '../ZoneOffset';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\n/**\n * A date-time without a time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n *\n * **Most applications should declare method signatures, fields and variables\n * as {@link LocalDateTime}, not this interface.**\n *\n * A {@link ChronoLocalDateTime} is the abstract representation of a local date-time\n * where the {@link Chronology}, or calendar system, is pluggable.\n * The date-time is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * #### When to use this interface\n *\n * The design of the API encourages the use of {@link LocalDateTime} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.\n *\n * Ensure that the discussion in {@link ChronoLocalDate} has been read and understood\n * before using this interface.\n *\n * ### Specification for implementors\n *\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n *\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n *\n * @param D the date type\n */\nexport class ChronoLocalDateTime extends Temporal {\n    /* <D extends ChronoLocalDate>\n        extends DefaultInterfaceTemporal\n        implements Temporal, TemporalAdjuster, Comparable<ChronoLocalDateTime<?>> */\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date-time.\n     *\n     * The {@link Chronology} represents the calendar system in use.\n     * The era and other fields in {@link ChronoField} are defined by the chronology.\n     *\n     * @return the chronology, not null\n     */\n    chronology() {\n        return this.toLocalDate().chronology();\n    }\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal\n            .with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay())\n            .with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@link Instant}.\n     *\n     * This combines this local date-time and the specified offset to form\n     * an {@link Instant}.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {Instant} an {@link Instant} representing the same instant, not null\n     */\n    toInstant(offset) {\n        requireInstance(offset, ZoneOffset, 'zoneId');\n        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * This combines this local date-time and the specified offset to calculate the\n     * epoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond(offset) {\n        requireNonNull(offset, 'offset');\n        const epochDay = this.toLocalDate().toEpochDay();\n        let secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= offset.totalSeconds();\n        return MathUtil.safeToInt(secs);\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {Instant} from './Instant';\nimport {LocalDate} from './LocalDate';\nimport {LocalTime} from './LocalTime';\nimport {ZonedDateTime} from './ZonedDateTime';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\nimport {ChronoLocalDateTime} from './chrono/ChronoLocalDateTime';\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as `2007-12-03T10:15:30`.\n *\n * {@link LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value '2nd October 2007 at 13:45.30.123456789' can be\n * stored in a {@link LocalDateTime}.\n *\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalTime}\n *\n * LocalDateTime.MIN\n *\n * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n * This is the local date-time of midnight at the start of the minimum date.\n * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n * This could be used by an application as a 'far past' date-time.\n *\n * LocalDateTime.MAX\n *\n * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n * This is the local date-time just before midnight at the end of the maximum date.\n * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n * This could be used by an application as a 'far future' date-time.\n *\n */\nexport class LocalDateTime extends ChronoLocalDateTime\n/** extends ChronoLocalDateTime<LocalDate>\nimplements Temporal, TemporalAdjuster, Serializable */ {\n\n\n    /**\n     * Obtains the current date-time from from the specified clock or the system clock in the specified time-zone.\n     *\n     * If the argument is an instance of Clock this will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * If the argument is an instance of ZoneId this will query the system clock (see {@link Clock#system}) to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * If nor argument is applied, the system default time zone is used to obtain the current date-time.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalDateTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalDateTime._now(clockOrZone);\n        } else {\n            return LocalDateTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     *\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, defaults to Clock.systemDefaultZone()\n     * @return {LocalDateTime} the current date-time, not null\n     */\n    static _now(clock) {\n        requireNonNull(clock, 'clock');\n        return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n\n        // this is an alternative implementation with better performance.\n        // const epochMilli = clock.millis();\n        // const offset = clock.zone().rules().offsetOfEpochMilli(epochMilli);\n        // return LocalDateTime._ofEpochMillis(epochMilli, offset);\n\n    }\n\n    /**\n     * @see comment at {LocalDateTime._now}\n     * @param {number} epochMilli\n     * @param {ZoneOffset} offset\n     * @return {LocalDateTime} the  date-time, not null\n     *\n     */\n    static _ofEpochMillis(epochMilli, offset){\n        const localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n        const localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        const secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        const nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n        const date = LocalDate.ofEpochDay(localEpochDay);\n        const time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.of}\n     *\n     * if called with 2 arguments and first argument is an instance of LocalDate and second is an\n     * instance of LocalTime, then {@link LocalDateTime.ofDateAndTime} is executed.\n     *\n     * Otherwise {@link LocalDateTime.ofNumbers} is executed.\n     *\n     * @returns {LocalDateTime}\n     */\n    static of(){\n        if (arguments.length === 2 && (arguments[0] instanceof LocalDate || arguments[1] instanceof LocalTime)){\n            return LocalDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return LocalDateTime.ofNumbers.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     *\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {number} [year=0] - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} [month=0] - the month-of-year to represent, from 1 to 12 or from a Month\n     * @param {number} [dayOfMonth=0] - the day-of-month to represent, from 1 to 31\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    static ofNumbers(year=0, month=0, dayOfMonth=0, hour=0, minute=0, second=0, nanoOfSecond=0) {\n        const date = LocalDate.of(year, month, dayOfMonth);\n        const time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a date and time.\n     *\n     * @param {!LocalDate} date - the local date, not null\n     * @param {!LocalTime} time - the local time, not null\n     * @return {LocalDateTime} the local date-time, not null\n     */\n    static ofDateAndTime(date, time) {\n        requireNonNull(date, 'date');\n        requireNonNull(time, 'time');\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from an {@link Instant} and zone ID.\n     *\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param {!Instant} instant  the instant to create the date-time from, not null\n     * @param {!ZoneId} [zone=ZoneId.systemDefault()]  the time-zone, which may be an offset, defaults to ZoneId.systemDefault()\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()) {\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        requireNonNull(zone, 'zone');\n        const offset = zone.rules().offset(instant);\n        return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * This allows the {@link ChronoField.INSTANT_SECONDS} epoch-second field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number|!ZoneOffset} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneOffset} offset - the zone offset, not null if called with 3 arguments\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofEpochSecond(epochSecond=0, nanoOfSecond=0, offset) {\n        if(arguments.length === 2 && nanoOfSecond instanceof ZoneOffset){\n            offset = nanoOfSecond;\n            nanoOfSecond = 0;\n        }\n        requireNonNull(offset, 'offset');\n        const localSecond = epochSecond + offset.totalSeconds();  // overflow caught later\n        const localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        const secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        const date = LocalDate.ofEpochDay(localEpochDay);\n        const time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDateTime}.\n     *\n     * The conversion extracts and combines {@link LocalDate} and {@link LocalTime}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDateTime} {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof LocalDateTime) {\n            return temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return temporal.toLocalDateTime();\n        }\n        try {\n            const date = LocalDate.from(temporal);\n            const time = LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain LocalDateTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE_TIME] - the formatter to use,\n     * defaults to DateTimeFormatter.ISO_LOCAL_DATE_TIME\n     * @return {LocalDateTime} the parsed local date-time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDate} date - the date part of the date-time, validated not null\n     * @param {LocalTime} time - the time part of the date-time, validated not null\n     * @private\n     */\n    constructor(date, time) {\n        super();\n        requireInstance(date, LocalDate, 'date');\n        requireInstance(time, LocalTime, 'time');\n        this._date = date;\n        this._time = time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {LocalDate} newDate - the date of the new date-time, not null\n     * @param {LocalTime} newTime - the time of the new date-time, not null\n     * @return {LocalDateTime} the date-time, not null\n     */\n    _withDateTime(newDate, newTime) {\n        if (this._date === newDate && this._time === newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link LocalDateTime.range} range and\n     * {@link LocalDateTime.get} get methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND}\n     * * {@link ChronoField.NANO_OF_DAY}\n     * * {@link ChronoField.MICRO_OF_SECOND}\n     * * {@link ChronoField.MICRO_OF_DAY}\n     * * {@link ChronoField.MILLI_OF_SECOND}\n     * * {@link ChronoField.MILLI_OF_DAY}\n     * * {@link ChronoField.SECOND_OF_MINUTE}\n     * * {@link ChronoField.SECOND_OF_DAY}\n     * * {@link ChronoField.MINUTE_OF_HOUR}\n     * * {@link ChronoField.MINUTE_OF_DAY}\n     * * {@link ChronoField.HOUR_OF_AMPM}\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * * {@link ChronoField.HOUR_OF_DAY}\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * * {@link ChronoField.AMPM_OF_DAY}\n     * * {@link ChronoField.DAY_OF_WEEK}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link ChronoField.DAY_OF_MONTH}\n     * * {@link ChronoField.DAY_OF_YEAR}\n     * * {@link ChronoField.EPOCH_DAY}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * * {@link ChronoField.MONTH_OF_YEAR}\n     * * {@link ChronoField.EPOCH_MONTH}\n     * * {@link ChronoField.YEAR_OF_ERA}\n     * * {@link ChronoField.YEAR}\n     * * {@link ChronoField.ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.range(field) : this._date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an `int`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY} and {@link EPOCH_MONTH} which are too large to fit in\n     * an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.get(field) : this._date.get(field));\n        }\n        return super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a `long`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per `get(YEAR)`.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._date.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._date.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use\n     * {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._date.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._date.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     *\n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._date.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use\n     * {@link DayOfWeek#getValue}.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._date.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._time.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._time.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._time.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._time.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.with}\n     *\n     * if called with 1 argument, {@link LocalDateTime.withTemporalAdjuster} is applied,\n     * otherwise {@link LocalDateTime.with2}.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue - only require if first argument is a TemporalField\n     * @returns {LocalDateTime}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     *\n     * This returns a new {@link LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = localDateTime.with(date);\n     *  result = localDateTime.with(time);\n     * </pre>\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._withDateTime(adjuster, this._time);\n        } else if (adjuster instanceof LocalTime) {\n            return this._withDateTime(this._date, adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields (see {@link isSupported}) will behave as in\n     * {@link LocalDate#with} or {@link LocalTime#with}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDateTime} a {@link LocalDateTime} based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            if (field.isTimeBased()) {\n                return this._withDateTime(this._date, this._time.with(field, newValue));\n            } else {\n                return this._withDateTime(this._date.with(field, newValue), this._time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        return this._withDateTime(this._date.withYear(year), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the month-of-year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!(number|Month)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._withDateTime(this._date.withMonth(month), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-month altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-year altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the hour-of-day value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour) {\n        const newTime = this._time.withHour(hour);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the minute-of-hour value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute) {\n        const newTime = this._time.withMinute(minute);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the second-of-minute value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second) {\n        const newTime = this._time.withSecond(second);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the nano-of-second value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        const newTime = this._time.withNano(nanoOfSecond);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the time truncated.\n     *\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with {@link ChronoUnit#MINUTES}\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._withDateTime(this._date, this._time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.plus}\n     *\n     * if called with 1 argument {@link LocalDateTime.plusTemporalAmount} is applied,\n     * otherwise {@link LocalDateTime.plus2}\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @returns {LocalDateTime}\n     */\n    plus(amount, unit){\n        if(arguments.length === 1){\n            return this.plusTemporalAmount(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {LocalDateTime} based on this date-time with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years added.\n     *\n     * This method adds the specified amount to the years field in three steps:\n     *\n     * 1. Add the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        const newDate = this._date.plusYears(years);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months added.\n     *\n     * This method adds the specified amount to the months field in three steps:\n     *\n     * 1. Add the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        const newDate = this._date.plusMonths(months);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks added.\n     *\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        const newDate = this._date.plusWeeks(weeks);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days added.\n     *\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        const newDate = this._date.plusDays(days);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.minus}\n     *\n     * if called with 1 argument {@link LocalDateTime.minusTemporalAmount} is applied,\n     * otherwise {@link LocalDateTime.minus2}\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @returns {LocalDateTime}\n     */\n    minus(amount, unit){\n        if(arguments.length === 1){\n            return this.minusTemporalAmount(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    minusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years subtracted.\n     *\n     * This method subtracts the specified amount from the years field in three steps:\n     *\n     * 1. Subtract the input years from the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months subtracted.\n     *\n     * This method subtracts the specified amount from the months field in three steps:\n     *\n     * 1. Subtract the input months from the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks subtracted.\n     *\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days subtracted.\n     *\n     * This method subtracts the specified amount from the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanos - the nanos to subtract, may be negative\n     * @return {LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {LocalDate} newDate  the new date to base the calculation on, not null\n     * @param {Number} hours - the hours to add, may be negative\n     * @param {Number} minutes - the minutes to add, may be negative\n     * @param {Number} seconds - the seconds to add, may be negative\n     * @param {Number} nanos - the nanos to add, may be negative\n     * @param {Number} sign - the sign to determine add or subtract\n     * @return {LocalDateTime} the combined result, not null\n     */\n    _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) === 0) {\n            return this._withDateTime(newDate, this._time);\n        }\n        let totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) +             //   max/24*60*60*1B\n                MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) +                //   max/24*60*60\n                MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) +                //   max/24*60\n                MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);                     //   max/24\n        totDays *= sign;                                   // total max*0.4237...\n        let totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) +                    //   max  86400000000000\n                (MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY)) * LocalTime.NANOS_PER_SECOND +   //   max  86400000000000\n                (MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY)) * LocalTime.NANOS_PER_MINUTE +   //   max  86400000000000\n                (MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY)) * LocalTime.NANOS_PER_HOUR;          //   max  86400000000000\n        const curNoD = this._time.toNanoOfDay();                       //   max  86400000000000\n        totNanos = totNanos * sign + curNoD;                    // total 432000000000000\n        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n        const newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n        const newTime = (newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD));\n        return this._withDateTime(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     *\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDateTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDateTime);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {LocalDateTime} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are `this` and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDateTime}.\n     * For example, the period in days between two date-times can be calculated\n     * using `startDateTime.until(endDateTime, DAYS)`.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date-time, which is converted to a {@link LocalDateTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                let daysUntil = this._date.daysUntil(end._date);\n                let timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n                if (daysUntil > 0 && timeUntil < 0) {\n                    daysUntil--;\n                    timeUntil += LocalTime.NANOS_PER_DAY;\n                } else if (daysUntil < 0 && timeUntil > 0) {\n                    daysUntil++;\n                    timeUntil -= LocalTime.NANOS_PER_DAY;\n                }\n                let amount = daysUntil;\n                switch (unit) {\n                    case ChronoUnit.NANOS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n                        return MathUtil.safeAdd(amount, timeUntil);\n                    case ChronoUnit.MICROS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n                    case ChronoUnit.MILLIS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n                    case ChronoUnit.SECONDS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n                    case ChronoUnit.MINUTES:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n                    case ChronoUnit.HOURS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n                    case ChronoUnit.HALF_DAYS:\n                        amount = MathUtil.safeMultiply(amount, 2);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, (LocalTime.NANOS_PER_HOUR * 12)));\n                }\n                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n            }\n            let endDate = end._date;\n            const endTime = end._time;\n            if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n                endDate = endDate.minusDays(1);\n            } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n                endDate = endDate.plusDays(1);\n            }\n            return this._date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param {ZoneOffset} offset  the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date-time and the specified offset, not null\n     */\n    /*\n    atOffset(offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n*/\n\n    /**\n     * Combines this date-time with a time-zone to create a {@link ZonedDateTime}.\n     *\n     * This returns a {@link ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict}.\n     *\n     * @param {ZoneId} zone  the time-zone to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date-time, not null\n     */\n    atZone(zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     *\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._date;\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     *\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._time;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     *\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * If all the date-times being compared are instances of {@link LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param {!LocalDateTime} other - the other date-time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDateTime, 'other');\n        return this._compareTo0(other);\n        // return super.compareTo(other); if not instance of  LocalDateTime\n    }\n\n    /**\n     *\n     * @param {!LocalDateTime} other\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(other) {\n        let cmp = this._date.compareTo(other.toLocalDate());\n        if (cmp === 0) {\n            cmp = this._time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     *\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is after the specified date-time\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other);  if not instance of LocalDateTime\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     *\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is before the specified date-time\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other);  if not instance of LocalDateTime\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     *\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {*} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is equal to the specified date-time\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other); if not instance of LocalDateTime\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * Compares this {@link LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@link LocalDateTime} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDateTime) {\n            return this._date.equals(other._date) && this._time.equals(other._time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._date.hashCode() ^ this._time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a string, such as `2007-12-03T10:15:30`.\n     *\n     * The output will be one of the following ISO-8601 formats:\n     *\n     * * `yyyy-MM-dd'T'HH:mm`\n     * * `yyyy-MM-dd'T'HH:mm:ss`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSS`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSSSSS`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS`\n     *\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        return this._date.toString() + 'T' + this._time.toString();\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {!DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date-time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nexport function _init(){\n    /**\n     * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a 'far past' date-time.\n     */\n    LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n\n    /**\n     * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a 'far future' date-time.\n     */\n    LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', (temporal) => {\n        return LocalDateTime.from(temporal);\n    });\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalDateTime} from './LocalDateTime';\nimport {ZoneId} from './ZoneId';\n\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalField} from './temporal/TemporalField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\n/**\n * A time without time-zone in the ISO-8601 calendar system,\n * such as `10:15:30`.\n *\n * {@link LocalTime} is an immutable date-time object that represents a time,\n * often viewed as hour-minute-second.\n * Time is represented to nanosecond precision.\n * For example, the value '13:45.30.123456789' can be stored in a {@link LocalTime}.\n *\n * It does not store or represent a date or time-zone.\n * Instead, it is a description of the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. This API assumes that all calendar systems use the same\n * representation, this class, for time-of-day.\n *\n * ### Static properties of Class {@link LocalTime}\n *\n * LocalTime.MIN\n *\n * The minimum supported {@link LocalTime}, '00:00'.\n * This is the time of midnight at the start of the day.\n *\n * LocalTime.MAX\n *\n * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n * This is the time just before midnight at the end of the day.\n *\n * LocalTime.MIDNIGHT\n *\n * The time of midnight at the start of the day, '00:00'.\n *\n * LocalTime.NOON\n *\n * The time of noon in the middle of the day, '12:00'.\n *\n * LocalTime.HOURS_PER_DAY\n *\n * Hours per day.\n *\n * LocalTime.MINUTES_PER_HOUR\n *\n * Minutes per hour.\n *\n * LocalTime.MINUTES_PER_DAY\n *\n * Minutes per day.\n *\n * LocalTime.SECONDS_PER_MINUTE\n *\n * Seconds per minute.\n *\n * LocalTime.SECONDS_PER_HOUR\n *\n * Seconds per hour.\n *\n * LocalTime.SECONDS_PER_DAY\n *\n * Seconds per day.\n *\n * LocalTime.MILLIS_PER_DAY\n *\n * Milliseconds per day.\n *\n * LocalTime.MICROS_PER_DAY\n *\n * Microseconds per day.\n *\n * LocalTime.NANOS_PER_SECOND\n *\n * Nanos per second.\n *\n * LocalTime.NANOS_PER_MINUTE\n *\n * Nanos per minute.\n *\n * LocalTime.NANOS_PER_HOUR\n *\n * Nanos per hour.\n *\n * LocalTime.NANOS_PER_DAY\n *\n * Nanos per day.\n *\n */\nexport class LocalTime extends Temporal /** implements Temporal, TemporalAdjuster */ {\n    /**\n     * Obtains the current time from the specified clock.\n     * If no argument is specified the system default clock is queried,\n     * if a zone-id is passed a system clock with the specified zone is queried.\n     *\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalTime} the current time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalTime._now(clockOrZone);\n        } else {\n            return LocalTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current time from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection (see {@link Clock}).\n     *\n     * @param {Clock} [clock=Clock.systemDefaultZone()] - the clock to use, not null\n     * @return {LocalTime} the current time, not null\n     */\n    static _now(clock = Clock.systemDefaultZone()) {\n        requireNonNull(clock, 'clock');// inline OffsetTime factory to avoid creating object and InstantProvider checks\n        return LocalTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalTime from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalTime} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        const offset = zone.rules().offset(instant);\n        let secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n        secsOfDay = MathUtil.intMod((secsOfDay + offset.totalSeconds()), LocalTime.SECONDS_PER_DAY);\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from an hour, minute, second and nanosecond.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    static of(hour, minute, second, nanoOfSecond) {\n        return new LocalTime(hour, minute, second, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a second-of-day value, with\n     * associated nanos of second.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [secondOfDay=0] - the second-of-day, from `0` to `24 * 60 * 60 - 1`\n     * @param {number} [nanoOfSecond=0] - the nano-of-second, from `0` to `999,999,999`\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the either input value is invalid\n     */\n    static ofSecondOfDay(secondOfDay=0, nanoOfSecond=0) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        const hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n        secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n        const minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n        secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n        return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a nanos-of-day value.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [nanoOfDay=0] - the nano of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the nanos of day value is invalid\n     */\n    static ofNanoOfDay(nanoOfDay=0) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n        const hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n        nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n        const minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n        nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n        const seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n        nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n        return new LocalTime(hours, minutes, seconds, nanoOfDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalTime}.\n     *\n     * The conversion uses the {@link TemporalQueries#localTime} query, which relies\n     * on extracting {@link ChronoField#NANO_OF_DAY}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link LocalTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const time = temporal.query(TemporalQueries.localTime());\n        if (time == null) {\n            throw new DateTimeException(`Unable to obtain LocalTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return time;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a time.\n     *\n     * @param {!String} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_TIME] - the formatter to use, default is\n     * {@link DateTimeFormatter.ISO_LOCAL_TIME}\n     * @return {LocalTime} the parsed local time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter=DateTimeFormatter.ISO_LOCAL_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalTime.FROM);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, validated from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, validated from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, validated from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, validated from 0 to 999,999,999\n     * @private\n     */\n    constructor(hour=0, minute=0, second=0, nanoOfSecond=0) {\n        super();\n        const _hour = MathUtil.safeToInt(hour);\n        const _minute = MathUtil.safeToInt(minute);\n        const _second = MathUtil.safeToInt(second);\n        const _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);\n        LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);\n        if ((_minute | _second | _nanoOfSecond) === 0) {\n            if (!LocalTime.HOURS[_hour]) {\n                this._hour = _hour;\n                this._minute = _minute;\n                this._second = _second;\n                this._nano = _nanoOfSecond;\n                LocalTime.HOURS[_hour] = this;\n            }\n            return LocalTime.HOURS[_hour];\n        }\n        this._hour = _hour;\n        this._minute = _minute;\n        this._second = _second;\n        this._nano = _nanoOfSecond;\n    }\n\n    static _validate(hour, minute, second, nanoOfSecond){\n        ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this time can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND}\n     * * {@link ChronoField.NANO_OF_DAY}\n     * * {@link ChronoField.MICRO_OF_SECOND}\n     * * {@link ChronoField.MICRO_OF_DAY}\n     * * {@link ChronoField.MILLI_OF_SECOND}\n     * * {@link ChronoField.MILLI_OF_DAY}\n     * * {@link ChronoField.SECOND_OF_MINUTE}\n     * * {@link ChronoField.SECOND_OF_DAY}\n     * * {@link ChronoField.MINUTE_OF_HOUR}\n     * * {@link ChronoField.MINUTE_OF_DAY}\n     * * {@link ChronoField.HOUR_OF_AMPM}\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * * {@link ChronoField.HOUR_OF_DAY}\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * * {@link ChronoField.AMPM_OF_DAY}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {ChronoField|ChronoUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {ChronoField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        requireNonNull(field);\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as an `int`.\n     *\n     * This queries this time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this time, except {@link ChronoField.NANO_OF_DAY} and {@link ChronoField.MICRO_OF_DAY}\n     * which are too large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as a `long`.\n     *\n     * This queries this time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.from}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     *\n     * @param {ChronoField} field\n     * @returns {number}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.NANO_OF_SECOND: return this._nano;\n            case ChronoField.NANO_OF_DAY: return this.toNanoOfDay();\n            case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nano, 1000);\n            case ChronoField.MICRO_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n            case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nano, 1000000);\n            case ChronoField.MILLI_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n            case ChronoField.SECOND_OF_MINUTE: return this._second;\n            case ChronoField.SECOND_OF_DAY: return this.toSecondOfDay();\n            case ChronoField.MINUTE_OF_HOUR: return this._minute;\n            case ChronoField.MINUTE_OF_DAY: return this._hour * 60 + this._minute;\n            case ChronoField.HOUR_OF_AMPM: return MathUtil.intMod(this._hour, 12);\n            case ChronoField.CLOCK_HOUR_OF_AMPM: {\n                const ham = MathUtil.intMod(this._hour, 12);\n                return (ham % 12 === 0 ? 12 : ham);\n            }\n            case ChronoField.HOUR_OF_DAY: return this._hour;\n            case ChronoField.CLOCK_HOUR_OF_DAY: return (this._hour === 0 ? 24 : this._hour);\n            case ChronoField.AMPM_OF_DAY: return MathUtil.intDiv(this._hour, 12);\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._hour;\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._minute;\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._second;\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nano;\n    }\n\n    /**\n     * function overloading for {@link LocalDate.with}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.withTemporalAdjuster} is called.\n     * Otherwise {@link LocalTime.with2} is called.\n     *\n     * @param {!(TemporalAdjuster|ChronoField)} adjusterOrField\n     * @param {number} newValue - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length < 2){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this time.\n     *\n     * This returns a new {@link LocalTime}, based on this one, with the time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the hour field.\n     * A more complex adjuster might set the time to the last hour of the day.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing this as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalTime} a {@link LocalTime} based on this with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalTime) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the hour, minute or second.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the specified nano-of-second.\n     *  The hour, minute and second will be unchanged.\n     * * {@link ChronoField.NANO_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified nano-of-day.\n     *   This completely replaces the time and is equivalent to {@link ofNanoOfDay}.\n     * * {@link ChronoField.MICRO_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *   micro-of-second multiplied by 1,000.\n     *   The hour, minute and second will be unchanged.\n     * * {@link ChronoField.MICRO_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified micro-of-day.\n     *   This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n     *   with the micro-of-day multiplied by 1,000.\n     * * {@link ChronoField.MILLI_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *   milli-of-second multiplied by 1,000,000.\n     *   The hour, minute and second will be unchanged.\n     * * {@link ChronoField.MILLI_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified milli-of-day.\n     *   This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n     *   with the milli-of-day multiplied by 1,000,000.\n     * * {@link ChronoField.SECOND_OF_MINUTE} -\n     *   Returns a {@link LocalTime} with the specified second-of-minute.\n     *   The hour, minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.SECOND_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified second-of-day.\n     *   The nano-of-second will be unchanged.\n     * * {@link ChronoField.MINUTE_OF_HOUR} -\n     *   Returns a {@link LocalTime} with the specified minute-of-hour.\n     *   The hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.MINUTE_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified minute-of-day.\n     *   The second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.HOUR_OF_AMPM} -\n     *   Returns a {@link LocalTime} with the specified hour-of-am-pm.\n     *   The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM} -\n     *   Returns a {@link LocalTime} with the specified clock-hour-of-am-pm.\n     *   The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.HOUR_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified hour-of-day.\n     *   The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified clock-hour-of-day.\n     *   The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.AMPM_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified AM/PM.\n     *   The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing this as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalTime} a {@link LocalTime} based on this with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this.withNano(newValue);\n                case ChronoField.NANO_OF_DAY: return LocalTime.ofNanoOfDay(newValue);\n                case ChronoField.MICRO_OF_SECOND: return this.withNano(newValue * 1000);\n                case ChronoField.MICRO_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000);\n                case ChronoField.MILLI_OF_SECOND: return this.withNano( newValue * 1000000);\n                case ChronoField.MILLI_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000000);\n                case ChronoField.SECOND_OF_MINUTE: return this.withSecond(newValue);\n                case ChronoField.SECOND_OF_DAY: return this.plusSeconds(newValue - this.toSecondOfDay());\n                case ChronoField.MINUTE_OF_HOUR: return this.withMinute(newValue);\n                case ChronoField.MINUTE_OF_DAY: return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n                case ChronoField.HOUR_OF_AMPM: return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n                case ChronoField.CLOCK_HOUR_OF_AMPM: return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n                case ChronoField.HOUR_OF_DAY: return this.withHour(newValue);\n                case ChronoField.CLOCK_HOUR_OF_DAY: return this.withHour((newValue === 24 ? 0 : newValue));\n                case ChronoField.AMPM_OF_DAY: return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the hour-of-day value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [hour=0] - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour=0) {\n        if (this._hour === hour) {\n            return this;\n        }\n        return new LocalTime(hour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the minute-of-hour value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [minute=0] - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute=0) {\n        if (this._minute === minute) {\n            return this;\n        }\n        return new LocalTime(this._hour, minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the second-of-minute value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [second=0] - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second=0) {\n        if (this._second === second) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the nano-of-second value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nanos value is invalid\n     */\n    withNano(nanoOfSecond=0) {\n        if (this._nano === nanoOfSecond) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the time truncated.\n     *\n     * Truncating the time returns a copy of the original time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit.MINUTES} minutes unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit.DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!ChronoUnit} unit - the unit to truncate to, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        const unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        const dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        const nod = this.toNanoOfDay();\n        return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * function overloading for {@link LocalDate.plus}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.plus1} is called.\n     * Otherwise {@link LocalTime.plus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {ChronoUnit} unit - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    plus(amount, unit){\n        if(arguments.length < 2){\n            return this.plus1(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified period added.\n     *\n     * This method returns a new time based on this time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours added.\n     *\n     * This adds the specified number of hours to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToAdd - the hours to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours added, not null\n     */\n    plusHours(hoursToAdd) {\n        if (hoursToAdd === 0) {\n            return this;\n        }\n\n        const newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n        return new LocalTime(newHour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes added.\n     *\n     * This adds the specified number of minutes to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToAdd - the minutes to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes added, not null\n     */\n    plusMinutes(minutesToAdd) {\n        if (minutesToAdd === 0) {\n            return this;\n        }\n        const mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n        const newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n        if (mofd === newMofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n        const newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n        return new LocalTime(newHour, newMinute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds added.\n     *\n     * This adds the specified number of seconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondstoAdd - the seconds to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds added, not null\n     */\n    plusSeconds(secondstoAdd) {\n        if (secondstoAdd === 0) {\n            return this;\n        }\n        const sofd = this._hour * LocalTime.SECONDS_PER_HOUR +\n                    this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n        const newSofd = MathUtil.intMod((MathUtil.intMod(secondstoAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY), LocalTime.SECONDS_PER_DAY);\n        if (sofd === newSofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n        const newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        const newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n        return new LocalTime(newHour, newMinute, newSecond, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds added.\n     *\n     * This adds the specified number of nanoseconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanos to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds added, not null\n     */\n    plusNanos(nanosToAdd) {\n        if (nanosToAdd === 0) {\n            return this;\n        }\n        const nofd = this.toNanoOfDay();\n        const newNofd = MathUtil.intMod((MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY), LocalTime.NANOS_PER_DAY);\n        if (nofd === newNofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n        const newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        const newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n        const newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n        return new LocalTime(newHour, newMinute, newSecond, newNano);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.minus}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.minus1} is called.\n     * Otherwise {@link LocalTime.minus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {ChronoUnit} unit - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    minus(amount, unit){\n        if(arguments.length < 2){\n            return this.minus1(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     *\n     * This method returns a new time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     *\n     * This method returns a new time based on this time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {ChronoUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours subtracted.\n     *\n     * This subtracts the specified number of hours from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToSubtract - the hours to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours subtracted, not null\n     */\n    minusHours(hoursToSubtract) {\n        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes subtracted.\n     *\n     * This subtracts the specified number of minutes from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToSubtract - the minutes to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes subtracted, not null\n     */\n    minusMinutes(minutesToSubtract) {\n        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds subtracted.\n     *\n     * This subtracts the specified number of seconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds subtracted, not null\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds subtracted.\n     *\n     * This subtracts the specified number of nanoseconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract - the nanos to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds subtracted, not null\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this time using the specified query.\n     *\n     * This queries this time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localTime()) {\n            return this;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset() ||\n                query === TemporalQueries.localDate()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same time as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the time changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link ChronoField.NANO_OF_DAY} as the field.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalTime);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n    }\n\n    /**\n     * Calculates the period between this time and another time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two times in terms of a single unit.\n     * The start and end points are this and the specified time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalTime}.\n     * For example, the period in hours between two times can be calculated\n     * using {@link startTime.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two times.\n     * For example, the period in hours between 11:30 and 13:29 will only\n     * be one hour as it is one minute short of two hours.\n     *\n     * This method operates in association with {@link TemporalUnit.between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, HOURS);   // this method\n     *   dateTime.plus(HOURS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link ChronoUnit.NANOS}, {@link ChronoUnit.MICROS}, {@link ChronoUnit.MILLIS}, {@link ChronoUnit.SECONDS},\n     * {@link ChronoUnit.MINUTES}, {@link ChronoUnit.HOURS} and {@link ChronoUnit.HALF_DAYS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing this as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAccessor} endExclusive - the end time, which is converted to a {@link LocalTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this time and the end time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = LocalTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();  // no overflow\n            switch (unit) {\n                case ChronoUnit.NANOS: return nanosUntil;\n                case ChronoUnit.MICROS: return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS: return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(nanosUntil, (12 * LocalTime.NANOS_PER_HOUR));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this time with a date to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this time at the specified date.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalDate} date - the date to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this time and the specified date, not null\n     */\n    atDate(date) {\n        return LocalDateTime.of(date, this);\n    }\n\n    /**\n     * Combines this time with an offset to create an {@link OffsetTime}.\n     *\n     * This returns an {@link OffsetTime} formed from this time at the specified offset.\n     * All possible combinations of time and offset are valid.\n     *\n     * @param {OffsetTime} offset - the offset to combine with, not null\n     * @return {OffsetTime} the offset time formed from this time and the specified offset, not null\n     */\n    /*\n    atOffset(offset) {\n        return OffsetTime.of(this, offset);\n    }\n*/\n\n    //-----------------------------------------------------------------------\n    /**\n     * Extracts the time as seconds of day, from `0` to `24 * 60 * 60 - 1`.\n     *\n     * @return {number} the second-of-day equivalent to this time\n     */\n    toSecondOfDay() {\n        let total = this._hour * LocalTime.SECONDS_PER_HOUR;\n        total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n        total += this._second;\n        return total;\n    }\n\n    /**\n     * Extracts the time as nanos of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`.\n     *\n     * @return {number} the nano of day equivalent to this time\n     */\n    toNanoOfDay() {\n        let total = this._hour * LocalTime.NANOS_PER_HOUR;\n        total += this._minute * LocalTime.NANOS_PER_MINUTE;\n        total += this._second * LocalTime.NANOS_PER_SECOND;\n        total += this._nano;\n        return total;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this {@link LocalTime} to another time.\n     *\n     * The comparison is based on the time-line position of the local times within a day.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws {NullPointerException} if `other` is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalTime, 'other');\n        let cmp = MathUtil.compareNumbers(this._hour, other._hour);\n        if (cmp === 0) {\n            cmp = MathUtil.compareNumbers(this._minute, other._minute);\n            if (cmp === 0) {\n                cmp = MathUtil.compareNumbers(this._second, other._second);\n                if (cmp === 0) {\n                    cmp = MathUtil.compareNumbers(this._nano, other._nano);\n                }\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is after the specified time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean} true if this is after the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is before the specified time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean} true if this point is before the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this time is equal to another time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * Only objects of type {@link LocalTime} are compared, other types return false.\n     * To compare the date of two {@link TemporalAccessor} instances, use\n     * {@link ChronoField#NANO_OF_DAY} as a comparator.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalTime) {\n            return this._hour === other._hour && this._minute === other._minute &&\n                this._second === other._second && this._nano === other._nano;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const nod = this.toNanoOfDay();\n        return MathUtil.hash(nod);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this time as a string, such as `10:15`.\n     *\n     * The output will be one of the following ISO-8601 formats:\n     *\n     * * {@link HH:mm}\n     * * {@link HH:mm:ss}\n     * * {@link HH:mm:ss.SSS}\n     * * {@link HH:mm:ss.SSSSSS}\n     * * {@link HH:mm:ss.SSSSSSSSS}\n     *\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this time, not null\n     */\n    toString() {\n        let buf = '';\n        const hourValue = this._hour;\n        const minuteValue = this._minute;\n        const secondValue = this._second;\n        const nanoValue = this._nano;\n        buf += hourValue < 10 ? '0' : '';\n        buf += hourValue;\n        buf += minuteValue < 10 ? ':0' : ':';\n        buf += minuteValue;\n        if (secondValue > 0 || nanoValue > 0) {\n            buf += secondValue < 10 ? ':0' : ':';\n            buf += secondValue;\n            if (nanoValue > 0) {\n                buf += '.';\n                if(MathUtil.intMod(nanoValue, 1000000) === 0) {\n                    buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n                } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n                    buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n                } else {\n                    buf += ('' + (nanoValue + 1000000000)).substring(1);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this time as a string using the formatter.\n     *\n     * @param {DateTineFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n\nexport function _init() {\n    /**\n     * Constants for the local time of each hour.\n     */\n    LocalTime.HOURS = [];\n    for (let hour = 0; hour < 24; hour++) {\n        LocalTime.of(hour, 0, 0, 0);\n    }\n\n    /**\n     * The minimum supported {@link LocalTime}, '00:00'.\n     * This is the time of midnight at the start of the day.\n     */\n    LocalTime.MIN = LocalTime.HOURS[0];\n    /**\n     * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n     * This is the time just before midnight at the end of the day.\n     */\n    LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);\n    /**\n     * The time of midnight at the start of the day, '00:00'.\n     */\n    LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n    /**\n     * The time of noon in the middle of the day, '12:00'.\n     */\n    LocalTime.NOON = LocalTime.HOURS[12];\n\n    LocalTime.FROM = createTemporalQuery('LocalTime.FROM', (temporal) => {\n        return LocalTime.from(temporal);\n    });\n}\n\n/**\n * Hours per day.\n */\nLocalTime.HOURS_PER_DAY = 24;\n/**\n * Minutes per hour.\n */\nLocalTime.MINUTES_PER_HOUR = 60;\n/**\n * Minutes per day.\n */\nLocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\n/**\n * Seconds per minute.\n */\nLocalTime.SECONDS_PER_MINUTE = 60;\n/**\n * Seconds per hour.\n */\nLocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n/**\n * Seconds per day.\n */\nLocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n/**\n * Milliseconds per day.\n */\nLocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\n/**\n * Microseconds per day.\n */\nLocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\n/**\n * Nanos per second.\n */\nLocalTime.NANOS_PER_SECOND = 1000000000;\n/**\n * Nanos per minute.\n */\nLocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\n/**\n * Nanos per hour.\n */\nLocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n/**\n * Nanos per day.\n */\nLocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalTime} from './LocalTime';\nimport {ZonedDateTime} from './ZonedDateTime';\nimport {MathUtil} from './MathUtil';\n\nimport {Temporal} from './temporal/Temporal';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {TemporalUnit} from './temporal/TemporalUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nconst NANOS_PER_MILLI = 1000000;\n\n/**\n * An instantaneous point on the time-line.\n *\n * This class models a single instantaneous point on the time-line.\n * This might be used to record event time-stamps in the application.\n *\n * Time-scale\n *\n * The length of the solar day is the standard way that humans measure time.\n * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,\n * forming a 86400 second day.\n *\n * Modern timekeeping is based on atomic clocks which precisely define an SI second\n * relative to the transitions of a Caesium atom. The length of an SI second was defined\n * to be very close to the 86400th fraction of a day.\n *\n * Unfortunately, as the Earth rotates the length of the day varies.\n * In addition, over time the average length of the day is getting longer as the Earth slows.\n * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.\n * The actual length of any given day and the amount by which the Earth is slowing\n * are not predictable and can only be determined by measurement.\n * The UT1 time-scale captures the accurate length of day, but is only available some\n * time after the day has completed.\n *\n * The UTC time-scale is a standard approach to bundle up all the additional fractions\n * of a second from UT1 into whole seconds, known as *leap-seconds*.\n * A leap-second may be added or removed depending on the Earth's rotational changes.\n * As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where\n * necessary in order to keep the day aligned with the Sun.\n *\n * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.\n * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and\n * alterations to the length of the notional second. As of 2012, discussions are underway\n * to change the definition of UTC again, with the potential to remove leap seconds or\n * introduce other changes.\n *\n * Given the complexity of accurate timekeeping described above, this Java API defines\n * its own time-scale, the *Java Time-Scale*.\n *\n * The Java Time-Scale divides each calendar day into exactly 86400\n * subdivisions, known as seconds.  These seconds may differ from the\n * SI second.  It closely matches the de facto international civil time\n * scale, the definition of which changes from time to time.\n *\n * The Java Time-Scale has slightly different definitions for different\n * segments of the time-line, each based on the consensus international\n * time scale that is used as the basis for civil time. Whenever the\n * internationally-agreed time scale is modified or replaced, a new\n * segment of the Java Time-Scale must be defined for it.  Each segment\n * must meet these requirements:\n *\n * * the Java Time-Scale shall closely match the underlying international\n *   civil time scale;\n * * the Java Time-Scale shall exactly match the international civil\n *   time scale at noon each day;\n * * the Java Time-Scale shall have a precisely-defined relationship to\n *   the international civil time scale.\n *\n * There are currently, as of 2013, two segments in the Java time-scale.\n *\n * For the segment from 1972-11-03 (exact boundary discussed below) until\n * further notice, the consensus international time scale is UTC (with\n * leap seconds).  In this segment, the Java Time-Scale is identical to\n * [UTC-SLS](http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/).\n * This is identical to UTC on days that do not have a leap second.\n * On days that do have a leap second, the leap second is spread equally\n * over the last 1000 seconds of the day, maintaining the appearance of\n * exactly 86400 seconds per day.\n *\n * For the segment prior to 1972-11-03, extending back arbitrarily far,\n * the consensus international time scale is defined to be UT1, applied\n * proleptically, which is equivalent to the (mean) solar time on the\n * prime meridian (Greenwich). In this segment, the Java Time-Scale is\n * identical to the consensus international time scale. The exact\n * boundary between the two segments is the instant where UT1 = UTC\n * between 1972-11-03T00:00 and 1972-11-04T12:00.\n *\n * Implementations of the Java time-scale using the JSR-310 API are not\n * required to provide any clock that is sub-second accurate, or that\n * progresses monotonically or smoothly. Implementations are therefore\n * not required to actually perform the UTC-SLS slew or to otherwise be\n * aware of leap seconds. JSR-310 does, however, require that\n * implementations must document the approach they use when defining a\n * clock representing the current instant.\n * See {@link Clock} for details on the available clocks.\n *\n * The Java time-scale is used for all date-time classes.\n * This includes {@link Instant}, {@link LocalDate}, {@link LocalTime}, {@link OffsetDateTime},\n * {@link ZonedDateTime} and {@link Duration}.\n *\n * ### Static properties of Class {@link Instant}\n *\n * Instant.EPOCH\n *\n * Instant.MIN\n *\n * Instant.MAX\n *\n * Instant.MIN_SECONDS\n *\n * Instant.MAX_SECONDS\n *\n */\nexport class Instant extends Temporal {\n\n    /**\n     * Obtains the current instant from the system clock, or if specified\n     * the current instant from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     *\n     * @param {Clock} [clock=Clock.systemUTC()] - the clock to use, defaults to the system clock\n     * @return {Instant} the current instant, not null\n     */\n    static now(clock = Clock.systemUTC()){\n        return clock.instant();\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from 1970-01-01T00:00:00Z\n     * @param {number} nanoAdjustment nanoseconds start from the start of epochSecond, if null the nanosecond field is set to zero.\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochSecond(epochSecond, nanoAdjustment=0){\n        const secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Instant._create(secs, nos);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using milliseconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {number} epochMilli - the number of milliseconds from 1970-01-01T00:00:00Z\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochMilli(epochMilli) {\n        const secs = MathUtil.floorDiv(epochMilli, 1000);\n        const mos = MathUtil.floorMod(epochMilli, 1000);\n        return Instant._create(secs, mos * 1000000);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link Instant}.\n     *\n     * The conversion extracts the {@link ChronoField#INSTANT_SECONDS}\n     * and {@link ChronoField#NANO_OF_SECOND} fields.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link Instant::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {Instant} the instant, not null\n     * @throws DateTimeException if unable to convert to an {@link Instant}\n     */\n    static from(temporal) {\n        try {\n            const instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n            const nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n            return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' +\n                    temporal + ', type ' + typeof temporal, ex);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} from a text string such as\n     * `2007-12-03T10:15:30.000Z`.\n     *\n     * The string must represent a valid instant in UTC and is parsed using\n     * {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Instant} the parsed instant, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text) {\n        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @returns {Instant}\n     * @private\n     */\n    static _create(seconds, nanoOfSecond){\n        if(seconds === 0 && nanoOfSecond === 0){\n            return Instant.EPOCH;\n        }\n        return new Instant(seconds, nanoOfSecond);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    static _validate(seconds, nanoOfSecond){\n        if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    constructor(seconds, nanoOfSecond){\n        super();\n        Instant._validate(seconds, nanoOfSecond);\n        this._seconds = MathUtil.safeToInt(seconds);\n        this._nanos = MathUtil.safeToInt(nanoOfSecond);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this instant can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link NANO_OF_SECOND}\n     * * {@link MICRO_OF_SECOND}\n     * * {@link MILLI_OF_SECOND}\n     * * {@link INSTANT_SECONDS}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this instant, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This instant is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as an `int`.\n     *\n     * This queries this instant for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link INSTANT_SECONDS} which is too\n     * large to fit in an `int` and throws a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as a `long`.\n     *\n     * This queries this instant for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this._nanos;\n                case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nanos, 1000);\n                case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n                case ChronoField.INSTANT_SECONDS: return this._seconds;\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.\n     *\n     * The epoch second count is a simple incrementing count of seconds where\n     * second 0 is 1970-01-01T00:00:00Z.\n     * The nanosecond part of the day is returned by {@link getNanosOfSecond}.\n     *\n     * @return {number} the seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    epochSecond(){\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds, later along the time-line, from the start\n     * of the second.\n     *\n     * The nanosecond-of-second value measures the total number of nanoseconds from\n     * the second returned by {@link getEpochSecond}.\n     *\n     * @return {number} the nanoseconds within the second, always positive, never exceeds 999,999,999\n     */\n    nano(){\n        return this._nanos;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * function overloading for {@link Instant.with}\n     *\n     * if called with 1 argument {@link Instant.withTemporalAdjuster} is called\n     * otherwise {@link Instant.with2}\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue\n     * @returns {Instant}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n    /**\n     * Returns an adjusted copy of this instant.\n     *\n     * This returns a new {@link Instant}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {Instant} an {@link Instant} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified field set to a new value.\n     *\n     * This returns a new {@link Instant}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link NANO_OF_SECOND} -\n     *  Returns an {@link Instant} with the specified nano-of-second.\n     *  The epoch-second will be unchanged.\n     * * {@link MICRO_OF_SECOND} -\n     *  Returns an {@link Instant} with the nano-of-second replaced by the specified\n     *  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.\n     * * {@link MILLI_OF_SECOND} -\n     *  Returns an {@link Instant} with the nano-of-second replaced by the specified\n     *  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.\n     * * {@link INSTANT_SECONDS} -\n     *  Returns an {@link Instant} with the specified epoch-second.\n     *  The nano-of-second will be unchanged.\n     *\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {Instant} an {@link Instant} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.MILLI_OF_SECOND: {\n                    const nval = newValue * NANOS_PER_MILLI;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.MICRO_OF_SECOND: {\n                    const nval = newValue * 1000;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.NANO_OF_SECOND: return (newValue !== this._nanos? Instant._create(this._seconds, newValue) : this);\n                case ChronoField.INSTANT_SECONDS: return (newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link Instant} truncated to the specified unit.\n     *\n     * Truncating the instant returns a copy of the original with fields\n     * smaller than the specified unit set to zero.\n     * The fields are calculated on the basis of using a UTC offset as seen\n     * in {@link toString}.\n     * For example, truncating with {@link ChronoUnit#MINUTES} will\n     * round down to the nearest minute, setting the seconds and nanoseconds to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalUnit} unit - the unit to truncate to, not null\n     * @return {Instant} an {@link Instant} based on this instant with the time truncated, not null\n     * @throws DateTimeException if the unit is invalid for truncation\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        const unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        const dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        const nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n        const result = MathUtil.intDiv(nod, dur) * dur;\n        return this.plusNanos(result - nod);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {TemporalAmount|number} amount\n     * @param {TemporalUnit} unit - only required if first param is a TemporalAmount\n     * @return {Instant}\n     */\n    plus(amount, unit){\n        if(arguments.length === 1){\n            return this.plus1(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * @param {!TemporalAmount} amount\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {!number} amountToAdd\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n                case ChronoUnit.HOURS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.HALF_DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n                case ChronoUnit.DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd  the seconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusSeconds(secondsToAdd) {\n        return this._plus(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified milliseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusNanos(nanosToAdd) {\n        return this._plus(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd - the seconds to add, positive or negative\n     * @param {number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    _plus(secondsToAdd, nanosToAdd) {\n        if ((secondsToAdd | nanosToAdd) === 0) {\n            return this;\n        }\n        let epochSec = this._seconds + secondsToAdd;\n        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n        return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {TemporalAmount|number} amount\n     * @param {TemporalUnit} unit - only required if first param is a TemporalAmount\n     * @return {Instant}\n     */\n    minus(amount, unit){\n        if(arguments.length === 1){\n            return this.minus1(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * @param {!TemporalAmount} amount\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {!number} amountToSubtract\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    minus2(amountToSubtract, unit) {\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(secondsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified milliseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return this.plusMillis(-1 * millisToSubtract);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract  the nanoseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * nanosToSubtract);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Queries this instant using the specified query.\n     *\n     * This queries this instant using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {!TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this instant.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the instant changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#INSTANT_SECONDS} and\n     * {@link ChronoField#NANO_OF_SECOND} as the fields.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisInstant.adjustInto(temporal);\n     *   temporal = temporal.with(thisInstant);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n    }\n\n    /**\n     * Calculates the period between this instant and another instant in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two instants in terms of a single unit.\n     * The start and end points are `this` and the specified instant.\n     * The result will be negative if the end is before the start.\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two instants.\n     * The {@link Temporal} passed to this method is converted to a\n     * {@link Instant} using {@link from}.\n     * For example, the period in days between two dates can be calculated\n     * using `startInstant.until(endInstant, SECONDS)`.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, SECONDS);   // this method\n     *   dateTime.plus(SECONDS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS}, {@link HALF_DAYS} and {@link DAYS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date, which is converted to an {@link Instant}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = Instant.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this._nanosUntil(end);\n                case ChronoUnit.MICROS: return MathUtil.intDiv(this._nanosUntil(end), 1000);\n                case ChronoUnit.MILLIS: return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n                case ChronoUnit.SECONDS: return this._secondsUntil(end);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(this._secondsUntil(end), (12 * LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.DAYS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _nanosUntil(end) {\n        const secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        const totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _secondsUntil(end) {\n        let secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        const nanosDiff = end.nano() - this.nano();\n        if (secsDiff > 0 && nanosDiff < 0) {\n            secsDiff--;\n        } else if (secsDiff < 0 && nanosDiff > 0) {\n            secsDiff++;\n        }\n        return secsDiff;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this instant with an offset to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this instant at the\n     * specified offset from UTC/Greenwich. An exception will be thrown if the\n     * instant is too large to fit into an offset date-time.\n     *\n     * This method is equivalent to {@link OffsetDateTime#ofInstant}.\n     *\n     * @param {ZoneOffset} offset - the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this instant and the specified offset, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    //atOffset(offset) {\n    //    return OffsetDateTime.ofInstant(this, offset);\n    //}\n\n    /**\n     * Combines this instant with a time-zone to create a {@link ZonedDateTime}.\n     *\n     * This returns an {@link ZonedDateTime} formed from this instant at the\n     * specified time-zone. An exception will be thrown if the instant is too\n     * large to fit into a zoned date-time.\n     *\n     * This method is equivalent to {@link ZonedDateTime#ofInstant}.\n     *\n     * @param {ZoneId} zone - the zone to combine with, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this instant and the specified zone, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    atZone(zone) {\n        return ZonedDateTime.ofInstant(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this instant to the number of milliseconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * If this instant represents a point on the time-line too far in the future\n     * or past to fit in a `long` milliseconds, then an exception is thrown.\n     *\n     * If this instant has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the number of milliseconds since the epoch of 1970-01-01T00:00:00Z\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toEpochMilli() {\n        const millis = MathUtil.safeMultiply(this._seconds, 1000);\n        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this instant to the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws NullPointerException if otherInstant is null\n     */\n    compareTo(otherInstant) {\n        requireNonNull(otherInstant, 'otherInstant');\n        requireInstance(otherInstant, Instant, 'otherInstant');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherInstant._nanos;\n    }\n\n    /**\n     * Checks if this instant is after the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isAfter(otherInstant) {\n        return this.compareTo(otherInstant) > 0;\n    }\n\n    /**\n     * Checks if this instant is before the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isBefore(otherInstant) {\n        return this.compareTo(otherInstant) < 0;\n    }\n\n    /**\n     * Checks if this instant is equal to the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {*} otherInstant - the other instant, null/ undefined returns false\n     * @return {boolean} true if the other instant is equal to this one\n     */\n    equals(otherInstant) {\n        if(this === otherInstant){\n            return true;\n        }\n        if(otherInstant instanceof Instant){\n            return this.epochSecond() === otherInstant.epochSecond() &&\n                this.nano() === otherInstant.nano();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code for this instant.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._seconds, this._nanos);\n    }\n\n    /**\n     * A string representation of this instant using ISO-8601 representation.\n     *\n     * The format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @return {string} an ISO-8601 representation of this instant, not null\n     */\n    toString(){\n        return DateTimeFormatter.ISO_INSTANT.format(this);\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDate.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nexport function _init() {\n    Instant.MIN_SECONDS = -31619119219200; // -1000000-01-01T00:00:00Z\n    Instant.MAX_SECONDS = 31494816403199; // +1000000-12-31T23:59:59.999999999Z\n    Instant.EPOCH = new Instant(0, 0);\n    Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n    Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n    Instant.FROM = createTemporalQuery('Instant.FROM', (temporal) => {\n        return Instant.from(temporal);\n    });\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail, requireNonNull} from './assert';\nimport {Instant} from './Instant';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n/**\n * A clock providing access to the current instant, date and time using a time-zone.\n *\n * Instances of this class are used to find the current instant, which can be\n * interpreted using the stored time-zone to find the current date and time.\n * As such, a clock can be used instead of {@link System#currentTimeMillis}\n * and {@link TimeZone#getDefault}.\n *\n * Use of a {@link Clock} is optional. All key date-time classes also have a\n * `now()` factory method that uses the system clock in the default time zone.\n * The primary purpose of this abstraction is to allow alternate clocks to be\n * plugged in as and when required. Applications use an object to obtain the\n * current time rather than a static method. This can simplify testing.\n *\n * Best practice for applications is to pass a {@link Clock} into any method\n * that requires the current instant.\n *\n * This approach allows an alternate clock, such as {@link fixed}\n * or {@link offset} to be used during testing.\n *\n * The {@link system} factory methods provide clocks based on the best available\n * system clock This may use {@link System#currentTimeMillis}, or a higher\n * resolution clock if one is available.\n *\n * The javascript Clock implementation differs from the openjdk.\n *\n * Javascript only provides the UTC millis of epoch and the ZoneOffset in minutes of the system default time.\n * Javascript do not provide the system default ZoneId.\n *\n * the system default ZoneId is only guessable by the ZoneOffset, like moment-timezone does by returning one ZoneId\n * with the same ZoneOffset.\n *\n * Therefore we are doing a shortcut here, by defining a SystemUTCClock and a SystemDefaultClock, the Clock itself\n * is returning the ZoneOffset and not the ZoneRules as in the jdk. We should change it, when introducing the iana\n * timezone database and implementing the timezone domains.\n *\n */\n\nexport class Clock {\n    /**\n     * Obtains a clock that returns the current instant using the\n     * system clock, converting to date and time using the Date.getTime() UTC millis.\n     *\n     * This clock, rather than {@link systemDefaultZone}, should be used when\n     * you need the current instant without the date or time.\n     *\n     * @return {Clock} a clock that uses the system clock in the UTC zone, not null\n     */\n    static systemUTC() {\n        return new SystemClock(ZoneOffset.UTC);\n    }\n\n    /**\n     * Obtains a clock that returns the current instant using the best available\n     * system clock, converting to date and time using the default time-zone.\n     *\n     * This clock is based on the available system clock using the Date.getTime() UTC millis\n     *\n     * Using this method hard codes a dependency to the default time-zone into your application.\n     *\n     * The UTC clock (see {@link systemUTC}) should be used when you need the current instant\n     * without the date or time.\n     *\n     *\n     * @return {Clock} a clock that uses the system clock in the default zone, not null\n     * @see ZoneId#systemDefault()\n     */\n    static systemDefaultZone() {\n        return new SystemClock(ZoneId.systemDefault());\n    }\n\n    /**\n     *\n     * @param {ZoneId} zone\n     * @return {Clock} a clock that uses the specified time zone\n     */\n    static system(zone){\n        return new SystemClock(zone);\n    }\n\n    /**\n     * Obtains a clock that always returns the same instant.\n     *\n     * This clock simply returns the specified instant.\n     * As such, it is not a clock in the conventional sense.\n     * The main use case for this is in testing, where the fixed clock ensures\n     * tests are not dependent on the current clock.\n     *\n     * @param {Instant} fixedInstant  the instant to use as the clock, not null\n     * @param {ZoneId} zoneId  the zoneOffset to use as zone Offset, not null\n     * @return {Clock} a clock that always returns the same instant, not null\n     */\n    static fixed(fixedInstant, zoneId) {\n        return new FixedClock(fixedInstant, zoneId);\n    }\n    \n    /**\n     * Obtains a clock that returns instants from the specified clock with the\n     * specified duration added\n     * <p>\n     * This clock wraps another clock, returning instants that are later by the\n     * specified duration. If the duration is negative, the instants will be\n     * earlier than the current date and time.\n     * The main use case for this is to simulate running in the future or in the past.\n     * <p>\n     * A duration of zero would have no offsetting effect.\n     * Passing zero will return the underlying clock.\n     * <p>\n     * The returned implementation is immutable, thread-safe and {@code Serializable}\n     * providing that the base clock is.\n     *\n     * @param baseClock  the base clock to add the duration to, not null\n     * @param offsetDuration  the duration to add, not null\n     * @return a clock based on the base clock with the duration added, not null\n     */\n    static offset(baseClock, duration) {\n        return new OffsetClock(baseClock, duration);   \n    }\n\n    /**\n      * Gets the current millisecond instant of the clock.\n      *\n      * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n      * This is equivalent to the definition of {@link Date#getTime}.\n      *\n      * Most applications should avoid this method and use {@link Instant} to represent\n      * an instant on the time-line rather than a raw millisecond value.\n      * This method is provided to allow the use of the clock in high performance use cases\n      * where the creation of an object would be unacceptable.\n      *\n      * The default implementation currently calls {@link instant}.\n      *\n      * @return the current millisecond instant from this clock, measured from\n      *  the Java epoch of 1970-01-01T00:00Z (UTC), not null\n      */\n    millis(){\n        abstractMethodFail('Clock.millis');\n    }\n\n    /**\n     * Gets the current instant of the clock.\n     *\n     * This returns an instant representing the current instant as defined by the clock.\n     *\n     * @return {Instant} the current instant from this clock, not null\n     */\n    instant(){\n        abstractMethodFail('Clock.instant');\n    }\n\n    zone(){\n        abstractMethodFail('Clock.zone');\n    }\n    \n    /**\n     * Returns a copy of this clock with a different time-zone.\n     * <p>\n     * A clock will typically obtain the current instant and then convert that\n     * to a date or time using a time-zone. This method returns a clock with\n     * similar properties but using a different time-zone.\n     *\n     * @param zone  the time-zone to change to, not null\n     * @return a clock based on this clock with the specified time-zone, not null\n     */\n    withZone(){\n        abstractMethodFail('Clock.withZone');\n    }\n}\n\n/**\n * Implementation of a clock that always returns the latest time from\n * {@link Date#getTime}.\n *\n * @private\n */\nclass SystemClock extends Clock {\n    /**\n     *\n     * @param {!ZoneId} zone\n     */\n    constructor(zone){\n        requireNonNull(zone, 'zone');\n        super();\n        this._zone = zone;\n    }\n\n    /**\n     *\n     * @returns {!ZoneId}\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    millis() {\n        return new Date().getTime();\n    }\n\n    /**\n     *\n     * @returns {Instant}\n     */\n    instant() {\n        return Instant.ofEpochMilli(this.millis());\n    }\n    \n    equals(obj) {    \n        if (obj instanceof SystemClock) {            \n            return this._zone.equals(obj._zone);\n        }\n        return false;    \n    }  \n      \n    withZone(zone) {\n        if (zone.equals(this._zone)) {  // intentional NPE\n            return this;\n        }\n        return new SystemClock(zone);\n    }      \n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return 'SystemClock[' + this._zone.toString() + ']';\n    }\n\n}\n\n/**\n * Implementation of a clock that always returns the same instant.\n * This is typically used for testing.\n * @private\n */\nclass FixedClock extends Clock{\n    constructor(fixedInstant, zoneId) {\n        super();\n        this._instant = fixedInstant;\n        this._zoneId = zoneId;\n    }\n\n    instant() {\n        return this._instant;\n    }\n\n    millis(){\n        return this._instant.toEpochMilli();\n    }\n\n    zone() {\n        return this._zoneId;\n    }\n\n    toString(){\n        return 'FixedClock[]';\n    }\n    \n    equals(obj) {    \n        if (obj instanceof FixedClock) {            \n            return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);\n        }\n        return false;    \n    }\n\n    withZone(zone) {\n        if (zone.equals(this._zoneId)) {  // intentional NPE\n            return this;\n        }\n        return new FixedClock(this._instant, zone);\n    }      \n    \n}\n\n\n/**\n * Implementation of a clock that adds an offset to an underlying clock.\n */\nclass OffsetClock extends Clock {\n    constructor(baseClock, offset) {\n        super();\n        this._baseClock = baseClock;\n        this._offset = offset;\n    }\n   \n    zone() {\n        return this._baseClock.zone();\n    }\n        \n    withZone(zone) {\n        if (zone.equals(this._baseClock.zone())) {  // intentional NPE\n            return this;\n        }\n        return new OffsetClock(this._baseClock.withZone(zone), this._offset);\n    }\n    \n    millis() {\n        return this._baseClock.millis() + this._offset.toMillis();\n    }\n    \n    instant() {\n        return this._baseClock.instant().plus(this._offset);\n    }\n        \n    equals(obj) {\n        if (obj instanceof OffsetClock) {            \n            return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);\n        }\n        return false;\n    }\n    \n    toString() {\n        return 'OffsetClock[' + this._baseClock + ',' + this._offset + ']';\n    }\n}","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {IllegalArgumentException} from '../errors';\n\nimport {Duration} from '../Duration';\nimport {LocalDateTime} from '../LocalDateTime';\n\n/**\n * A transition between two offsets caused by a discontinuity in the local time-line.\n *\n * A transition between two offsets is normally the result of a daylight savings cutover.\n * The discontinuity is normally a gap in spring and an overlap in autumn.\n * {@link ZoneOffsetTransition} models the transition between the two offsets.\n *\n * Gaps occur where there are local date-times that simply do not not exist.\n * An example would be when the offset changes from `+03:00` to `+04:00`.\n * This might be described as 'the clocks will move forward one hour tonight at 1am'.\n *\n * Overlaps occur where there are local date-times that exist twice.\n * An example would be when the offset changes from `+04:00` to `+03:00`.\n * This might be described as 'the clocks will move back one hour tonight at 2am'.\n *\n */\nexport class ZoneOffsetTransition {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance defining a transition between two offsets.\n     *\n     * Applications should normally obtain an instance from {@link ZoneRules}.\n     * This factory is only intended for use when creating {@link ZoneRules}.\n     *\n     * @param {LocalDateTime} transition - the transition date-time at the transition, which never\n     *  actually occurs, expressed local to the before offset, not null\n     * @param {ZoneOffset} offsetBefore - the offset before the transition, not null\n     * @param {ZoneOffset} offsetAfter - the offset at and after the transition, not null\n     * @return {ZoneOffsetTransition} the transition, not null\n     * @throws IllegalArgumentException if {@link offsetBefore} and {@link offsetAfter}\n     *         are equal, or {@link transition.getNano} returns non-zero value\n     */\n    static of(transition, offsetBefore, offsetAfter) {\n        return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);\n    }\n\n    /**\n     * Creates an instance defining a transition between two offsets.\n     * Creates an instance from epoch-second if transition is not a LocalDateTimeInstance\n     *\n     * @param {(LocalDateTime \\ number)} transition - the transition date-time with the offset before the transition, not null\n     * @param {ZoneOffset} offsetBefore - the offset before the transition, not null\n     * @param {ZoneOffset} offsetAfter - the offset at and after the transition, not null\n     * @private\n     */\n    constructor(transition, offsetBefore, offsetAfter) {\n        requireNonNull(transition, 'transition');\n        requireNonNull(offsetBefore, 'offsetBefore');\n        requireNonNull(offsetAfter, 'offsetAfter');\n        if (offsetBefore.equals(offsetAfter)) {\n            throw new IllegalArgumentException('Offsets must not be equal');\n        }\n        if (transition.nano() !== 0) {\n            throw new IllegalArgumentException('Nano-of-second must be zero');\n        }\n        if(transition instanceof LocalDateTime) {\n            this._transition = transition;\n        } else {\n            this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);\n        }\n        this._offsetBefore = offsetBefore;\n        this._offsetAfter = offsetAfter;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the transition instant.\n     *\n     * This is the instant of the discontinuity, which is defined as the first\n     * instant that the 'after' offset applies.\n     *\n     * The methods {@link getInstant}, {@link getDateTimeBefore} and {@link getDateTimeAfter}\n     * all represent the same instant.\n     *\n     * @return {Instant} the transition instant, not null\n     */\n    instant() {\n        return this._transition.toInstant(this._offsetBefore);\n    }\n\n    /**\n     * Gets the transition instant as an epoch second.\n     *\n     * @return {number} the transition epoch second\n     */\n    toEpochSecond() {\n        return this._transition.toEpochSecond(this._offsetBefore);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Gets the local transition date-time, as would be expressed with the 'before' offset.\n     *\n     * This is the date-time where the discontinuity begins expressed with the 'before' offset.\n     * At this instant, the 'after' offset is actually used, therefore the combination of this\n     * date-time and the 'before' offset will never occur.\n     *\n     * The combination of the 'before' date-time and offset represents the same instant\n     * as the 'after' date-time and offset.\n     *\n     * @return {LocalDateTime} the transition date-time expressed with the before offset, not null\n     */\n    dateTimeBefore(){\n        return this._transition;\n    }\n\n    /**\n     * Gets the local transition date-time, as would be expressed with the 'after' offset.\n     *\n     * This is the first date-time after the discontinuity, when the new offset applies.\n     *\n     * The combination of the 'before' date-time and offset represents the same instant\n     * as the 'after' date-time and offset.\n     *\n     * @return {LocalDateTime} the transition date-time expressed with the after offset, not null\n     */\n    dateTimeAfter() {\n        return this._transition.plusSeconds(this.durationSeconds());\n    }\n\n    /**\n     * Gets the offset before the transition.\n     *\n     * This is the offset in use before the instant of the transition.\n     *\n     * @return {ZoneOffset} the offset before the transition, not null\n     */\n    offsetBefore() {\n        return this._offsetBefore;\n    }\n\n    /**\n     * Gets the offset after the transition.\n     *\n     * This is the offset in use on and after the instant of the transition.\n     *\n     * @return {ZoneOffset} the offset after the transition, not null\n     */\n    offsetAfter() {\n        return this._offsetAfter;\n    }\n\n    /**\n     * Gets the duration of the transition.\n     *\n     * In most cases, the transition duration is one hour, however this is not always the case.\n     * The duration will be positive for a gap and negative for an overlap.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @return {Duration} the duration of the transition, positive for gaps, negative for overlaps\n     */\n    duration() {\n        return Duration.ofSeconds(this.durationSeconds());\n    }\n\n    /**\n     * Gets the duration of the transition in seconds.\n     *\n     * @return {number} the duration in seconds\n     */\n    durationSeconds() {\n        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();\n    }\n\n    /**\n     * Does this transition represent a gap in the local time-line.\n     *\n     * Gaps occur where there are local date-times that simply do not not exist.\n     * An example would be when the offset changes from `+01:00` to `+02:00`.\n     * This might be described as 'the clocks will move forward one hour tonight at 1am'.\n     *\n     * @return {boolean} true if this transition is a gap, false if it is an overlap\n     */\n    isGap() {\n        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();\n    }\n\n    /**\n     * Does this transition represent a gap in the local time-line.\n     *\n     * Overlaps occur where there are local date-times that exist twice.\n     * An example would be when the offset changes from `+02:00` to `+01:00`.\n     * This might be described as 'the clocks will move back one hour tonight at 2am'.\n     *\n     * @return {boolean} true if this transition is an overlap, false if it is a gap\n     */\n    isOverlap() {\n        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();\n    }\n\n    /**\n     * Checks if the specified offset is valid during this transition.\n     *\n     * This checks to see if the given offset will be valid at some point in the transition.\n     * A gap will always return false.\n     * An overlap will return true if the offset is either the before or after offset.\n     *\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset is valid during the transition\n     */\n    isValidOffset(offset) {\n        return this.isGap() ? false : (this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset));\n    }\n\n    /**\n     * Gets the valid offsets during this transition.\n     *\n     * A gap will return an empty list, while an overlap will return both offsets.\n     *\n     * @return {ZoneOffset[]} the list of valid offsets\n     */\n    validOffsets() {\n        if (this.isGap()){\n            return [];\n        } else {\n            return [this._offsetBefore, this._offsetAfter];\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this transition to another based on the transition instant.\n     *\n     * This compares the instants of each transition.\n     * The offsets are ignored, making this order inconsistent with equals.\n     *\n     * @param {ZoneOffsetTransition} transition - the transition to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(transition) {\n        return this.instant().compareTo(transition.instant());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this object equals another.\n     *\n     * The entire state of the object is compared.\n     *\n     * @param {*} other - the other object to compare to, null returns false\n     * @return true if equal\n     */\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ZoneOffsetTransition) {\n            const d = other;\n            return this._transition.equals(d._transition) &&\n                this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());\n        }\n        return false;\n    }\n\n    /**\n     * Returns a suitable hash code.\n     *\n     * @return {number} the hash code\n     */\n    hashCode() {\n        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ (this._offsetAfter.hashCode()>>>16);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a string describing this object.\n     *\n     * @return {string} a string for debugging, not null\n     */\n    toString() {\n        return 'Transition[' + (this.isGap() ? 'Gap' : 'Overlap') +\n            ' at ' + this._transition.toString() + this._offsetBefore.toString() +\n            ' to ' + this._offsetAfter + ']';\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ChronoField} from './ChronoField';\nimport {createTemporalQuery} from './TemporalQuery';\nimport {TemporalQueries} from './TemporalQueries';\n\nimport {LocalDate} from '../LocalDate';\nimport {LocalTime} from '../LocalTime';\nimport {ZoneOffset} from '../ZoneOffset';\n\n\nexport function _init() {\n    //-----------------------------------------------------------------------\n    /**\n     * A strict query for the {@link ZoneId}.\n     */\n    TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', (temporal) => {\n        return temporal.query(TemporalQueries.ZONE_ID);\n    });\n\n    /**\n     * A query for the {@link Chronology}.\n     */\n    TemporalQueries.CHRONO = createTemporalQuery('CHRONO', (temporal) => {\n        return temporal.query(TemporalQueries.CHRONO);\n    });\n\n    /**\n     * A query for the smallest supported unit.\n     */\n    TemporalQueries.PRECISION = createTemporalQuery('PRECISION', (temporal) => {\n        return temporal.query(TemporalQueries.PRECISION);\n    });\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query for {@link ZoneOffset} returning null if not found.\n     */\n    TemporalQueries.OFFSET = createTemporalQuery('OFFSET', (temporal) => {\n        if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n            return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n        }\n        return null;\n    });\n\n    /**\n     * A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n     */\n    TemporalQueries.ZONE = createTemporalQuery('ZONE', (temporal) => {\n        const zone = temporal.query(TemporalQueries.ZONE_ID);\n        return (zone != null ? zone : temporal.query(TemporalQueries.OFFSET));\n    });\n\n    /**\n     * A query for {@link LocalDate} returning null if not found.\n     */\n    TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', (temporal) => {\n        if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n        }\n        return null;\n    });\n\n    /**\n     * A query for {@link LocalTime} returning null if not found.\n     */\n    TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', (temporal) => {\n        if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n            return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n        }\n        return null;\n    });\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ZoneRules} from './ZoneRules';\nimport {ZoneOffset} from '../ZoneOffset';\nimport {DateTimeException} from '../errors';\n\nexport class SystemDefaultZoneRules extends ZoneRules {\n\n    isFixedOffset(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {Instant} instant\n     * @returns {ZoneOffset}\n     */\n    offsetOfInstant(instant){\n        const offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     *\n     * @param {number} epochMilli\n     * @returns {ZoneOffset}\n     */\n    offsetOfEpochMilli(epochMilli){\n        const offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     * This implementation is NOT returning the best value in a gap or overlap situation\n     * as specified at {@link ZoneRules.offsetOfLocalDateTime}.\n     *\n     * The calculated offset depends Date.prototype.getTimezoneOffset and its not specified\n     * at the ECMA-262 specification how to handle daylight savings gaps/ overlaps.\n     *\n     * The Chrome Browser version 49 is returning the next transition offset in a gap/overlap situation,\n     * other browsers/ engines might do it in the same way.\n     *\n     * @param {LocalDateTime} localDateTime\n     * @returns {ZoneOffset}\n     */\n    offsetOfLocalDateTime(localDateTime){\n        const epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n        const offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n        const epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n        const offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n    }\n\n    /**\n     *\n     * @param localDateTime\n     * @return {ZoneOffset[]}\n     */\n    validOffsets(localDateTime){\n        return [this.offsetOfLocalDateTime(localDateTime)];\n    }\n\n    /**\n     * @return null, not supported\n     */\n    transition(){\n        return null;\n    }\n\n    /**\n     *\n     * @param instant\n     * @return {ZoneOffset}\n     */\n    standardOffset(instant){\n        return this.offsetOfInstant(instant);\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    daylightSavings(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    isDaylightSavings(){\n        this._throwNotSupported();\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} dateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(dateTime, offset) {\n        return this.offsetOfLocalDateTime(dateTime).equals(offset);\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    nextTransition(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    previousTransition(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transitions(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transitionRules(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    _throwNotSupported(){\n        throw new DateTimeException('not supported operation');\n    }\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other || other instanceof SystemDefaultZoneRules) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'SYSTEM';\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {SystemDefaultZoneRules} from './SystemDefaultZoneRules';\nimport {ZoneId} from '../ZoneId';\n\nexport class SystemDefaultZoneId extends ZoneId {\n\n    constructor(){\n        super();\n        this._rules = new SystemDefaultZoneRules();\n    }\n\n    rules(){\n        return this._rules;\n    }\n\n    equals(other){\n        if(this === other){\n            return true;\n        }\n        return false;\n    }\n\n    id(){\n        return 'SYSTEM';\n    }\n\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException, IllegalArgumentException} from './errors';\nimport {StringUtil} from './StringUtil';\n\nimport {ZoneOffset} from './ZoneOffset';\nimport {ZoneRegion} from './ZoneRegion';\nimport {ZoneId} from './ZoneId';\n\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {SystemDefaultZoneId} from './zone/SystemDefaultZoneId';\nimport {ZoneRulesProvider} from './zone/ZoneRulesProvider';\n\n/**\n * @see {@link ZoneId}\n *\n * Helper class to avoid dependency cycles.\n * Static methods of the class ZoneIdFactory are added automatically to class ZoneId.\n * @private\n */\nexport class ZoneIdFactory {\n\n    /**\n     * Gets the system default time-zone.\n     *\n     *\n     * @return {ZoneId} the zone ID, not null\n     */\n    static systemDefault() {\n        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    }\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * This set includes the string form of all available region-based IDs.\n     * Offset-based zone IDs are not included in the returned set.\n     * The ID can be passed to {@link of} to create a {@link ZoneId}.\n     *\n     * The set of zone IDs can increase over time, although in a typical application\n     * the set of IDs is fixed. Each call to this method is thread-safe.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds() {\n        return ZoneRulesProvider.getAvailableZoneIds();\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} from an ID ensuring that the\n     * ID is valid and available for use.\n     *\n     * This method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\n     * A {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\n     * The result will always be a valid ID for which {@link ZoneRules} can be obtained.\n     *\n     * Parsing matches the zone ID step by step as follows.\n     *\n     * * If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n     * * If the zone ID consists of a single letter, the zone ID is invalid\n     *   and {@link DateTimeException} is thrown.\n     * * If the zone ID starts with '+' or '-', the ID is parsed as a\n     *   {@link ZoneOffset} using {@link ZoneOffset#of}.\n     * * If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n     *   with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n     * * If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n     *   then the ID is a prefixed offset-based ID. The ID is split in two, with\n     *   a two or three letter prefix and a suffix starting with the sign.\n     *   The suffix is parsed as a {@link ZoneOffset}.\n     *   The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n     *   and the normalized offset ID as per {@link ZoneOffset#getId}.\n     *   The rules of the returned {@link ZoneId} will be equivalent to the\n     *   parsed {@link ZoneOffset}.\n     * * All other IDs are parsed as region-based zone IDs. Region IDs must\n     *   match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n     *   otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n     *   in the configured set of IDs, {@link ZoneRulesException} is thrown.\n     *   The detailed format of the region ID depends on the group supplying the data.\n     *   The default set of data is supplied by the IANA Time Zone Database (TZDB).\n     *   This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n     *   This is compatible with most IDs from {@link java.util.TimeZone}.\n     *\n     * @param {string} zoneId  the time-zone ID, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if the zone ID has an invalid format\n     * @throws ZoneRulesException if the zone ID is a region ID that cannot be found\n     */\n    static of(zoneId) {\n        requireNonNull(zoneId, 'zoneId');\n        if (zoneId === 'Z') {\n            return ZoneOffset.UTC;\n        }\n        if (zoneId.length === 1) {\n            throw new DateTimeException('Invalid zone: ' + zoneId);\n        }\n        if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n            return ZoneOffset.of(zoneId);\n        }\n        if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {\n            return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') ||\n                StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n            const offset = ZoneOffset.of(zoneId.substring(3));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n            }\n            return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n            const offset = ZoneOffset.of(zoneId.substring(2));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion('UT', offset.rules());\n            }\n            return new ZoneRegion('UT' + offset.id(), offset.rules());\n        }\n        // javascript special case\n        if(zoneId === 'SYSTEM'){\n            return ZoneId.systemDefault();\n        }\n        return ZoneRegion.ofId(zoneId);\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} wrapping an offset.\n     *\n     * If the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\n     * with the prefix and the non-zero offset is returned.\n     * If the prefix is empty `''` the {@link ZoneOffset} is returned.\n     *\n     * @param {string} prefix  the time-zone ID, not null\n     * @param {ZoneOffset} offset  the offset, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws IllegalArgumentException if the prefix is not one of\n     *     'GMT', 'UTC', or 'UT', or ''\n     */\n    static ofOffset(prefix, offset) {\n        requireNonNull(prefix, 'prefix');\n        requireNonNull(offset, 'offset');\n        if (prefix.length === 0) {\n            return offset;\n        }\n        if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(prefix, offset.rules());\n            }\n            return new ZoneRegion(prefix + offset.id(), offset.rules());\n        }\n        throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);\n    }\n\n\n    /**\n     * Obtains an instance of {@link ZoneId} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n     *\n     * The conversion will try to obtain the zone in a way that favours region-based\n     * zones over offset-based zones using {@link TemporalQueries#zone}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZoneId::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if unable to convert to a {@link ZoneId}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const obj = temporal.query(TemporalQueries.zone());\n        if (obj == null) {\n            throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n        return obj;\n    }\n}\n\nlet SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\n\nexport function _init(){\n    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n\n    // a bit magic to stay a bit more to the threeten bp impl.\n    ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n    ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n    ZoneId.of = ZoneIdFactory.of;\n    ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n    ZoneId.from = ZoneIdFactory.from;\n    ZoneOffset.from = ZoneIdFactory.from;\n\n    // short cut\n    ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {_init as ZoneOffsetInit} from './ZoneOffset';\nimport {_init as DayOfWeekInit} from './DayOfWeek';\nimport {_init as DurationInit} from './Duration';\nimport {_init as InstantInit} from './Instant';\nimport {_init as LocalDateInit} from './LocalDate';\nimport {_init as LocalTimeInit} from './LocalTime';\nimport {_init as LocalDateTimeInit} from './LocalDateTime';\nimport {_init as MonthInit} from './Month';\nimport {_init as MonthDayInit} from './MonthDay';\nimport {_init as PeriodInit} from './Period';\nimport {_init as YearInit} from './Year';\nimport {_init as YearConstantsInit} from './YearConstants';\nimport {_init as YearMonthInit} from './YearMonth';\nimport {_init as ZonedDateTimeInit} from './ZonedDateTime';\nimport {_init as IsoChronologyInit} from './chrono/IsoChronology';\nimport {_init as DateTimeFormatterInit} from './format/DateTimeFormatter';\nimport {_init as ChronoFieldInit} from './temporal/ChronoField';\nimport {_init as ChronoUnitInit} from './temporal/ChronoUnit';\nimport {_init as IsoFieldsInit} from './temporal/IsoFields';\nimport {_init as DateTimeFormatterBuilderInit} from './format/DateTimeFormatterBuilder';\n\nimport {_init as TemporalQueriesInit} from './temporal/TemporalQueriesFactory';\nimport {_init as ZoneIdInit} from './ZoneIdFactory';\n\nlet isInit = false;\n\nfunction init() {\n\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    YearConstantsInit();\n    DurationInit();\n    ChronoUnitInit();\n    ChronoFieldInit();\n    LocalTimeInit();\n    IsoFieldsInit();\n    TemporalQueriesInit();\n    DayOfWeekInit();\n    InstantInit();\n    LocalDateInit();\n    LocalDateTimeInit();\n    YearInit();\n    MonthInit();\n    YearMonthInit();\n    MonthDayInit();\n    PeriodInit();\n    ZoneOffsetInit();\n    ZonedDateTimeInit();\n    ZoneIdInit();\n    IsoChronologyInit();\n    DateTimeFormatterInit();\n    DateTimeFormatterBuilderInit();\n}\n\ninit();\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {IllegalArgumentException} from './errors';\n\nimport {LocalDate} from './LocalDate';\nimport {LocalDateTime} from './LocalDateTime';\nimport {ZonedDateTime} from './ZonedDateTime';\nimport {ZoneId} from './ZoneId';\n\nclass ToNativeJsConverter {\n    /**\n     * @param {!(LocalDate|LocalDateTime|ZonedDateTime)} temporal - a joda temporal instance\n     * @param {ZoneId} [zone] - the zone of the temporal,\n     *  the default value for LocalDate and LocalDateTime is ZoneId.systemDefault().\n     */\n    constructor(temporal, zone){\n        let zonedDateTime;\n\n        if(temporal instanceof LocalDate) {\n            zone = zone == null ?  ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atStartOfDay(zone);\n        } else if (temporal instanceof LocalDateTime) {\n            zone = zone == null ? ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atZone(zone);\n        } else if (temporal instanceof ZonedDateTime) {\n            if (zone == null) {\n                zonedDateTime = temporal;\n            } else {\n                zonedDateTime = temporal.withZoneSameInstant(zone);\n            }\n        } else {\n            throw new IllegalArgumentException('unsupported instance for convert operation:' + temporal);\n        }\n\n        this.instant = zonedDateTime.toInstant();\n    }\n\n    /**\n     *\n     * @returns {Date}\n     */\n    toDate() {\n        return new Date(this.instant.toEpochMilli());\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    toEpochMilli() {\n        return this.instant.toEpochMilli();\n    }\n}\n\n/**\n * converts a LocalDate, LocalDateTime or ZonedDateTime to a native Javascript Date.\n *\n * In a first step the temporal is converted to an Instant by adding implicit values.\n * \n * A LocalDate is implicit set to a LocalDateTime at start of day. \n * A LocalDateTime is implicit set to a ZonedDateTime with \n * the passed zone or if null, with the system default time zone. \n * A ZonedDateTime is converted to an Instant, if a zone is specified the zonedDateTime is adjusted to this \n * zone, keeping the same Instant.\n *\n * In a second step the instant is converted to a native Javascript Date\n *\n * default zone for LocalDate and LocalDateTime is ZoneId.systemDefault().\n *\n * @example\n * convert(localDate).toDate() // returns a javascript Date\n * convert(localDate).toEpochMilli()   // returns the epochMillis\n *\n * @param {!(LocalDate|LocalDateTime|ZonedDateTime)} temporal - a joda temporal instance\n * @param {ZoneId} [zone] - the zone of the temporal\n * @returns {ToNativeJsConverter}\n */\nexport function convert(temporal, zone){\n    return new ToNativeJsConverter(temporal, zone);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\nimport {UnsupportedTemporalTypeException} from '../errors';\n\nimport {Instant} from '../Instant';\nimport {LocalDate} from '../LocalDate';\nimport {LocalTime} from '../LocalTime';\nimport {MathUtil} from '../MathUtil';\nimport {ZoneId} from '../ZoneId';\n\nimport {ChronoField} from './ChronoField';\nimport {TemporalQueries} from './TemporalQueries';\nimport {TemporalAccessor} from './TemporalAccessor';\n\n/**\n * A wrapper around a native javascript Date instance that\n * implements TemporalAccessor functionality\n */\nclass NativeJsTemporal extends TemporalAccessor {\n\n    /**\n     * @param {!(Date|moment)} date - a javascript Date or a moment instance\n     * @param {ZoneId} [zone=ZoneId.systemDefault()] - the zone of the temporal, defaults to ZoneId.systemDefault()\n     * @private\n     */\n    constructor(date, zone=ZoneId.systemDefault()){\n        super();\n        this._zone = zone;\n        if(date instanceof Date) {\n            this._epochMilli = date.getTime();\n            return;\n        } else if(typeof date.toDate === 'function' &&  date.toDate() instanceof Date) {\n            // it's a moment\n            this._epochMilli = date.toDate().getTime();\n            return;\n        }\n        assert(false, 'date must be either a javascript date or a moment');\n    }\n\n    /**\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        } else if(query === TemporalQueries.localTime()){\n            return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        } else if(query === TemporalQueries.zone()){\n            return this._zone;\n        }\n        return super.query(query);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     *\n     * @param {!TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;\n                case ChronoField.INSTANT_SECONDS: return MathUtil.floorDiv(this._epochMilli, 1000);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {boolean}\n     */\n    isSupported(field){\n        return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;\n    }\n}\n\n/**\n *\n * @param {!(Date|moment)} date - a javascript Date or a moment instance\n * @param {ZoneId} [zone=ZoneId.systemDefault()] - the zone of the temporal, defaults to ZoneId.systemDefault()\n * @returns {NativeJsTemporal}\n */\nexport function nativeJs(date, zone){\n    return new NativeJsTemporal(date, zone);\n}\n","\nexport function bindUse(jsJoda) {\n    const used = [];\n\n    /**\n     * use\n     *\n     * Provides a way to extend the internals of js-joda\n     *\n     * @param {function} fn - function to extend js-joda public api\n     * @returns {this} for chaining\n     */\n    return function use(fn) {\n        if (!~used.indexOf(fn)) {\n            fn(jsJoda);\n            used.push(fn);\n        }\n        return jsJoda;\n    };\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    ArithmeticException,\n    DateTimeException,\n    DateTimeParseException,\n    IllegalArgumentException,\n    IllegalStateException,\n    UnsupportedTemporalTypeException,\n    NullPointerException\n} from './errors';\n\nimport { Clock } from './Clock';\nimport { DayOfWeek } from './DayOfWeek';\nimport { Duration } from './Duration';\nimport { Instant } from './Instant';\nimport { LocalDate } from './LocalDate';\nimport { LocalTime } from './LocalTime';\nimport { LocalDateTime } from './LocalDateTime';\nimport { Month } from './Month';\nimport { MonthDay } from './MonthDay';\nimport { Period } from './Period';\nimport { Year } from './Year';\nimport { YearConstants } from './YearConstants';\nimport { YearMonth } from './YearMonth';\nimport { ZonedDateTime } from './ZonedDateTime';\nimport { ZoneOffset } from './ZoneOffset';\nimport { ZoneId } from './ZoneId';\nimport { ZoneRegion } from './ZoneRegion';\n\nimport { ZoneOffsetTransition } from './zone/ZoneOffsetTransition';\nimport { ZoneRules } from './zone/ZoneRules';\nimport { ZoneRulesProvider } from './zone/ZoneRulesProvider';\n\nimport { ChronoLocalDate } from './chrono/ChronoLocalDate';\nimport { ChronoLocalDateTime } from './chrono/ChronoLocalDateTime';\nimport { ChronoZonedDateTime } from './chrono/ChronoZonedDateTime';\nimport { IsoChronology } from './chrono/IsoChronology';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { IsoFields } from './temporal/IsoFields';\nimport { Temporal } from './temporal/Temporal';\nimport { TemporalAccessor } from './temporal/TemporalAccessor';\nimport { TemporalAdjuster } from './temporal/TemporalAdjuster';\nimport { TemporalAdjusters } from './temporal/TemporalAdjusters';\nimport { TemporalAmount } from './temporal/TemporalAmount';\nimport { TemporalField } from './temporal/TemporalField';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { TemporalQuery } from './temporal/TemporalQuery';\nimport { TemporalUnit } from './temporal/TemporalUnit';\nimport { ValueRange } from './temporal/ValueRange';\n\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { DateTimeFormatterBuilder } from './format/DateTimeFormatterBuilder';\nimport { DecimalStyle } from './format/DecimalStyle';\nimport { ResolverStyle } from './format/ResolverStyle';\nimport { SignStyle } from './format/SignStyle';\nimport { TextStyle } from './format/TextStyle';\n\n// init static properties\nimport './_init';\n\n// private/internal exports, e.g. for use in plugins\nimport { MathUtil } from './MathUtil';\nimport { StringUtil } from './StringUtil';\nimport { DateTimeBuilder } from './format/DateTimeBuilder';\nimport { DateTimeParseContext } from './format/DateTimeParseContext';\nimport { DateTimePrintContext } from './format/DateTimePrintContext';\nimport { StringBuilder } from './format/StringBuilder';\nimport * as assert from './assert';\n\nimport { convert } from './convert';\nimport { nativeJs } from './temporal/NativeJsTemporal';\nimport { bindUse } from './use';\n\nconst _ = {\n    assert,\n    DateTimeBuilder,\n    DateTimeParseContext,\n    DateTimePrintContext,\n    MathUtil,\n    StringUtil,\n    StringBuilder,\n};\n\nconst jsJiodaExports = {\n    _,\n    convert,\n    nativeJs,\n    ArithmeticException,\n    DateTimeException,\n    DateTimeParseException,\n    IllegalArgumentException,\n    IllegalStateException,\n    UnsupportedTemporalTypeException,\n    NullPointerException,\n    Clock,\n    DayOfWeek,\n    Duration,\n    Instant,\n    LocalDate,\n    LocalTime,\n    LocalDateTime,\n    Month,\n    MonthDay,\n    Period,\n    Year,\n    YearConstants,\n    YearMonth,\n    ZonedDateTime,\n    ZoneOffset,\n    ZoneId,\n    ZoneRegion,\n    ZoneOffsetTransition,\n    ZoneRules,\n    ZoneRulesProvider,\n    ChronoLocalDate,\n    ChronoLocalDateTime,\n    ChronoZonedDateTime,\n    IsoChronology,\n    ChronoField,\n    ChronoUnit,\n    IsoFields,\n    Temporal,\n    TemporalAccessor,\n    TemporalAdjuster,\n    TemporalAdjusters,\n    TemporalAmount,\n    TemporalField,\n    TemporalQueries,\n    TemporalQuery,\n    TemporalUnit,\n    ValueRange,\n    DateTimeFormatter,\n    DateTimeFormatterBuilder,\n    DecimalStyle,\n    ResolverStyle,\n    SignStyle,\n    TextStyle,\n};\n\nconst use = bindUse(jsJiodaExports);\njsJiodaExports.use = use;\n\nexport {\n    _,\n    use,\n    convert,\n    nativeJs,\n    ArithmeticException,\n    DateTimeException,\n    DateTimeParseException,\n    IllegalArgumentException,\n    IllegalStateException,\n    UnsupportedTemporalTypeException,\n    NullPointerException,\n    Clock,\n    DayOfWeek,\n    Duration,\n    Instant,\n    LocalDate,\n    LocalTime,\n    LocalDateTime,\n    Month,\n    MonthDay,\n    Period,\n    Year,\n    YearConstants,\n    YearMonth,\n    ZonedDateTime,\n    ZoneOffset,\n    ZoneId,\n    ZoneRegion,\n    ZoneOffsetTransition,\n    ZoneRules,\n    ZoneRulesProvider,\n    ChronoLocalDate,\n    ChronoLocalDateTime,\n    ChronoZonedDateTime,\n    IsoChronology,\n    ChronoField,\n    ChronoUnit,\n    IsoFields,\n    Temporal,\n    TemporalAccessor,\n    TemporalAdjuster,\n    TemporalAdjusters,\n    TemporalAmount,\n    TemporalField,\n    TemporalQueries,\n    TemporalQuery,\n    TemporalUnit,\n    ValueRange,\n    DateTimeFormatter,\n    DateTimeFormatterBuilder,\n    DecimalStyle,\n    ResolverStyle,\n    SignStyle,\n    TextStyle,\n};\n"],"names":["createErrorType","name","init","superErrorClass","Error","E","message","captureStackTrace","stack","constructor","apply","arguments","toString","prototype","DateTimeException","messageWithCause","DateTimeParseException","messageForDateTimeParseException","UnsupportedTemporalTypeException","ArithmeticException","IllegalArgumentException","IllegalStateException","NullPointerException","cause","msg","text","index","parsedString","errorIndex","assert","assertion","error","requireNonNull","value","parameterName","requireInstance","_class","abstractMethodFail","methodName","TypeError","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","MathUtil","intDiv","x","y","r","roundDown","safeZero","intMod","Math","ceil","floor","floorDiv","floorMod","safeAdd","verifyInt","safeToInt","safeSubtract","safeMultiply","parseInt","isNaN","compareNumbers","a","b","smi","int","hash","number","Infinity","result","hashCode","numbers","n","Enum","_name","equals","other","toJSON","TemporalAmount","get","unit","units","addTo","temporal","subtractFrom","TemporalUnit","duration","isDurationEstimated","isDateBased","isTimeBased","isSupportedBy","dateTime","periodToAdd","between","temporal1","temporal2","Duration","seconds","nanos","_seconds","_nanos","ofDays","days","_create","LocalTime","SECONDS_PER_DAY","ofHours","hours","SECONDS_PER_HOUR","ofMinutes","minutes","SECONDS_PER_MINUTE","ofSeconds","nanoAdjustment","secs","NANOS_PER_SECOND","nos","ofMillis","millis","mos","ofNanos","of","amount","ZERO","plus","from","forEach","startInclusive","endExclusive","until","ChronoUnit","SECONDS","isSupported","ChronoField","NANO_OF_SECOND","startNos","getLong","adjustedEnd","with","e","parse","PATTERN","RegExp","matches","exec","negate","dayMatch","hourMatch","minuteMatch","secondMatch","fractionMatch","daysAsSecs","_parseNumber","hoursAsSecs","minsAsSecs","negativeSecs","charAt","_parseFraction","ex","parsed","multiplier","errorText","substring","parseFloat","length","_createSecondsNanos","_createNegateDaysHoursMinutesSecondsNanos","negated","NANOS","isZero","isNegative","nano","withSeconds","withNanos","nanoOfSecond","checkValidIntValue","plusDuration","durationOrNumber","unitOrNumber","plusAmountUnit","plusSecondsNanos","amountToAdd","DAYS","plusNanos","MICROS","MILLIS","plusMillis","plusSeconds","multipliedBy","plusDays","daysToAdd","plusHours","hoursToAdd","plusMinutes","minutesToAdd","secondsToAdd","millisToAdd","nanosToAdd","epochSec","minus","minusDuration","minusAmountUnit","secsToSubtract","nanosToSubtract","amountToSubtract","minusDays","daysToSubtract","minusHours","hoursToSubtract","minusMinutes","minutesToSubtract","minusSeconds","secondsToSubtract","minusMillis","millisToSubtract","minusNanos","multiplicand","dividedBy","divisor","secsMod","abs","toDays","toHours","toMinutes","toMillis","round","toNanos","totalNanos","compareTo","otherDuration","cmp","rval","nanoString","slice","_init","YearConstants","MIN_VALUE","MAX_VALUE","estimatedDuration","_duration","FOREVER","e2","MINUTES","HOURS","HALF_DAYS","WEEKS","MONTHS","YEARS","DECADES","CENTURIES","MILLENNIA","ERAS","TemporalField","ValueRange","minSmallest","minLargest","maxSmallest","maxLargest","_minSmallest","_minLargest","_maxLargest","_maxSmallest","isFixed","minimum","largestMinimum","maximum","smallestMaximum","isValidValue","checkValidValue","field","isValidIntValue","isIntValue","str","byName","fieldName","prop","hasOwnProperty","baseUnit","rangeUnit","range","_baseUnit","_rangeUnit","_range","displayName","dateBased","DAY_OF_WEEK","ALIGNED_DAY_OF_WEEK_IN_MONTH","ALIGNED_DAY_OF_WEEK_IN_YEAR","DAY_OF_MONTH","DAY_OF_YEAR","EPOCH_DAY","ALIGNED_WEEK_OF_MONTH","ALIGNED_WEEK_OF_YEAR","MONTH_OF_YEAR","YEAR_OF_ERA","YEAR","ERA","timeBased","NANO_OF_DAY","MICRO_OF_SECOND","MICRO_OF_DAY","MILLI_OF_SECOND","MILLI_OF_DAY","SECOND_OF_MINUTE","SECOND_OF_DAY","MINUTE_OF_HOUR","MINUTE_OF_DAY","HOUR_OF_AMPM","CLOCK_HOUR_OF_AMPM","HOUR_OF_DAY","CLOCK_HOUR_OF_DAY","AMPM_OF_DAY","rangeRefinedBy","getFrom","PROLEPTIC_MONTH","INSTANT_SECONDS","OFFSET_SECONDS","TemporalQueries","zoneId","ZONE_ID","chronology","CHRONO","precision","PRECISION","zone","ZONE","offset","OFFSET","localDate","LOCAL_DATE","localTime","LOCAL_TIME","TemporalAccessor","query","queryFrom","Temporal","TemporalQuery","createTemporalQuery","queryFromFunction","ExtendedTemporalQuery","DayOfWeek","ordinal","_ordinal","values","ENUMS","valueOf","dayOfWeek","getDisplayName","style","locale","adjustInto","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY","FROM","StringUtil","startsWith","pattern","indexOf","len","i","chr","charCodeAt","ZoneId","systemDefault","getAvailableZoneIds","ofOffset","prefix","id","rules","normalized","isFixedOffset","Instant","EPOCH","ZoneRules","Fixed","instantOrLocalDateTime","offsetOfInstant","offsetOfLocalDateTime","instant","offsetOfEpochMilli","epochMilli","localDateTime","validOffsets","transition","standardOffset","daylightSavings","isDaylightSavings","isValidOffset","nextTransition","previousTransition","transitions","transitionRules","_offset","SECONDS_CACHE","ID_CACHE","ZoneOffset","totalSeconds","_validateTotalSeconds","_totalSeconds","_rules","_id","_buildId","absTotalSeconds","absHours","absMinutes","MINUTES_PER_HOUR","buf","absSeconds","MAX_SECONDS","_validate","offsetId","first","ofHoursMinutesSeconds","pos","precededByColon","ch1","ch2","ofHoursMinutes","ofTotalSeconds","ofTotalMinutes","totalMinutes","totalSecs","obj","UTC","MIN","MAX","Period","years","months","_years","_months","_days","ofYears","create","ofMonths","ofWeeks","weeks","unitAmount","startDate","endDate","LocalDate","_parse","yearMatch","monthMatch","weekMatch","val","IsoChronology","INSTANCE","withYears","withMonths","withDays","plusYears","yearsToAdd","plusMonths","monthsToAdd","minusYears","yearsToSubtract","minusMonths","monthsToSubtract","scalar","totalMonths","toTotalMonths","splitYears","splitMonths","ParsePosition","_index","_errorIndex","getIndex","setIndex","getErrorIndex","setErrorIndex","EnumMap","_map","putAll","otherMap","key","containsKey","undefined","put","set","retainAll","keyList","map","remove","keyName","keySet","clear","ResolverStyle","STRICT","SMART","LENIENT","DateTimeBuilder","dtb","_addFieldValue","fieldValues","chrono","date","time","leapSecond","excessDays","getFieldValue0","old","_putFieldValue0","resolve","resolverStyle","resolverFields","_mergeDate","_mergeTime","_resolveTimeInferZeroes","_resolveInstant","_checkDate","resolveDate","_addObject","val1","val2","ch","ap","hap","nod","cod","lod","sod","mod","los","cos","hod","moh","som","hodVal","mohVal","somVal","nosVal","ofNanoOfDay","ofSecondOfDay","dateOrTime","ChronoLocalDate","offsetSecs","atTime","atZone","build","type","DateTimeParseContext","_constructorSelf","_constructorFormatter","_constructorParam","_caseSensitive","_strict","_parsed","Parsed","symbols","_locale","_symbols","_overrideChronology","formatter","decimalStyle","_overrideZone","copy","isStrict","setStrict","strict","setLocale","startOptional","push","currentParsed","endOptional","successful","splice","isCaseSensitive","setCaseSensitive","caseSensitive","subSequenceEquals","cs1","offset1","cs2","offset2","toLowerCase","charEquals","charEqualsIgnoreCase","c1","c2","setParsedField","errorPos","successPos","currentParsedFieldValues","setParsedZone","getParsed","toParsed","setParsedLeapSecond","getEffectiveChronology","dateTimeParseContext","cloned","toBuilder","builder","overrideZone","DateTimePrintContext","localeOrFormatter","DateTimeFormatter","_temporal","adjust","_optional","getValueQuery","getValue","setDateTime","SignStyle","positive","fixedWidth","NORMAL","ALWAYS","EXCEEDS_PAD","NEVER","NOT_NEGATIVE","StringBuilder","_str","append","appendChar","insert","replace","start","end","setLength","parsedExcessDays","PARSED_EXCESS_DAYS","parsedLeapSecond","PARSED_LEAP_SECOND","ofPattern","DateTimeFormatterBuilder","appendPattern","toFormatter","printerParser","_printerParser","_decimalStyle","_resolverStyle","_resolverFields","_chrono","_zone","withChronology","withLocale","withResolverStyle","format","_formatTo","appendable","context","print","parse1","parse2","_parseToBuilder","_createError","abbr","position","_parseUnresolved0","substr","parseUnresolved","_toPrinterParser","optional","withOptional","ISO_LOCAL_DATE","appendValue","appendLiteral","ISO_LOCAL_TIME","optionalStart","appendFraction","ISO_LOCAL_DATE_TIME","parseCaseInsensitive","ISO_INSTANT","appendInstant","ISO_OFFSET_DATE_TIME","appendOffsetId","ISO_ZONED_DATE_TIME","parseCaseSensitive","appendZoneId","fieldOrUnit","ofEpochDay","toEpochDay","IsoFields","QUARTER_DAYS","Field","_isIso","_getWeekRangeByLocalDate","wby","_getWeekBasedYear","_getWeekRangeByYear","isLeapYear","_getWeek","dow0","doy0","dayOfYear","doyThu0","alignedWeek","firstThuDoy0","firstMonDoy0","withDayOfYear","week","year","doy","dow","DAY_OF_QUARTER_FIELD","QUARTER_YEARS","qoy","QUARTER_OF_YEAR","moy","newValue","curValue","partialTemporal","yearLong","qoyLong","doq","DAY_OF_QUARTER","max","QUARTER_OF_YEAR_FIELD","WEEK_OF_WEEK_BASED_YEAR_FIELD","WEEK_BASED_YEARS","wbyLong","WEEK_BASED_YEAR","dowLong","wowby","WEEK_OF_WEEK_BASED_YEAR","plusWeeks","temp","WEEK_BASED_YEAR_FIELD","newWby","resolved","Unit","added","isoWeekOfWeekyear","isoWeekyear","DecimalStyle","zeroChar","positiveSignChar","negativeSignChar","decimalPointChar","_zeroDigit","_zeroDigitCharCode","_positiveSign","_negativeSign","_decimalSeparator","positiveSign","withPositiveSign","negativeSign","withNegativeSign","zeroDigit","withZeroDigit","decimalSeparator","withDecimalSeparator","convertToDigit","char","convertNumberToI18N","numericText","diff","convertedText","String","fromCharCode","availableLocales","STANDARD","TextStyle","isStandalone","FULL_STANDALONE","SHORT_STANDALONE","NARROW_STANDALONE","asStandalone","FULL","SHORT","NARROW","asNormal","CharLiteralPrinterParser","literal","_literal","CompositePrinterParser","printerParsers","_printerParsers","pp","FractionPrinterParser","minWidth","maxWidth","decimalPoint","fraction","convertToFraction","outputScale","min","effectiveMin","effectiveMax","minEndPos","maxEndPos","total","digit","moveLeft","scale","pow","convertFromFraction","_min","_value","_scaled","decimal","MAX_WIDTH","EXCEED_POINTS","NumberPrinterParser","signStyle","subsequentWidth","_field","_minWidth","_maxWidth","_signStyle","_subsequentWidth","withFixedWidth","withSubsequentWidth","_isFixedWidth","contextValue","_getValue","sign","negative","effMinWidth","effMaxWidth","pass","parseLen","_setValue","ReducedPrinterParser","width","baseValue","baseDate","_baseValue","_baseDate","absValue","lastPart","basePart","isFixedWidth","PATTERNS","OffsetIdPrinterParser","noOffsetText","_checkPattern","bufPos","output","noOffsetLen","array","arrayIndex","parseText","required","converted","INSTANCE_ID","PadPrinterParserDecorator","padWidth","padChar","_padWidth","_padChar","preLen","endPos","resultPos","SettingsParser","SENSITIVE","INSENSITIVE","StringLiteralPrinterParser","ZoneRulesProvider","getRules","ZoneRegion","ofId","ZoneIdPrinterParser","description","nextChar","newContext","nextNextChar","_parsePrefixedOffset","availableZoneIds","zoneIdTree","size","ZoneIdTree","createTreeMap","maxParseLength","treeMap","parsedZoneId","parseLength","parsedSubZoneId","isLeaf","prefixPos","toUpperCase","sortedZoneIds","sort","ZoneIdTreeMap","add","_treeMap","idLength","subZoneId","subTreeMap","_active","_parent","_padNextWidth","_padNextChar","_valueParserIndex","_of","parent","dtFormatterBuilder","_appendInternalPrinterParser","parseStrict","parseLenient","_appendValue1","_appendValue2","_appendValue4","_appendValuePrinterParser","appendValueReduced","_appendValueReducedFieldWidthMaxWidthBaseDate","_appendValueReducedFieldWidthMaxWidthBaseValue","activeValueParser","basePP","_appendInternal","fractionalDigits","InstantPrinterParser","appendOffset","_parsePattern","appendZoneText","appendText","appendLocalizedOffset","appendWeekField","FIELD_MAP","cur","count","pad","padNext","_parseField","zero","optionalEnd","BASE_DATE","_padNext1","_padNext2","cpp","SECONDS_PER_10000_YEARS","SECONDS_0000_TO_1970","inSecs","inNanos","inSec","inNano","zeroSecs","hi","lo","ldt","LocalDateTime","ofEpochSecond","second","div","minDigits","maxDigits","parser","yearParsed","month","day","hour","secVal","nanoVal","sec","instantSecs","toEpochSecond","Month","newMonthVal","leapYear","FEBRUARY","APRIL","JUNE","SEPTEMBER","NOVEMBER","minLength","maxLength","firstDayOfYear","leap","JANUARY","MARCH","MAY","JULY","AUGUST","OCTOBER","DECEMBER","firstMonthOfQuarter","MonthDay","now","zoneIdOrClock","now0","nowZoneId","nowClock","Clock","systemDefaultZone","system","clock","dayOfMonth","monthOrNumber","ofMonthNumber","ofNumberNumber","parseString","parseStringFormatter","PARSER","_month","_day","monthValue","isValidYear","Year","isLeap","withMonth","withDayOfMonth","atYear","isAfter","isBefore","YearMonth","ofNumberMonth","_year","isSupportedField","isSupportedUnit","_getProlepticMonth","isValidDay","lengthOfMonth","lengthOfYear","adjusterOrFieldOrNumber","withAdjuster","withFieldValue","withYearMonth","newYear","newMonth","adjuster","f","withYear","amountOrNumber","plusAmount","monthCount","calcMonths","minusAmount","monthsUntil","atDay","atEndOfMonth","isoYear","parseTextFormatter","plusAmountToAddUnit","minusAmountToSubtractUnit","isValidMonthDay","monthDay","ofYearDay","atMonth","atMonthMonth","atMonthNumber","atMonthDay","otherYear","TemporalAdjuster","TemporalAdjusters","firstDayOfMonth","Impl","FIRST_DAY_OF_MONTH","lastDayOfMonth","LAST_DAY_OF_MONTH","firstDayOfNextMonth","FIRST_DAY_OF_NEXT_MONTH","FIRST_DAY_OF_YEAR","lastDayOfYear","LAST_DAY_OF_YEAR","firstDayOfNextYear","FIRST_DAY_OF_NEXT_YEAR","firstInMonth","DayOfWeekInMonth","lastInMonth","dayOfWeekInMonth","next","RelativeDayOfWeek","nextOrSame","previous","previousOrSame","_dowValue","curDow","dowDiff","daysDiff","relative","_relative","calDow","prolepticYear","_updateResolveMap","current","prolepticMonth","yoeLong","era","dom","aw","ad","ChronoZonedDateTime","toLocalDate","toLocalTime","toInstant","epochDay","toSecondOfDay","toLocalDateTime","strcmp","thisEpochSec","otherEpochSec","isEqual","ZonedDateTime","clockOrZone","ofInstant","of2","of3","of8","ofLocal","minute","dt","preferredOffset","trans","offsetAfter","some","validOffset","ofInstant2","ofInstant3","epochSecond","ofStrict","isGap","ofLenient","zdt","_from","__from","_dateTime","_resolveLocal","newDateTime","_resolveOffset","withEarlierOffsetAtOverlap","isOverlap","earlierOffset","offsetBefore","withLaterOffsetAtOverlap","laterOffset","withZoneSameLocal","withZoneSameInstant","withFixedOffsetZone","withTemporalAdjuster","with2","withHour","withMinute","withSecond","withNano","truncatedTo","plusTemporalAmount","plus2","minusTemporalAmount","minus2","minusWeeks","difference","DAYS_PER_CYCLE","DAYS_0000_TO_1970","monthEnd","adjustCycles","doyEst","yearEst","zeroDay","marchDoy0","marchMonth0","_resolvePreviousValid","_get0","_prolepticMonth","fieldOrAdjuster","withFieldAndValue","m","p1","p2","plus1","weeksToAdd","mjDay","minus1","weeksToSubtract","until1","until2","daysUntil","_monthsUntil","packed1","packed2","calcDate","atTime1","atTime4","atStartOfDay","atStartOfDayWithZone","MIDNIGHT","dateTimeAfter","_compareTo0","otherDate","yearValue","dayValue","dayString","monthString","yearString","absYear","EPOCH_0","ChronoLocalDateTime","toNanoOfDay","_now","_ofEpochMillis","localSecond","localEpochDay","secsOfDay","ofDateAndTime","ofNumbers","_date","_time","_withDateTime","newDate","newTime","adjusterOrField","MICROS_PER_DAY","MILLIS_PER_DAY","_plusWithOverflow","totDays","NANOS_PER_DAY","MINUTES_PER_DAY","HOURS_PER_DAY","totNanos","NANOS_PER_MINUTE","NANOS_PER_HOUR","curNoD","newNoD","timeUntil","endTime","secondOfDay","nanoOfDay","_hour","_minute","_second","_nanoOfSecond","_nano","ham","unitDur","dur","newHour","mofd","newMofd","newMinute","secondstoAdd","sofd","newSofd","newSecond","nofd","newNofd","newNano","nanosUntil","atDate","hourValue","minuteValue","secondValue","nanoValue","NOON","NANOS_PER_MILLI","systemUTC","ofEpochMilli","MIN_SECONDS","nval","_plus","_nanosUntil","toEpochMilli","_secondsUntil","secsDiff","nanosDiff","otherInstant","SystemClock","fixed","fixedInstant","FixedClock","baseClock","OffsetClock","withZone","Date","getTime","_instant","_zoneId","_baseClock","ZoneOffsetTransition","_transition","_offsetBefore","_offsetAfter","dateTimeBefore","durationSeconds","d","SystemDefaultZoneRules","offsetInMinutes","getTimezoneOffset","offsetInMinutesBeforePossibleTransition","epochMilliSystemZone","offsetInMinutesAfterPossibleTransition","_throwNotSupported","SystemDefaultZoneId","ZoneIdFactory","SYSTEM_DEFAULT_ZONE_ID_INSTANCE","SYSTEM","isInit","YearConstantsInit","DurationInit","ChronoUnitInit","ChronoFieldInit","LocalTimeInit","IsoFieldsInit","TemporalQueriesInit","DayOfWeekInit","InstantInit","LocalDateInit","LocalDateTimeInit","YearInit","MonthInit","YearMonthInit","MonthDayInit","PeriodInit","ZoneOffsetInit","ZonedDateTimeInit","ZoneIdInit","IsoChronologyInit","DateTimeFormatterInit","DateTimeFormatterBuilderInit","ToNativeJsConverter","zonedDateTime","toDate","convert","NativeJsTemporal","_epochMilli","nativeJs","bindUse","jsJoda","used","use","fn","_","jsJiodaExports"],"mappings":"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"}