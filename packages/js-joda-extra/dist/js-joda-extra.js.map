{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 4b2298dc3085d623c0c6","webpack:///./src/js-joda-extra.js","webpack:///./src/main.js","webpack:///./src/Interval.js","webpack:///external {\"amd\":\"js-joda\",\"commonjs\":\"js-joda\",\"commonjs2\":\"js-joda\",\"root\":\"JSJoda\"}","webpack:///./src/assert.js","webpack:///./src/errors.js"],"names":["jsJoda","_init","_plugin","Interval","of","startInstant","endInstantOrDuration","ofInstantDuration","ofInstantInstant","startInclusive","endExclusive","isBefore","duration","isNegative","plus","_start","_end","start","end","isEmpty","equals","isUnboundedStart","MIN","isUnboundedEnd","MAX","withStart","withEnd","contains","instant","compareTo","encloses","other","abuts","isConnected","overlaps","intersection","cmpStart","cmpEnd","newStart","newEnd","union","span","isAfter","instantOrInterval","isAfterInstant","isAfterInterval","isBeforeInstant","isBeforeInterval","interval","toDuration","between","obj","hashCode","toString","_initialized","ALL","assert","requireNonNull","requireInstance","abstractMethodFail","assertion","msg","error","Error","value","parameterName","_class","name","constructor","methodName","TypeError","createErrorType","init","superErrorClass","E","message","captureStackTrace","stack","apply","arguments","prototype","DateTimeException","messageWithCause","DateTimeParseException","messageForDateTimeParseException","UnsupportedTemporalTypeException","ArithmeticException","IllegalArgumentException","IllegalStateException","NullPointerException","cause","text","index","parsedString","errorIndex"],"mappings":"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","file":"js-joda-extra.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"js-joda\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"js-joda\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSJodaExtra\"] = factory(require(\"js-joda\"));\n\telse\n\t\troot[\"JSJodaExtra\"] = factory(root[\"JSJoda\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4b2298dc3085d623c0c6","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\nimport extraDefault from './main';\n\nexport default extraDefault;\n\n\n\n// WEBPACK FOOTER //\n// ./src/js-joda-extra.js","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n\nimport {_plugin as IntervalPlugin} from './Interval';\n\n/**\n * plugin Function, call using js-jodas use()\n *\n * @param jsJoda\n */\nexport default function(jsJoda) {\n    IntervalPlugin(jsJoda);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","import {Duration, Instant} from 'js-joda';\n\n//TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException} from './errors';\n\n/**\n * An immutable interval of time between two instants.\n * <p>\n * An interval represents the time on the time-line between two {@link Instant}s.\n * The class stores the start and end instants, with the start inclusive and the end exclusive.\n * The end instant is always greater than or equal to the start instant.\n * <p>\n * The {@link Duration} of an interval can be obtained, but is a separate concept.\n * An interval is connected to the time-line, whereas a duration is not.\n * <p>\n * Intervals are not comparable. To compare the length of two intervals, it is\n * generally recommended to compare their durations.\n *\n */\nexport class Interval {\n    \n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Interval.of}\n     *\n     * if called without arguments, then {@link Interval.ofInstantInstant} is executed.\n     \n     * if called with 1 arguments and first argument is an instance of ZoneId, then {@link Interval.ofInstantDuration} is executed.\n     *\n     * Otherwise {@link Interval.ofInstantDuration} is executed.\n     *\n     * @param {!(Instant)} startInstant\n     * @param {!(Instant|Duration)} endInstantOrDuration\n     * @returns {Interval}\n     */\n    static of(startInstant, endInstantOrDuration) {\n        if (endInstantOrDuration instanceof Duration) {\n            return Interval.ofInstantDuration(startInstant, endInstantOrDuration);\n        } else {\n            return Interval.ofInstantInstant(startInstant, endInstantOrDuration);\n        }\n    }\n    \n    /**\n     * Obtains an instance of {@code Interval} from the start and end instant.\n     * <p>\n     * The end instant must not be before the start instant.\n     *\n     * @param {Instant} startInclusive  the start instant, inclusive, MIN_DATE treated as unbounded, not null\n     * @param {Instant} endExclusive  the end instant, exclusive, MAX_DATE treated as unbounded, not null\n     * @return {Interval} the half-open interval, not null\n     * @throws DateTimeException if the end is before the start\n     */\n    static ofInstantInstant(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        requireInstance(startInclusive, Instant, 'startInclusive');\n        requireInstance(endExclusive, Instant, 'endExclusive');\n        if (endExclusive.isBefore(startInclusive)) {\n            throw new DateTimeException('End instant must on or after start instant');\n        }\n        return new Interval(startInclusive, endExclusive);\n    }\n\n    /**\n     * Obtains an instance of {@code Interval} from the start and a duration.\n     * <p>\n     * The end instant is calculated as the start plus the duration.\n     * The duration must not be negative.\n     *\n     * @param {Instant} startInclusive  the start instant, inclusive, not null\n     * @param {Duration} duration  the duration from the start to the end, not null\n     * @return {Interval} the interval, not null\n     * @throws DateTimeException if the end is before the start,\n     *  or if the duration addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs when adding the duration\n     */\n    static ofInstantDuration(startInclusive, duration) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(duration, 'duration');\n        requireInstance(startInclusive, Instant, 'startInclusive');\n        requireInstance(duration, Duration, 'duration');\n        if (duration.isNegative()) {\n            throw new DateTimeException('Duration must not be zero or negative');\n        }\n        return new Interval(startInclusive, startInclusive.plus(duration));\n    }\n\n    //-----------------------------------------------------------------------\n    \n/* TODO: OffsetDateTime is missing\n    /!**\n     * Obtains an instance of {@code Interval} from a text string such as\n     * {@code 2007-12-03T10:15:30Z/2007-12-04T10:15:30Z}, where the end instant is exclusive.\n     * <p>\n     * The string must consist of one of the following three formats:\n     * <ul>\n     * <li>a representations of an {@link OffsetDateTime}, followed by a forward slash,\n     *  followed by a representation of a {@link OffsetDateTime}\n     * <li>a representation of an {@link OffsetDateTime}, followed by a forward slash,\n     *  followed by a representation of a {@link Duration}\n     * <li>a representation of a {@link Duration}, followed by a forward slash,\n     *  followed by a representation of an {@link OffsetDateTime}\n     * </ul>\n     *\n     *\n     * @param {string} text  the text to parse, not null\n     * @return {Interval} the parsed interval, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     *!/\n    static parse(text) {\n        requireNonNull(text, 'text');\n        requireInstance(text, String, 'text');\n        for (let i = 0; i < text.length(); i++) {\n            if (text.charAt(i) === '/') {\n                let firstChar = text.charAt(0);\n                if (firstChar === 'P' || firstChar === 'p') {\n                    // duration followed by instant\n                    let duration = Duration.parse(text.subSequence(0, i));\n                    let end = OffsetDateTime.parse(text.subSequence(i + 1, text.length())).toInstant();\n                    return Interval.of(end.minus(duration), end);\n                } else {\n                    // instant followed by instant or duration\n                    let start = OffsetDateTime.parse(text.subSequence(0, i)).toInstant();\n                    if (i + 1 < text.length()) {\n                        let c = text.charAt(i + 1);\n                        if (c === 'P' || c === 'p') {\n                            let duration = Duration.parse(text.subSequence(i + 1, text.length()));\n                            return Interval.of(start, start.plus(duration));\n                        }\n                    }\n                    let end = OffsetDateTime.parse(text.subSequence(i + 1, text.length())).toInstant();\n                    return Interval.of(start, end);\n                }\n            }\n        }\n        throw new DateTimeParseException('Interval cannot be parsed, no forward slash found', text, 0);\n    }\n*/\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {Instant} startInclusive  the start instant, inclusive, validated not null\n     * @param {Instant} endExclusive  the end instant, exclusive, validated not null\n     */\n    constructor(startInclusive, endExclusive) {\n        this._start = startInclusive;\n        this._end = endExclusive;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the start of this time interval, inclusive.\n     * <p>\n     * This will return {@link Instant#MIN} if the range is unbounded at the start.\n     * In this case, the range includes all dates into the far-past.\n     *\n     * @return {Instant} the start of the time interval\n     */\n    start() {\n        return this._start;\n    }\n\n    /**\n     * Gets the end of this time interval, exclusive.\n     * <p>\n     * This will return {@link Instant#MAX} if the range is unbounded at the end.\n     * In this case, the range includes all dates into the far-future.\n     *\n     * @return {Instant} the end of the time interval, exclusive\n     */\n    end() {\n        return this._end;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the range is empty.\n     * <p>\n     * An empty range occurs when the start date equals the inclusive end date.\n     *\n     * @return {boolean} true if the range is empty\n     */\n    isEmpty() {\n        return this._start.equals(this._end);\n    }\n\n    /**\n     * Checks if the start of the interval is unbounded.\n     *\n     * @return {boolean} true if start is unbounded\n     */\n    isUnboundedStart() {\n        return this._start.equals(Instant.MIN);\n    }\n\n    /**\n     * Checks if the end of the interval is unbounded.\n     *\n     * @return {boolean} true if end is unbounded\n     */\n    isUnboundedEnd() {\n        return this._end.equals(Instant.MAX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this range with the specified start instant.\n     *\n     * @param {Instant} start  the start instant for the new interval, not null\n     * @return {Interval} an interval with the end from this interval and the specified start\n     * @throws DateTimeException if the resulting interval has end before start\n     */\n    withStart(start) {\n        return Interval.of(start, this._end);\n    }\n\n    /**\n     * Returns a copy of this range with the specified end instant.\n     *\n     * @param {Instant} end  the end instant for the new interval, not null\n     * @return {Interval} an interval with the start from this interval and the specified end\n     * @throws DateTimeException if the resulting interval has end before start\n     */\n    withEnd(end) {\n        return Interval.of(this._start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this interval contains the specified instant.\n     * <p>\n     * This checks if the specified instant is within the bounds of this interval.\n     * If this range has an unbounded start then {@code contains(Instant#MIN)} returns true.\n     * If this range has an unbounded end then {@code contains(Instant#MAX)} returns true.\n     * If this range is empty then this method always returns false.\n     *\n     * @param {Instant} instant  the instant, not null\n     * @return {boolean} true if this interval contains the instant\n     */\n    contains(instant) {\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        return this._start.compareTo(instant) <= 0 && (instant.compareTo(this._end) < 0 || this.isUnboundedEnd());\n    }\n\n    /**\n     * Checks if this interval encloses the specified interval.\n     * <p>\n     * This checks if the bounds of the specified interval are within the bounds of this interval.\n     * An empty interval encloses itself.\n     *\n     * @param {Interval} other  the other interval, not null\n     * @return {boolean} true if this interval contains the other interval\n     */\n    encloses(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return this._start.compareTo(other.start()) <= 0 && other.end().compareTo(this._end) <= 0;\n    }\n\n    /**\n     * Checks if this interval abuts the specified interval.\n     * <p>\n     * The result is true if the end of this interval is the start of the other, or vice versa.\n     * An empty interval does not abut itself.\n     *\n     * @param {Interval} other  the other interval, not null\n     * @return {boolean} true if this interval abuts the other interval\n     */\n    abuts(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return !this._end.equals(other.start()) !== !this._start.equals(other.end());\n    }\n\n    /**\n     * Checks if this interval is connected to the specified interval.\n     * <p>\n     * The result is true if the two intervals have an enclosed interval in common, even if that interval is empty.\n     * An empty interval is connected to itself.\n     * <p>\n     * This is equivalent to {@code (overlaps(other) || abuts(other))}.\n     *\n     * @param {Interval} other  the other interval, not null\n     * @return {boolean} true if this interval is connected to the other interval\n     */\n    isConnected(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return this.equals(other) || (this._start.compareTo(other.end()) <= 0 && other.start().compareTo(this._end) <= 0);\n    }\n\n    /**\n     * Checks if this interval overlaps the specified interval.\n     * <p>\n     * The result is true if the the two intervals share some part of the time-line.\n     * An empty interval overlaps itself.\n     * <p>\n     * This is equivalent to {@code (isConnected(other) && !abuts(other))}.\n     *\n     * @param {Interval} other  the time interval to compare to, null means a zero length interval now\n     * @return {boolean} true if the time intervals overlap\n     */\n    overlaps(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return other.equals(this) || (this._start.compareTo(other.end()) < 0 && other.start().compareTo(this._end) < 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the interval that is the intersection of this interval and the specified interval.\n     * <p>\n     * This finds the intersection of two intervals.\n     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.\n     *\n     * @param {Interval} other  the other interval to check for, not null\n     * @return {Interval} the interval that is the intersection of the two intervals\n     * @throws DateTimeException if the intervals do not connect\n     */\n    intersection(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException('Intervals do not connect: ' + this + ' and ' + other);\n        }\n        let cmpStart = this._start.compareTo(other.start());\n        let cmpEnd = this._end.compareTo(other.end());\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return this;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return other;\n        } else {\n            let newStart = (cmpStart >= 0 ? this._start : other.start());\n            let newEnd = (cmpEnd <= 0 ? this._end : other.end());\n            return Interval.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the interval that is the union of this interval and the specified interval.\n     * <p>\n     * This finds the union of two intervals.\n     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.\n     *\n     * @param {Interval} other  the other interval to check for, not null\n     * @return {Interval} the interval that is the union of the two intervals\n     * @throws DateTimeException if the intervals do not connect\n     */\n    union(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException('Intervals do not connect: ' + this + ' and ' + other);\n        }\n        let cmpStart = this._start.compareTo(other.start());\n        let cmpEnd = this._end.compareTo(other.end());\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return other;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return this;\n        } else {\n            let newStart = (cmpStart >= 0 ? other.start() : this._start);\n            let newEnd = (cmpEnd <= 0 ? other.end() : this._end);\n            return Interval.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the smallest interval that encloses this interval and the specified interval.\n     * <p>\n     * The result of this method will {@linkplain #encloses(Interval) enclose}\n     * this interval and the specified interval.\n     *\n     * @param {Interval} other  the other interval to check for, not null\n     * @return {Interval} the interval that spans the two intervals\n     */\n    span(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        let cmpStart = this._start.compareTo(other.start());\n        let cmpEnd = this._end.compareTo(other.end());\n        let newStart = (cmpStart >= 0 ? other.start() : this._start);\n        let newEnd = (cmpEnd <= 0 ? other.end() : this._end);\n        return Interval.of(newStart, newEnd);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * function overloading for {@link Interval#isAfter}\n     *\n     * if called with an Instant, then {@link Interval#isAfterInstant} is executed.\n     *\n     * Otherwise {@link Interval#isAfterInterval} is executed.\n     *\n     * @param {!(Instant|Interval)} instantOrInterval\n     * @returns {boolean}\n     */\n    isAfter(instantOrInterval) {\n        if (instantOrInterval instanceof Instant) {\n            return this.isAfterInstant(instantOrInterval);\n        } else {\n            return this.isAfterInterval(instantOrInterval);\n        }\n    }\n    \n    /**\n     * function overloading for {@link Interval#isBefore}\n     *\n     * if called with an Instant, then {@link Interval#isBeforeInstant} is executed.\n     *\n     * Otherwise {@link Interval#isBeforeInterval} is executed.\n     *\n     * @param {!(Instant|Interval)} instantOrInterval\n     * @returns {boolean}\n     */\n    isBefore(instantOrInterval) {\n        if (instantOrInterval instanceof Instant) {\n            return this.isBeforeInstant(instantOrInterval);\n        } else {\n            return this.isBeforeInterval(instantOrInterval);\n        }\n    }\n    \n    /**\n     * Checks if this interval is after the specified instant.\n     * <p>\n     * The result is true if the this instant starts after the specified instant.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Instant} instant  the other instant to compare to, not null\n     * @return {boolean} true if the start of this interval is after the specified instant\n     */\n    isAfterInstant(instant) {\n        return this._start.compareTo(instant) > 0;\n    }\n\n    /**\n     * Checks if this interval is before the specified instant.\n     * <p>\n     * The result is true if the this instant ends before the specified instant.\n     * Since intervals do not include their end points, this will return true if the\n     * instant equals the end of the interval.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Instant} instant  the other instant to compare to, not null\n     * @return {boolean} true if the start of this interval is before the specified instant\n     */\n    isBeforeInstant(instant) {\n        return this._end.compareTo(instant) <= 0 && this._start.compareTo(instant) < 0;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Checks if this interval is after the specified interval.\n     * <p>\n     * The result is true if the this instant starts after the end of the specified interval.\n     * Since intervals do not include their end points, this will return true if the\n     * instant equals the end of the interval.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Interval} interval  the other interval to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     */\n    isAfterInterval(interval) {\n        return this._start.compareTo(interval.end()) >= 0 && !interval.equals(this);\n    }\n\n    /**\n     * Checks if this interval is before the specified interval.\n     * <p>\n     * The result is true if the this instant ends before the start of the specified interval.\n     * Since intervals do not include their end points, this will return true if the\n     * two intervals abut.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Interval} interval  the other interval to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     */\n    isBeforeInterval(interval) {\n        return this._end.compareTo(interval.start()) <= 0 && !interval.equals(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the duration of this interval.\n     * <p>\n     * An {@code Interval} is associated with two specific instants on the time-line.\n     * A {@code Duration} is simply an amount of time, separate from the time-line.\n     *\n     * @return {Duration} the duration of the time interval\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}\n     */\n    toDuration() {\n        return Duration.between(this._start, this._end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this interval is equal to another interval.\n     * <p>\n     * Compares this {@code Interval} with another ensuring that the two instants are the same.\n     * Only objects of type {@code Interval} are compared, other types return false.\n     *\n     * @param {any} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other interval\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Interval) {\n            return this._start.equals(obj.start()) && this._end.equals(obj.end());\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this interval.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._start.hashCode() ^ this._end.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this interval as a {@code String}, such as {@code 2007-12-03T10:15:30/2007-12-04T10:15:30}.\n     * <p>\n     * The output will be the ISO-8601 format formed by combining the\n     * {@code toString()} methods of the two instants, separated by a forward slash.\n     *\n     * @return {string} a string representation of this instant, not null\n     */\n    toString() {\n        return this._start.toString() + '/' + this._end.toString();\n    }\n\n}\n\nlet _initialized = false;\n\nexport function _init() {\n    \n    Interval.ALL = Interval.of(Instant.MIN, Instant.MAX);\n    _initialized = true;\n}\n\nexport function _plugin(jsJoda) {\n    if (!_initialized) {\n        _init();\n    }\n    jsJoda.Interval = Interval;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Interval.js","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"amd\":\"js-joda\",\"commonjs\":\"js-joda\",\"commonjs2\":\"js-joda\",\"root\":\"JSJoda\"}\n// module id = 3\n// module chunks = 0","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {NullPointerException, IllegalArgumentException} from './errors';\n\nexport function assert(assertion, msg, error) {\n    if(!assertion){\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(parameterName + ' must not be null');\n    }\n    return value;\n}\n\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));\n    }\n    return value;\n}\n\nexport function abstractMethodFail(methodName){\n    throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\n\n\n// WEBPACK FOOTER //\n// ./src/assert.js","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init, superErrorClass = Error) {\n    function E(message) {\n        if (!Error.captureStackTrace){\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n\n    }\n    E.prototype = new superErrorClass();\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    return E;\n}\n\nexport var DateTimeException = createErrorType('DateTimeException', messageWithCause);\nexport var DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nexport var UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nexport var ArithmeticException = createErrorType('ArithmeticException');\nexport var IllegalArgumentException = createErrorType('IllegalArgumentException');\nexport var IllegalStateException = createErrorType('IllegalStateException');\nexport var NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause = null) {\n    let msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text = '', index = 0, cause = null) {\n    let msg = message || this.name;\n    msg += ': ' + text + ', at index: ' + index;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n    this.parsedString = () => {\n        return text;\n    };\n    this.errorIndex = () => {\n        return index;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/errors.js"],"sourceRoot":""}