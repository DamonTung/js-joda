{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 571f188ccccb3d756817","webpack:///./src/js-joda-timezone.js","webpack:///./src/MomentZoneRulesProvider.js","webpack:///external {\"amd\":\"js-joda\",\"commonjs\":\"js-joda\",\"commonjs2\":\"js-joda\",\"root\":\"JSJoda\"}","webpack:///./src/MomentZoneRules.js"],"names":["jsJoda","ZoneRulesProvider","MomentZoneRulesProvider","getRules","zoneId","getAvailableZoneIds","MomentZoneRules","_zoneId","isFixedOffset","offset","instantOrLocalDateTime","offsetOfInstant","offsetOfLocalDateTime","instant","tbc","offsetOfEpochMilli","epochMilli","localDateTime","validOffsets","transition","standardOffset","daylightSavings","isDaylightSavings","isValidOffset","nextTransition","previousTransition","transitions","transitionRules","equals","other","toString","msg","Error"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;mBCpCe,UAASA,MAAT,EAAiB;AAC5BA,YAAOC,iBAAP;AACA,YAAOD,MAAP;AACH,E;;AALD,uD;;;;;;;;;;;ACAA;;AAEA;;;;;;;;KAEaE,uB,WAAAA,uB;;;;;;;;;6BAWFC,Q,qBAASC,M,EAAO;AACnB,gBAAO,qCAAoBA,MAApB,CAAP;AACH,M;;6BAUMC,mB,kCAAqB;AACxB,gBAAO,EAAP;AACH,M;;;;;;;;;AC7BL,gD;;;;;;;;;;;ACAA;;;;;;;;KAGaC,e,WAAAA,e;;;AAKT,8BAAYF,MAAZ,EAAmB;AAAA;;AAAA,sDACf,qBADe;;AAEf,eAAKG,OAAL,GAAeH,MAAf;AAFe;AAGlB;;+BAQDI,a,4BAAe;AACX,gBAAO,KAAP;AACH,M;;+BASDC,M,mBAAOC,sB,EAAuB;AAC1B,aAAGA,iDAAH,EAA6C;AACzC,oBAAO,KAAKC,eAAL,CAAqBD,sBAArB,CAAP;AACH,UAFD,MAEO;AACH,oBAAO,KAAKE,qBAAL,CAA2BF,sBAA3B,CAAP;AACH;AACJ,M;;+BAaDC,e,4BAAgBE,O,EAAQ;AACpBC,aAAI,yBAAJ;AACH,M;;+BAWDC,kB,+BAAmBC,U,EAAW;AAC1BF,aAAI,8BAAJ;AACH,M;;+BA+BDF,qB,kCAAsBK,a,EAAc;AAChCH,aAAI,+BAAJ;AACH,M;;+BA4CDI,Y,yBAAaD,a,EAAc;AACvBH,aAAI,wBAAJ;AACH,M;;+BAoCDK,U,uBAAWF,a,EAAc;AACrBH,aAAI,sBAAJ;AACH,M;;+BAeDM,c,2BAAeP,O,EAAQ;AACnBC,aAAI,0BAAJ;AACH,M;;+BAeDO,e,4BAAgBR,O,EAAQ;AACpBC,aAAI,2BAAJ;AAMH,M;;+BAWDQ,iB,8BAAkBT,O,EAAS;AACvBC,aAAI,6BAAJ;AAIH,M;;+BAaDS,a,0BAAcN,a,EAAeR,M,EAAO;AAChCK,aAAI,yBAAJ;AACH,M;;+BAcDU,c,2BAAeX,O,EAAQ;AACnBC,aAAI,0BAAJ;AACH,M;;+BAaDW,kB,+BAAmBZ,O,EAAQ;AACvBC,aAAI,8BAAJ;AACH,M;;+BAcDY,W,0BAAa;AACTZ,aAAI,uBAAJ;AACH,M;;+BAuBDa,e,8BAAiB;AACbb,aAAI,2BAAJ;AACH,M;;+BAODc,M,mBAAOC,K,EAAO;AACV,aAAI,SAASA,KAAb,EAAoB;AAChB,oBAAO,IAAP;AACH;AACD,aAAIA,iBAAiBvB,eAArB,EAAsC;AAClC,oBAAO,KAAKC,OAAL,KAAiBsB,MAAMtB,OAA9B;AACH;AACD,gBAAO,KAAP;AACH,M;;+BAMDuB,Q,uBAAW;AACP,gBAAO,KAAKvB,OAAZ;AACH,M;;;;;AAGL,UAASO,GAAT,CAAaiB,GAAb,EAAiB;AACb,WAAM,IAAIC,KAAJ,CAAU,0BAA0BD,GAApC,CAAN;AACH,E","file":"js-joda-timezone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"js-joda\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"js-joda\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSJoda\"] = factory(require(\"js-joda\"));\n\telse\n\t\troot[\"JSJoda\"] = factory(root[\"JSJoda\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 571f188ccccb3d756817","import {MomentZoneRulesProvider} from './MomentZoneRulesProvider';\n\nexport default function(jsJoda) {\n    jsJoda.ZoneRulesProvider = MomentZoneRulesProvider;\n    return jsJoda;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/js-joda-timezone.js","import { ZoneRulesProvider } from 'js-joda';\n\nimport { MomentZoneRules } from './MomentZoneRules';\n\nexport class MomentZoneRulesProvider extends ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     * <p>\n     * This returns the latest available rules for the zone ID.\n     * <p>\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        return new MomentZoneRules(zoneId);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     * <p>\n     * These zone IDs are loaded and available for use by {@code ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return [];\n    }\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/MomentZoneRulesProvider.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"amd\":\"js-joda\",\"commonjs\":\"js-joda\",\"commonjs2\":\"js-joda\",\"root\":\"JSJoda\"}\n// module id = 2\n// module chunks = 0","import { Instant } from 'js-joda';\nimport { ZoneRules } from 'js-joda';\n\nexport class MomentZoneRules extends ZoneRules{\n    /**\n     *\n     * @param {string} zoneId\n     */\n    constructor(zoneId){\n        super();\n        this._zoneId = zoneId;\n    }\n\n\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     *\n     * @param instantOrLocalDateTime\n     * @returns {ZoneOffset}\n     */\n    offset(instantOrLocalDateTime){\n        if(instantOrLocalDateTime instanceof Instant){\n            return this.offsetOfInstant(instantOrLocalDateTime);\n        } else {\n            return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n        }\n    }\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     * <p>\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfInstant(instant){\n        tbc('ZoneRules.offsetInstant');\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfEpochMilli(epochMilli){\n        tbc('ZoneRules.offsetOfEpochMilli');\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     * <p>\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    offsetOfLocalDateTime(localDateTime){\n        tbc('ZoneRules.offsetLocalDateTime');\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     * <p>\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    validOffsets(localDateTime){\n        tbc('ZoneRules.validOffsets');\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    transition(localDateTime){\n        tbc('ZoneRules.transition');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    standardOffset(instant){\n        tbc('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    daylightSavings(instant){\n        tbc('ZoneRules.daylightSavings');\n        //    default {\n        //        ZoneOffset standardOffset = getStandardOffset(instant);\n        //        ZoneOffset actualOffset = getOffset(instant);\n        //        return actualOffset.toDuration().minus(standardOffset.toDuration()).normalized();\n        //    }\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     * <p>\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    isDaylightSavings(instant) {\n        tbc('ZoneRules.isDaylightSavings');\n        //    default {\n        //        return (getStandardOffset(instant).equals(getOffset(instant)) == false);\n        //    }\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     * <p>\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    isValidOffset(localDateTime, offset){\n        tbc('ZoneRules.isValidOffset');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     * <p>\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    nextTransition(instant){\n        tbc('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     * <p>\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    previousTransition(instant){\n        tbc('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitionRules()}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        tbc('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitions()}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     * <p>\n     * For any given {@code ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     * <p>\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        tbc('ZoneRules.transitionRules');\n    }\n\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof MomentZoneRules) {\n            return this._zoneId === other._zoneId;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this._zoneId;\n    }\n}\n\nfunction tbc(msg){\n    throw new Error('not yet implemented: ' + msg);    \n}\n\n\n// WEBPACK FOOTER //\n// ./src/MomentZoneRules.js"],"sourceRoot":""}